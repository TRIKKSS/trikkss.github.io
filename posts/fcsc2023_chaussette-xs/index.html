<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FCSC 2023 - chaussette (XS) | TRIKKSS Blog</title><meta name=keywords content="Reverse engineering,Linux,Miasm"><meta name=description content="Write up du challenge chaussette (XS)."><meta name=author content="TRIKKSS"><link rel=canonical href=https://trikkss.github.io/posts/fcsc2023_chaussette-xs/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=16x16 href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=32x32 href=https://trikkss.github.io/img/pfp.png><link rel=apple-touch-icon href=https://trikkss.github.io/img/pfp.png><link rel=mask-icon href=https://trikkss.github.io/img/pfp.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="FCSC 2023 - chaussette (XS)"><meta property="og:description" content="Write up du challenge chaussette (XS)."><meta property="og:type" content="article"><meta property="og:url" content="https://trikkss.github.io/posts/fcsc2023_chaussette-xs/"><meta property="og:image" content="https://trikkss.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-30T00:00:00+00:00"><meta property="og:site_name" content="TRIKKSS Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trikkss.github.io/img/pfp.png"><meta name=twitter:title content="FCSC 2023 - chaussette (XS)"><meta name=twitter:description content="Write up du challenge chaussette (XS)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://trikkss.github.io/posts/"},{"@type":"ListItem","position":2,"name":"FCSC 2023 - chaussette (XS)","item":"https://trikkss.github.io/posts/fcsc2023_chaussette-xs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FCSC 2023 - chaussette (XS)","name":"FCSC 2023 - chaussette (XS)","description":"Write up du challenge chaussette (XS).","keywords":["Reverse engineering","Linux","Miasm"],"articleBody":"vous pouvez retrouver le binaire ici\nCe challenge est une version simplifiée d’un challenge nommé “chaussette”, durant la résolution de sa version compliquée j’ai appris à utiliser miasm, un framework de reverse engineering que j’ai trouvé très intéressant malgré le peu de documentation. J’ai donc décidé de proposer une solution utilisant miasm.\nDécouverte du challenge Pour ce challenge, un binaire nous est donné. La commande file permet d’en apprendre un peu plus à son sujet.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ file chaussette-xs\rchaussette-xs: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=913fe53d14998feda6a550d5a815830cf4ab132f, for GNU/Linux 3.2.0, stripped On apprend donc que l’on a un ELF x86-64. On va donc l’ouvrir dans ghidra afin d’avoir de comprendre ce qu’il fait plus précisemment.\nvoid FUN_00102140(undefined8 param_1,undefined8 param_2,undefined8 param_3) { undefined8 unaff_retaddr; undefined auStack_8 [8]; __libc_start_main(FUN_00102000,unaff_retaddr,\u0026stack0x00000008,FUN_00103230,FUN_00103290,param_3, auStack_8); do { /* WARNING: Do nothing block with infinite loop */ } while( true ); } On regard donc le point d’entrée du binaire afin de trouver la fonction main de l’application.\nIci, l’appel à la fonction libc_start_main de la libc nous permet de récuperer notre fonction principale qui sera donc FUN_00102000 .\nOn va de suite la renommer afin d’y voir plus clair et de la retrouver plus facilement (clic droit sur la fonction -\u003e Rename function).\nOn arrive donc sur le code principal de notre fonction qui est assez simple à comprendre.\nundefined8 main(void) { int iVar1; long lVar2; undefined8 *puVar3; ulong *puVar4; ulong uVar5; ulong *puVar6; undefined8 *puVar7; byte bVar8; ulong local_18; undefined8 local_10; bVar8 = 0; lVar2 = sysconf(0x1e); if (lVar2 == 0x1000) { puVar3 = (undefined8 *)mmap((void *)0x0,0x100000,7,0x22,-1,0); DAT_001061b0 = puVar3; *puVar3 = 0x1a22d2ea22d1b848; *(undefined8 *)((long)puVar3 + 0xf9) = 0xc3f83148b12e2565; lVar2 = (long)puVar3 - (long)(undefined8 *)((ulong)(puVar3 + 1) \u0026 0xfffffffffffffff8); puVar7 = (undefined8 *)((long)\u0026DAT_001060a0 - lVar2); puVar3 = (undefined8 *)((ulong)(puVar3 + 1) \u0026 0xfffffffffffffff8); for (uVar5 = (ulong)((int)lVar2 + 0x101U \u003e\u003e 3); uVar5 != 0; uVar5 = uVar5 - 1) { *puVar3 = *puVar7; puVar7 = puVar7 + (ulong)bVar8 * -2 + 1; puVar3 = puVar3 + (ulong)bVar8 * -2 + 1; } __isoc99_scanf(\u0026DAT_00104004,\u0026local_18); __isoc99_scanf(\u0026DAT_00104004,\u0026local_10); lVar2 = (*(code *)DAT_001061b0)(local_18,local_10); if (lVar2 == 0) { iVar1 = mprotect(FUN_00103000,0x400,7); if (iVar1 != -1) { puVar4 = (ulong *)FUN_00103000; uVar5 = local_18; do { *puVar4 = *puVar4 ^ uVar5; puVar6 = puVar4 + -0x205ff; uVar5 = uVar5 * 0x5851f42d4c957f2d + 0x14057b7ef767814f; puVar4 = puVar4 + 1; } while (puVar6 \u003c (ulong *)0x1f8); FUN_00103000(DAT_001061b0,local_18,local_10); } } } return 0; } Il va dans un premier temps allouer 0x100000 octets sur le tas avec les droits de lecture, d’écriture et d’execution grâce à la fonction mmap\nIl va ensuite effectuer certaines opérations afin d’écrire des données dans la mémoire allouée, on ne s’attardera pas dessus.\nPuis le programme va demander à l’utilisateur 2 entrées. Si l’on regard à l’addresse DAT_00104004 on peut voir qu’elle pointe vers la chaine de caractères : “%lu” ce qui signifie que la fonction scanf va demander à l’utilisateur 2 entiers non signés de 64 bytes.\nEnfin, il va appeler le code placé dans la mémoire allouée précedemment avec comme paramètres les 2 valeurs entrées par l’utilisateur.\nEn fonction du résultat de cette fonction il va continuer l’execution du programme ou non. On comprend donc rapidemment que notre première épreuve va être de trouver les entrées correctes afin que cette fonction retourne 0.\nA la suite de cette fonction, si les valeurs entrées sont correctes le binaire va appeler la fonction mprotect() afin d’ajouter les droits d’écriture sur la fonction FUN_00103000 et va ensuite modifier son contenu. Un fois le code de la fonction modifié, il va l’appeler comme argument l’addresse de notre mémoire précedemment allouée ainsi que nos 2 entrées utilisateur.\npremier shellcode La première étape de ce crackme va donc être de trouver les valeurs correcte afin que le code placé en mémoire retourne 0. On va donc utiliser un debugger afin de placer un point d’arrêt au moment de l’appel à la fonction et de récuperer son code.\nPour ma part j’utilise gdb.\nPetite astuce d’ailleurs si vous utilisez comme moi ghidra pour décompiler votre code et gdb pour debugger, vous pouvez changer la base address dans ghidra afin que vos addresses soit les mêmes entre ghidra et votre debugger. Il suffit d’aller dans Window -\u003e Memory map ensuite vous cliqué sur la petite maison et changer l’addresse de la base du binaire.\non lance donc gdb, on place notre point d’arret et on lance notre binaire.\n(gdb) b*0x5555555560aa\rBreakpoint 1 at 0x5555555560aa\r(gdb) run\rStarting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs\r[Thread debugging using libthread_db enabled]\rUsing host libthread_db library \"/usr/lib/libthread_db.so.1\".\r123\r123\rBreakpoint 1, 0x00005555555560aa in ?? ()\r(gdb) x/i $rip\r=\u003e 0x5555555560aa: call QWORD PTR [rip+0x4100] # 0x55555555a1b0 On peut voir qu’on est bel et bien arrété avant l’appel à la fonction.\nLa commande x/i address permet de décoder les opcodes présent à une addresse.\nOn va donc pouvoir afficher notre shellcode grâce à cette commande.\nAttention, ici le code ne se trouve pas à l’addresse mais à l’addresse pointée par celle ci.\n(gdb) x/gx 0x55555555a1b0\r0x55555555a1b0: 0x00007ffff7cc5000\r(gdb) x/100i 0x00007ffff7cc5000\r0x7ffff7cc5000: movabs rax,0x33a11a22d2ea22d1\r[...]\r0x7ffff7cc50ed: mul rdi\r0x7ffff7cc50f0: mov rdi,rax\r0x7ffff7cc50f3: movabs rax,0xb12e2565d1efe9f8\r0x7ffff7cc50fd: xor rax,rdi\r0x7ffff7cc5100: ret On a donc un joli code assembleur, maintenant il faut le résoudre. On remarque d’ailleurs qu’il utilise une seule des entrées utilisateur dans cette fonction. Ce sera de même tout le long du programme, la seconde entrée n’est pas utilisée.\nmovabs rax,0x33a11a22d2ea22d1 sub rdi,rax dec rdi movabs rax,0x94224bcad3296113 or rax,0x1 mul rdi mov rdi,rax dec rdi movabs rax,0xd3b1bf2d4d1d294a sub rdi,rax movabs rax,0xbe35746c05e956a9 add rdi,rax movabs rax,0x5819ea9fcbc8779 xor rdi,rax dec rdi movabs rax,0x7f7965e1baca6c8f sub rdi,rax neg rdi ror rdi,0xd movabs rax,0x4368955c512ca39b sub rdi,rax inc rdi neg rdi ror rdi,0x32 movabs rax,0x96ccb75bd569807d sub rdi,rax inc rdi movabs rax,0x9f40cb3b786d6842 or rax,0x1 mul rdi mov rdi,rax ror rdi,0x14 neg rdi neg rdi movabs rax,0x1fd3e4098240e723 add rdi,rax movabs rax,0xda3d1c27bae9522c sub rdi,rax rol rdi,0x36 inc rdi inc rdi dec rdi rol rdi,0x21 rol rdi,0x38 dec rdi neg rdi movabs rax,0xc88d84433f7b14e7 or rax,0x1 mul rdi mov rdi,rax movabs rax,0xb12e2565d1efe9f8 xor rax,rdi ret Il n’est pas très compliqué et aurait pu facilement être résolu à la main, néanmoins pour cette solution on utilisera miasm.\nOn va dump les octets de ce code dans un fichier, gdb nous permet de le faire grâce à sa commande dump\n(gdb) dump binary memory bytcodes_function 0x7ffff7cc5000 0x7ffff7cc5101 Je vous invite donc maintenant à installer miasm.\nRésolution avec Miasm Pour cette partie nous allons utiliser le framework miasm afin de résoudre ce code.\nVoici mon code permettant de trouver les entrées correctes à notre fonction. J’ai commenté le code au maximum, néanmoins je vais quand même vous résumer son fonctionnement afin d’être sur que tout le monde comprenne.\nLe programme va dans un premier temps lire les octets que l’on a dump précedemmemnt, les interpreter puis lancer une execution symbolique sur notre code. A la suite de cette exécution symbolique il va récuperer l’expression symbolique du registre RAX, qui est le registre qui contient notre valeur de retour et la transformer en contrainte compréhensible par z3. A partir de là on va simplifier cette expression et la résoudre.\nfrom miasm.analysis.machine import Machine from miasm.core.locationdb import LocationDB from miasm.analysis.binary import Container from miasm.expression.expression import * from miasm.ir.symbexec import SymbolicExecutionEngine from miasm.ir.translators.z3_ir import TranslatorZ3 from miasm.arch.x86.lifter_model_call import LifterModelCall_x86_64 from miasm.analysis.simplifier import * from miasm.expression.simplifications import expr_simp, ExpressionSimplifier from z3 import * import re def solve_shellcode(shellcode): # on créé une nouvelle location pour notre shellcode loc_db = LocationDB() # on load notre shellcode (nos bytes code) container = Container.from_string(shellcode, loc_db) machine = Machine('x86_64') ira = machine.lifter(loc_db) dis_engine = machine.dis_engine(container.bin_stream, loc_db=loc_db) start_addres = 0 # https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb asm_cfg = dis_engine.dis_multiblock(start_addres) ira_cfg = ira.new_ircfg_from_asmcfg(asm_cfg) \"\"\" # on peut utiliser ce bout de code pour afficher les instructions assembleurs. for block in asm_cfg.blocks: print(block) \"\"\" init_state = {} # on definit ici RDI qui va contenir la valeur en entrée. init_state[ExprId(\"RDI\", 64)] = ExprId('input', 64) # rax qui est censé être égal à 0 à la fin du script. init_state[ExprId(\"RAX\", 64)] = ExprId('result', 64) # on lance l'execution symbolique. sb = SymbolicExecutionEngine(LifterModelCall_x86_64(loc_db) , state=init_state) sb.run_at(ira_cfg, addr=start_addres) # on va transformer l'expression symbolique en contraintes pour z3 trans = TranslatorZ3(loc_db=loc_db) # solveur basique z3 s = Solver() # on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall) expr_simp_cond = ExpressionSimplifier() expr_simp_cond.enable_passes(ExpressionSimplifier.PASS_COND) # récuperer l'expression symbolique (+ la simplifiée.) expr_rax = sb.eval_expr(expr_simp(expr_simp_cond(ExprId('RAX', 64)))) # on solve avec z3 s.add(trans.from_expr(expr_rax) == trans.from_expr(ExprInt(0, 64))) if s.check() == sat: # print(\"found\") model = s.model() # on retourne le resultat # (j'ai honte de mon parsing mais je n'arrivais pas récuperer cette valeur correctement ...) return int(re.findall(\"[0-9]+\", str(model))[0]) else: print(\"[-] fail\") return 0 # on ouvre le fichier contenant les octets de notre code assembleur with open(\"bytcodes_function\", \"rb\") as file: content = file.read() result = solve_shellcode(content) if result: print(f\"[+] solution found : {result}\") On va donc executer notre programme et l’on récupère bel et bien une valeur.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ python3 solve_first_shellcode.py\r[+] solution found : 14171339039947875846 On peut entrer ces valeurs dans notre binaire et effectivemment notre script passe la première condition avec succès !\nVous croyez que c’était fini ? c’est que le début. On passe donc à la deuxième fonction. Comme précédemment, on place notre breakpoint avant l’appel à la fonction et on l’affiche.\n(gdb) b*0x000055555555612c\rBreakpoint 1 at 0x55555555612c\r(gdb) run\rStarting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs\r[Thread debugging using libthread_db enabled]\rUsing host libthread_db library \"/usr/lib/libthread_db.so.1\".\r14171339039947875846\r123\rBreakpoint 1, 0x000055555555612c in ?? ()\r(gdb) x/i $rip\r=\u003e 0x55555555612c: call 0x555555557000\r(gdb) x/110i 0x555555557000\r0x555555557000: movabs rax,0x676e656c6c616863\r0x55555555700a: push r15\r0x55555555700c: push r14\r0x55555555700e: push r13\r0x555555557010: push r12\r0x555555557012: push rbp\r0x555555557013: push rbx\r0x555555557014: mov rbx,rdi\r0x555555557017: lea rdi,[rip+0xfea] # 0x555555558008\r0x55555555701e: sub rsp,0x68\r0x555555557022: movdqa xmm0,XMMWORD PTR [rip+0xfe6] # 0x555555558010\r0x55555555702a: mov QWORD PTR [rsp+0x8],rsi\r0x55555555702f: movups XMMWORD PTR [rsp+0x30],xmm0\r0x555555557034: movdqa xmm0,XMMWORD PTR [rip+0xfe4] # 0x555555558020\r0x55555555703c: mov QWORD PTR [rsp],rdx\r0x555555557040: mov QWORD PTR [rsp+0x50],rax\r0x555555557045: mov DWORD PTR [rsp+0x58],0x72662e65\r0x55555555704d: mov BYTE PTR [rsp+0x5c],0x0\r0x555555557052: movups XMMWORD PTR [rsp+0x40],xmm0\r0x555555557057: call 0x5555555550a0 0x55555555705c: test rax,rax\r0x55555555705f: je 0x5555555571bf\r0x555555557065: mov edx,DWORD PTR [rax+0x10]\r0x555555557068: mov esi,0x1\r0x55555555706d: mov edi,0x2\r0x555555557072: call 0x5555555550f0 0x555555557077: mov DWORD PTR [rip+0x313b],eax # 0x55555555a1b8\r0x55555555707d: cmp eax,0xffffffff\r0x555555557080: je 0x5555555571bf\r0x555555557086: lea rdi,[rsp+0x30]\r0x55555555708b: call 0x555555555090 0x555555557090: test rax,rax\r0x555555557093: je 0x5555555571bf\r0x555555557099: mov rax,QWORD PTR [rax+0x18]\r0x55555555709d: mov rax,QWORD PTR [rax]\r0x5555555570a0: mov edi,DWORD PTR [rax]\r0x5555555570a2: call 0x555555555050 0x5555555570a7: mov rdi,rax\r0x5555555570aa: call 0x555555555080 0x5555555570af: cmp eax,0xffffffff\r0x5555555570b2: je 0x5555555571bf\r0x5555555570b8: mov edi,DWORD PTR [rip+0x30fa] # 0x55555555a1b8\r0x5555555570be: lea rsi,[rsp+0x20]\r0x5555555570c3: mov DWORD PTR [rsp+0x24],eax\r0x5555555570c7: mov edx,0x10\r0x5555555570cc: mov DWORD PTR [rsp+0x20],0xcd080002\r0x5555555570d4: call 0x5555555550e0 0x5555555570d9: cmp eax,0xffffffff\r0x5555555570dc: je 0x5555555571bf\r0x5555555570e2: lea r12,[rsp+0x18]\r0x5555555570e7: lea r13,[rsp+0x10]\r0x5555555570ec: lea r14,[rsp+0x8]\r0x5555555570f1: nop DWORD PTR [rax+0x0]\r0x5555555570f8: mov rax,QWORD PTR [rsp+0x8]\r0x5555555570fd: mov edi,DWORD PTR [rip+0x30b5] # 0x55555555a1b8\r0x555555557103: mov edx,0x8\r0x555555557108: mov rsi,r12\r0x55555555710b: mov QWORD PTR [rsp+0x18],rax\r0x555555557110: call 0x555555555040 0x555555557115: mov rax,QWORD PTR [rsp]\r0x555555557119: mov edx,0x8\r0x55555555711e: mov rsi,r12\r0x555555557121: mov edi,DWORD PTR [rip+0x3091] # 0x55555555a1b8\r0x555555557127: mov QWORD PTR [rsp+0x18],rax\r0x55555555712c: call 0x555555555040 0x555555557131: mov edi,DWORD PTR [rip+0x3081] # 0x55555555a1b8\r0x555555557137: mov edx,0x8\r0x55555555713c: mov rsi,r13\r0x55555555713f: call 0x555555555070 0x555555557144: mov rbp,QWORD PTR [rsp+0x10]\r0x555555557149: cmp rbp,0xffffffffffffffff\r0x55555555714d: je 0x5555555571ce\r0x55555555714f: mov r15,rbx\r0x555555557152: test rbp,rbp\r0x555555557155: jne 0x55555555716e\r0x555555557157: jmp 0x555555557189\r0x555555557159: nop DWORD PTR [rax+0x0]\r0x555555557160: add r15,rax\r0x555555557163: mov rax,r15\r0x555555557166: sub rax,rbx\r0x555555557169: cmp rax,rbp\r0x55555555716c: jae 0x555555557189\r0x55555555716e: mov edi,DWORD PTR [rip+0x3044] # 0x55555555a1b8\r0x555555557174: xor ecx,ecx\r0x555555557176: mov edx,0x1000\r0x55555555717b: mov rsi,r15\r0x55555555717e: call 0x555555555030 0x555555557183: cmp rax,0xffffffffffffffff\r0x555555557187: jne 0x555555557160\r0x555555557189: mov rsi,r14\r0x55555555718c: lea rdi,[rip+0xe71] # 0x555555558004\r0x555555557193: xor eax,eax\r0x555555557195: call 0x5555555550d0 \u003c__isoc99_scanf@plt\u003e\r0x55555555719a: mov rsi,rsp\r0x55555555719d: lea rdi,[rip+0xe60] # 0x555555558004\r0x5555555571a4: xor eax,eax\r0x5555555571a6: call 0x5555555550d0 \u003c__isoc99_scanf@plt\u003e\r0x5555555571ab: mov rsi,QWORD PTR [rsp]\r0x5555555571af: mov rdi,QWORD PTR [rsp+0x8]\r0x5555555571b4: call rbx\r0x5555555571b6: test rax,rax\r0x5555555571b9: je 0x5555555570f8\r0x5555555571bf: add rsp,0x68\r0x5555555571c3: pop rbx\r0x5555555571c4: pop rbp\r0x5555555571c5: pop r12\r0x5555555571c7: pop r13\r0x5555555571c9: pop r14\r0x5555555571cb: pop r15\r0x5555555571cd: ret cette fonction peut paraître effrayante aux premiers abords, mais elle est en réalité plutôt simple. On peut d’abord voir les appels aux fonctions de la libc tels que socket, connect, recv etc.\nElle va établir une connexion tcp avec un serveur distant, lui envoyer nos 2 valeurs entrées précédemment et récuperer des données que le serveur lui envoie. Les octets que la fonction récupère vont être placés à l’addresse de notre précédente fonction. Ensuite le programme va demander à nouveau 2 entrées à l’utilisateur et appeler notre nouvelle fonction avec les valeurs données par l’utlisateur et recommencer.\nOn pourrait représenter le fonctionnement de cette fonction par le pseudo code suivant :\nvoid strange_function(char* shellcode, ulong value1, ulong value2) { conn = connexion(); // établit une connexion tcp avec le serveur while (1) { size = read(conn, 8); // lit 8 octets qui seront la taille du shellcode *shellcode = recv(conn) // reçois le shellcode et l'écris à // l'addresse de l'ancien shellcode // récupère les 2 entrées utilisateur scanf(\"%lu\", \u0026value1); scanf(\"%lu\", \u0026value2); // verifie que les entrées résolve le shellcode. // pareil que la première partie du challenge. if ((*(void(*)())shellcode)(value1, value2) != 0) { // signifie que notre entrée est fausse // le programme se stoppe. (et donc par conséquent pas de flag) return; } } } On va donc récuperer l’IP et le port afin de créer nous même la connexion tcp avec le serveur distant, lui envoyer nos valeurs et récuperer les shellcodes.\nPour récuperer l’ip et le port on pourrait placer un point d’arret au niveau de l’appel à la fonction getprotobyname et au niveau de la fonction socket . Mais étant flemmard (ou malin à vous de me dire) j’ai préféré regarder les connexions ouvertes sur ma machine par le processus en question.\nPour ce faire j’ai utilisé l’outil ss. J’execute donc mon binaire, je lui donne les valeurs trouvé précedemment afin qu’il établisse la connexion et ensuite avec la commande ss -nap | grep chaussette-xs je récupère l’ip et le port.\nLe serveur distant se trouve donc en 51.254.115.216:2253.\nRésoudre les shellcode avec miasm Après quelques tests on s’aperçoit qu’a chaque connexion le code renvoyé par le serveur change. On va donc implémenter un algorithme qui resout les fonctions donnée par le serveur distant.\nHeureusement nous avons déjà fait une grande partie du travail, en effet nous avons implémenté durant la première partie une fonction qui utilise miasm afin de résoudre les shellcodes. Nous avons donc a configurer la connexion avec le serveur et ensuite résoudre les instructions que le serveur nous enverra.\nVoici mon code :\nfrom pwn import * from miasm.analysis.machine import Machine from miasm.core.locationdb import LocationDB from miasm.analysis.binary import Container from miasm.expression.expression import * from miasm.ir.symbexec import SymbolicExecutionEngine from miasm.ir.translators.z3_ir import TranslatorZ3 from miasm.arch.x86.lifter_model_call import LifterModelCall_x86_64 from miasm.analysis.simplifier import * from miasm.expression.simplifications import expr_simp, ExpressionSimplifier from z3 import * import re def solve_shellcode(shellcode): # on créé une nouvelle location pour notre shellcode loc_db = LocationDB() # on load notre shellcode container = Container.from_string(shellcode, loc_db) machine = Machine('x86_64') ira = machine.lifter(loc_db) dis_engine = machine.dis_engine(container.bin_stream, loc_db=loc_db) start_addres = 0 # https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb asm_cfg = dis_engine.dis_multiblock(start_addres) ira_cfg = ira.new_ircfg_from_asmcfg(asm_cfg) \"\"\" # on peut utiliser ce bout de code pour afficher les instructions assembleurs. for block in asm_cfg.blocks: print(block) \"\"\" init_state = {} # on definit ici RDI qui va contenir la valeur en entrée. init_state[ExprId(\"RDI\", 64)] = ExprId('input', 64) # rax qui est censé être égal à 0 à la fin du script. init_state[ExprId(\"RAX\", 64)] = ExprId('result', 64) # on lance l'execution symbolique. sb = SymbolicExecutionEngine(LifterModelCall_x86_64(loc_db) , state=init_state) sb.run_at(ira_cfg, addr=start_addres) # on va transformer l'expression symbolique en contraintes pour z3 trans = TranslatorZ3(loc_db=loc_db) # solveur basique z3 s = Solver() # on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall) expr_simp_cond = ExpressionSimplifier() expr_simp_cond.enable_passes(ExpressionSimplifier.PASS_COND) # récuperer l'expression symbolique (+ la simplifiée.) expr_rax = sb.eval_expr(expr_simp(expr_simp_cond(ExprId('RAX', 64)))) # on solve avec z3 s.add(trans.from_expr(expr_rax) == trans.from_expr(ExprInt(0, 64))) if s.check() == sat: # print(\"found\") model = s.model() return int(re.findall(\"[0-9]+\", str(model))[0]) else: print(\"[-] fail\") print(shellcode) return 0 # j'ai placé mon breakpoint au final, je trouvai un hostname plus joli host = \"challenges.france-cybersecurity-challenge.fr\" port = 2253 data_1 = 14171339039947875846 data_2 = 0xdeadbeef # useless # on etablit la connection tcp. p = remote(host, port) compteur = 0 while 1: # on envoie notre solution ainsi que celle inutile pour ce challenge. p.send(data_1.to_bytes(8, \"little\")) p.send(data_2.to_bytes(8, \"little\")) size = int.from_bytes(p.recv(8), \"little\") shellcode = b\"\" print(f\"[~] shellcode of {size} bytes\") shellcode = p.recv(size) flag = re.findall(b\"FCSC{.*}\", shellcode) if flag: print(\"flag is : \", end=\"\") print(flag[0].decode()) exit() print(f\"[~] solving shellcode {compteur}...\") result = solve_shellcode(shellcode) if result: data_1 = result print(f\"[+] solution found : {data_1}\") compteur += 1 else: exit(1) # on ferme la connection p.close() Ce code va établir une connexion avec le serveur et tant qu’il ne trouve pas le flag dans les fonctions qu’il reçoit il va les résoudre et renvoyer la solution. Je ne pense pas qu’il est nécessaire que j’explique mon script en détail, il est très similaire au précédent.\nOn execute donc le script et au bout de quelques secondes le flag apparait.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs\r╰─➤ python3 solving_using_miasm.py\r[+] Opening connection to challenges.france-cybersecurity-challenge.fr on port 2253: Done\r[~] shellcode of 414 bytes\r[~] solving shellcode 0...\r[+] solution found : 16584048833465228239\r[~] shellcode of 444 bytes\r[~] solving shellcode 1...\r[+] solution found : 5460636808995531285\r[~] shellcode of 842 bytes\r[~] solving shellcode 2...\r[+] solution found : 3445377768356975671\r[~] shellcode of 810 bytes\r[~] solving shellcode 3...\r[+] solution found : 6412023629681526002\r[~] shellcode of 929 bytes\r[~] solving shellcode 4...\r[+] solution found : 1172201077721270149\r[~] shellcode of 18446744073709551615 bytes\rflag is : FCSC{2a86d6edc5d08afc03d2c9ef3e2ff83cd63e520ffbd716d96479df8147e6da5e}\r[*] Closed connection to challenges.france-cybersecurity-challenge.fr port 2253 Pour conclure J’ai trouvé ce challenge très intéressant, j’ai malheureusement été bloqué par son grand frère durant plusieurs jours sans le réussir. Il m’a néanmoins appris beaucoup de choses sur l’automatisation de l’analyse binaire. En effet j’ai toujours cru que les outils tels que angr, miasm et tout les solveurs de ce genre était pour les personnes qui ne voulaient pas réfléchir. C’était donc la première fois que j’utilisais miasm (et angr) et j’ai trouvé ça très intéressant. Cela m’a permis d’aborder un nouvel aspect du reverse engineering qui m’a l’air très complexe mais également très intéressant.\n","wordCount":"3058","inLanguage":"en","datePublished":"2023-04-30T00:00:00Z","dateModified":"2023-04-30T00:00:00Z","author":{"@type":"Person","name":"TRIKKSS"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://trikkss.github.io/posts/fcsc2023_chaussette-xs/"},"publisher":{"@type":"Organization","name":"TRIKKSS Blog","logo":{"@type":"ImageObject","url":"https://trikkss.github.io/img/pfp.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://trikkss.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://trikkss.github.io/img/pfp.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://trikkss.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://trikkss.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://trikkss.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://trikkss.github.io/posts/>Posts</a></div><h1 class=post-title>FCSC 2023 - chaussette (XS)</h1><div class=post-meta><span title='2023-04-30 00:00:00 +0000 UTC'>April 30, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3058 words&nbsp;·&nbsp;TRIKKSS</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#découverte-du-challenge>Découverte du challenge</a></li><li><a href=#premier-shellcode>premier shellcode</a></li><li><a href=#résolution-avec-miasm>Résolution avec Miasm</a></li><li><a href=#vous-croyez-que-cétait-fini--cest-que-le-début>Vous croyez que c&rsquo;était fini ? c&rsquo;est que le début.</a></li><li><a href=#résoudre-les-shellcode-avec-miasm>Résoudre les shellcode avec miasm</a></li><li><a href=#pour-conclure>Pour conclure</a></li></ul></nav></div></details></div><div class=post-content><p><em>vous pouvez retrouver le binaire <a href=/static/chaussette-xs>ici</a></em></p><p><em>Ce challenge est une version simplifiée d&rsquo;un challenge nommé &ldquo;chaussette&rdquo;, durant la résolution de sa version compliquée j&rsquo;ai appris à utiliser miasm, un framework de reverse engineering que j&rsquo;ai trouvé très intéressant malgré le peu de documentation. J&rsquo;ai donc décidé de proposer une solution utilisant miasm.</em></p><p><img loading=lazy src=/img/posts/fcsc2023-chaussette-xs/enonce.png alt></p><h2 id=découverte-du-challenge>Découverte du challenge<a hidden class=anchor aria-hidden=true href=#découverte-du-challenge>#</a></h2><p>Pour ce challenge, un binaire nous est donné. La commande <code>file</code> permet d&rsquo;en apprendre un peu plus à son sujet.</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs
╰─➤  file chaussette-xs
chaussette-xs: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=913fe53d14998feda6a550d5a815830cf4ab132f, for GNU/Linux 3.2.0, stripped
</code></pre><p>On apprend donc que l&rsquo;on a un ELF x86-64. On va donc l&rsquo;ouvrir dans <a href=https://ghidra-sre.org/>ghidra</a> afin d&rsquo;avoir de comprendre ce qu&rsquo;il fait plus précisemment.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FUN_00102140</span><span class=p>(</span><span class=n>undefined8</span> <span class=n>param_1</span><span class=p>,</span><span class=n>undefined8</span> <span class=n>param_2</span><span class=p>,</span><span class=n>undefined8</span> <span class=n>param_3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>undefined8</span> <span class=n>unaff_retaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>undefined</span> <span class=n>auStack_8</span> <span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>__libc_start_main</span><span class=p>(</span><span class=n>FUN_00102000</span><span class=p>,</span><span class=n>unaff_retaddr</span><span class=p>,</span><span class=o>&amp;</span><span class=n>stack0x00000008</span><span class=p>,</span><span class=n>FUN_00103230</span><span class=p>,</span><span class=n>FUN_00103290</span><span class=p>,</span><span class=n>param_3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>auStack_8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=cm>/* WARNING: Do nothing block with infinite loop */</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>while</span><span class=p>(</span> <span class=nb>true</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>On regard donc le point d&rsquo;entrée du binaire afin de trouver la fonction <em>main</em> de l&rsquo;application.</p><p>Ici, l&rsquo;appel à la fonction <code>libc_start_main</code> de la libc nous permet de récuperer notre fonction principale qui sera donc <code>FUN_00102000</code> .</p><p>On va de suite la renommer afin d&rsquo;y voir plus clair et de la retrouver plus facilement (clic droit sur la fonction -> Rename function).</p><p>On arrive donc sur le code principal de notre fonction qui est assez simple à comprendre.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>undefined8</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>iVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>long</span> <span class=n>lVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>undefined8</span> <span class=o>*</span><span class=n>puVar3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ulong</span> <span class=o>*</span><span class=n>puVar4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ulong</span> <span class=n>uVar5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ulong</span> <span class=o>*</span><span class=n>puVar6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>undefined8</span> <span class=o>*</span><span class=n>puVar7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>byte</span> <span class=n>bVar8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ulong</span> <span class=n>local_18</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>undefined8</span> <span class=n>local_10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>bVar8</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>lVar2</span> <span class=o>=</span> <span class=nf>sysconf</span><span class=p>(</span><span class=mh>0x1e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>lVar2</span> <span class=o>==</span> <span class=mh>0x1000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>puVar3</span> <span class=o>=</span> <span class=p>(</span><span class=n>undefined8</span> <span class=o>*</span><span class=p>)</span><span class=nf>mmap</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0x0</span><span class=p>,</span><span class=mh>0x100000</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>DAT_001061b0</span> <span class=o>=</span> <span class=n>puVar3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>puVar3</span> <span class=o>=</span> <span class=mh>0x1a22d2ea22d1b848</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>undefined8</span> <span class=o>*</span><span class=p>)((</span><span class=kt>long</span><span class=p>)</span><span class=n>puVar3</span> <span class=o>+</span> <span class=mh>0xf9</span><span class=p>)</span> <span class=o>=</span> <span class=mh>0xc3f83148b12e2565</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lVar2</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=n>puVar3</span> <span class=o>-</span> <span class=p>(</span><span class=kt>long</span><span class=p>)(</span><span class=n>undefined8</span> <span class=o>*</span><span class=p>)((</span><span class=n>ulong</span><span class=p>)(</span><span class=n>puVar3</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xfffffffffffffff8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puVar7</span> <span class=o>=</span> <span class=p>(</span><span class=n>undefined8</span> <span class=o>*</span><span class=p>)((</span><span class=kt>long</span><span class=p>)</span><span class=o>&amp;</span><span class=n>DAT_001060a0</span> <span class=o>-</span> <span class=n>lVar2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puVar3</span> <span class=o>=</span> <span class=p>(</span><span class=n>undefined8</span> <span class=o>*</span><span class=p>)((</span><span class=n>ulong</span><span class=p>)(</span><span class=n>puVar3</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xfffffffffffffff8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>uVar5</span> <span class=o>=</span> <span class=p>(</span><span class=n>ulong</span><span class=p>)((</span><span class=kt>int</span><span class=p>)</span><span class=n>lVar2</span> <span class=o>+</span> <span class=mh>0x101U</span> <span class=o>&gt;&gt;</span> <span class=mi>3</span><span class=p>);</span> <span class=n>uVar5</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>uVar5</span> <span class=o>=</span> <span class=n>uVar5</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=o>*</span><span class=n>puVar3</span> <span class=o>=</span> <span class=o>*</span><span class=n>puVar7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>puVar7</span> <span class=o>=</span> <span class=n>puVar7</span> <span class=o>+</span> <span class=p>(</span><span class=n>ulong</span><span class=p>)</span><span class=n>bVar8</span> <span class=o>*</span> <span class=o>-</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>puVar3</span> <span class=o>=</span> <span class=n>puVar3</span> <span class=o>+</span> <span class=p>(</span><span class=n>ulong</span><span class=p>)</span><span class=n>bVar8</span> <span class=o>*</span> <span class=o>-</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>__isoc99_scanf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>DAT_00104004</span><span class=p>,</span><span class=o>&amp;</span><span class=n>local_18</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>__isoc99_scanf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>DAT_00104004</span><span class=p>,</span><span class=o>&amp;</span><span class=n>local_10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lVar2</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>code</span> <span class=o>*</span><span class=p>)</span><span class=n>DAT_001061b0</span><span class=p>)(</span><span class=n>local_18</span><span class=p>,</span><span class=n>local_10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>lVar2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>iVar1</span> <span class=o>=</span> <span class=nf>mprotect</span><span class=p>(</span><span class=n>FUN_00103000</span><span class=p>,</span><span class=mh>0x400</span><span class=p>,</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>iVar1</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>puVar4</span> <span class=o>=</span> <span class=p>(</span><span class=n>ulong</span> <span class=o>*</span><span class=p>)</span><span class=n>FUN_00103000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>uVar5</span> <span class=o>=</span> <span class=n>local_18</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=o>*</span><span class=n>puVar4</span> <span class=o>=</span> <span class=o>*</span><span class=n>puVar4</span> <span class=o>^</span> <span class=n>uVar5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>puVar6</span> <span class=o>=</span> <span class=n>puVar4</span> <span class=o>+</span> <span class=o>-</span><span class=mh>0x205ff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>uVar5</span> <span class=o>=</span> <span class=n>uVar5</span> <span class=o>*</span> <span class=mh>0x5851f42d4c957f2d</span> <span class=o>+</span> <span class=mh>0x14057b7ef767814f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>puVar4</span> <span class=o>=</span> <span class=n>puVar4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>puVar6</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>ulong</span> <span class=o>*</span><span class=p>)</span><span class=mh>0x1f8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>FUN_00103000</span><span class=p>(</span><span class=n>DAT_001061b0</span><span class=p>,</span><span class=n>local_18</span><span class=p>,</span><span class=n>local_10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Il va dans un premier temps allouer <code>0x100000</code> octets sur le tas avec les droits de <em>lecture</em>, <em>d&rsquo;écriture</em> et <em>d&rsquo;execution</em> grâce à la fonction <code>mmap</code></p><p>Il va ensuite effectuer certaines opérations afin d&rsquo;écrire des données dans la mémoire allouée, on ne s&rsquo;attardera pas dessus.</p><p>Puis le programme va demander à l&rsquo;utilisateur 2 entrées. Si l&rsquo;on regard à l&rsquo;addresse <code>DAT_00104004</code> on peut voir qu&rsquo;elle pointe vers la chaine de caractères : &ldquo;%lu&rdquo; ce qui signifie que la fonction <code>scanf</code> va demander à l&rsquo;utilisateur 2 entiers non signés de 64 bytes.</p><p>Enfin, il va appeler le code placé dans la mémoire allouée précedemment avec comme paramètres les 2 valeurs entrées par l&rsquo;utilisateur.</p><p>En fonction du résultat de cette fonction il va continuer l&rsquo;execution du programme ou non. On comprend donc rapidemment que notre première épreuve va être de trouver les entrées correctes afin que cette fonction retourne 0.</p><p>A la suite de cette fonction, si les valeurs entrées sont correctes le binaire va appeler la fonction <code>mprotect()</code> afin d&rsquo;ajouter les droits d&rsquo;écriture sur la fonction <code>FUN_00103000</code> et va ensuite modifier son contenu. Un fois le code de la fonction modifié, il va l&rsquo;appeler comme argument l&rsquo;addresse de notre mémoire précedemment allouée ainsi que nos 2 entrées utilisateur.</p><h2 id=premier-shellcode>premier shellcode<a hidden class=anchor aria-hidden=true href=#premier-shellcode>#</a></h2><p>La première étape de ce crackme va donc être de trouver les valeurs correcte afin que le code placé en mémoire retourne 0. On va donc utiliser un debugger afin de placer un point d&rsquo;arrêt au moment de l&rsquo;appel à la fonction et de récuperer son code.</p><p>Pour ma part j&rsquo;utilise gdb.</p><p><em>Petite astuce d&rsquo;ailleurs si vous utilisez comme moi ghidra pour décompiler votre code et gdb pour debugger, vous pouvez changer la base address dans ghidra afin que vos addresses soit les mêmes entre ghidra et votre debugger. Il suffit d&rsquo;aller dans <code>Window -> Memory map</code> ensuite vous cliqué sur la petite maison et changer l&rsquo;addresse de la base du binaire.</em></p><p><img loading=lazy src=/img/posts/fcsc2023-chaussette-xs/ghidra_base_address.png alt="change base address ghidra"></p><p>on lance donc gdb, on place notre point d&rsquo;arret et on lance notre binaire.</p><pre tabindex=0><code>(gdb) b*0x5555555560aa
Breakpoint 1 at 0x5555555560aa
(gdb) run
Starting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/usr/lib/libthread_db.so.1&#34;.
123
123

Breakpoint 1, 0x00005555555560aa in ?? ()
(gdb) x/i $rip
=&gt; 0x5555555560aa:    
    call   QWORD PTR [rip+0x4100]        # 0x55555555a1b0
</code></pre><p>On peut voir qu&rsquo;on est bel et bien arrété avant l&rsquo;appel à la fonction.</p><p>La commande <code>x/i address</code> permet de décoder les opcodes présent à une addresse.</p><p>On va donc pouvoir afficher notre shellcode grâce à cette commande.</p><p>Attention, ici le code ne se trouve pas à l&rsquo;addresse mais à l&rsquo;addresse pointée par celle ci.</p><pre tabindex=0><code class=language-asm6502 data-lang=asm6502>(gdb) x/gx 0x55555555a1b0
0x55555555a1b0:    0x00007ffff7cc5000
(gdb) x/100i 0x00007ffff7cc5000
   0x7ffff7cc5000:    movabs rax,0x33a11a22d2ea22d1
   [...]
   0x7ffff7cc50ed:    mul    rdi
   0x7ffff7cc50f0:    mov    rdi,rax
   0x7ffff7cc50f3:    movabs rax,0xb12e2565d1efe9f8
   0x7ffff7cc50fd:    xor    rax,rdi
   0x7ffff7cc5100:    ret
</code></pre><p>On a donc un joli code assembleur, maintenant il faut le résoudre. On remarque d&rsquo;ailleurs qu&rsquo;il utilise une seule des entrées utilisateur dans cette fonction. Ce sera de même tout le long du programme, la seconde entrée n&rsquo;est pas utilisée.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x33a11a22d2ea22d1</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>dec</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x94224bcad3296113</span>
</span></span><span class=line><span class=cl><span class=nf>or</span>     <span class=nb>rax</span><span class=p>,</span><span class=mh>0x1</span>
</span></span><span class=line><span class=cl><span class=nf>mul</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>dec</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0xd3b1bf2d4d1d294a</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0xbe35746c05e956a9</span>
</span></span><span class=line><span class=cl><span class=nf>add</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x5819ea9fcbc8779</span>
</span></span><span class=line><span class=cl><span class=nf>xor</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>dec</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x7f7965e1baca6c8f</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>neg</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>ror</span>    <span class=nb>rdi</span><span class=p>,</span><span class=mh>0xd</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x4368955c512ca39b</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>inc</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>neg</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>ror</span>    <span class=nb>rdi</span><span class=p>,</span><span class=mh>0x32</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x96ccb75bd569807d</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>inc</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x9f40cb3b786d6842</span>
</span></span><span class=line><span class=cl><span class=nf>or</span>     <span class=nb>rax</span><span class=p>,</span><span class=mh>0x1</span>
</span></span><span class=line><span class=cl><span class=nf>mul</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>ror</span>    <span class=nb>rdi</span><span class=p>,</span><span class=mh>0x14</span>
</span></span><span class=line><span class=cl><span class=nf>neg</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>neg</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0x1fd3e4098240e723</span>
</span></span><span class=line><span class=cl><span class=nf>add</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0xda3d1c27bae9522c</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>rol</span>    <span class=nb>rdi</span><span class=p>,</span><span class=mh>0x36</span>
</span></span><span class=line><span class=cl><span class=nf>inc</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>inc</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>dec</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>rol</span>    <span class=nb>rdi</span><span class=p>,</span><span class=mh>0x21</span>
</span></span><span class=line><span class=cl><span class=nf>rol</span>    <span class=nb>rdi</span><span class=p>,</span><span class=mh>0x38</span>
</span></span><span class=line><span class=cl><span class=nf>dec</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>neg</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0xc88d84433f7b14e7</span>
</span></span><span class=line><span class=cl><span class=nf>or</span>     <span class=nb>rax</span><span class=p>,</span><span class=mh>0x1</span>
</span></span><span class=line><span class=cl><span class=nf>mul</span>    <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>    <span class=nb>rdi</span><span class=p>,</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rax</span><span class=p>,</span><span class=mh>0xb12e2565d1efe9f8</span>
</span></span><span class=line><span class=cl><span class=nf>xor</span>    <span class=nb>rax</span><span class=p>,</span><span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>ret</span>
</span></span></code></pre></div><p>Il n&rsquo;est pas très compliqué et aurait pu facilement être résolu à la main, néanmoins pour cette solution on utilisera miasm.</p><p>On va dump les octets de ce code dans un fichier, gdb nous permet de le faire grâce à sa commande <code>dump</code></p><pre tabindex=0><code>(gdb) dump binary memory bytcodes_function 0x7ffff7cc5000 0x7ffff7cc5101
</code></pre><p>Je vous invite donc maintenant à installer <a href=https://github.com/cea-sec/miasm>miasm</a>.</p><h2 id=résolution-avec-miasm>Résolution avec Miasm<a hidden class=anchor aria-hidden=true href=#résolution-avec-miasm>#</a></h2><p>Pour cette partie nous allons utiliser le framework <a href=https://github.com/cea-sec/miasm>miasm</a> afin de résoudre ce code.</p><p>Voici mon code permettant de trouver les entrées correctes à notre fonction. J&rsquo;ai commenté le code au maximum, néanmoins je vais quand même vous résumer son fonctionnement afin d&rsquo;être sur que tout le monde comprenne.</p><p>Le programme va dans un premier temps lire les octets que l&rsquo;on a dump précedemmemnt, les interpreter puis lancer une execution symbolique sur notre code. A la suite de cette exécution symbolique il va récuperer l&rsquo;expression symbolique du registre RAX, qui est le registre qui contient notre valeur de retour et la transformer en contrainte compréhensible par z3. A partir de là on va simplifier cette expression et la résoudre.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.analysis.machine</span> <span class=kn>import</span> <span class=n>Machine</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.core.locationdb</span> <span class=kn>import</span> <span class=n>LocationDB</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.analysis.binary</span> <span class=kn>import</span> <span class=n>Container</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.expression.expression</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.ir.symbexec</span> <span class=kn>import</span> <span class=n>SymbolicExecutionEngine</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.ir.translators.z3_ir</span> <span class=kn>import</span> <span class=n>TranslatorZ3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.arch.x86.lifter_model_call</span> <span class=kn>import</span> <span class=n>LifterModelCall_x86_64</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.analysis.simplifier</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.expression.simplifications</span> <span class=kn>import</span> <span class=n>expr_simp</span><span class=p>,</span> <span class=n>ExpressionSimplifier</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>z3</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_shellcode</span><span class=p>(</span><span class=n>shellcode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># on créé une nouvelle location pour notre shellcode</span>
</span></span><span class=line><span class=cl>    <span class=n>loc_db</span> <span class=o>=</span> <span class=n>LocationDB</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on load notre shellcode (nos bytes code)</span>
</span></span><span class=line><span class=cl>    <span class=n>container</span> <span class=o>=</span> <span class=n>Container</span><span class=o>.</span><span class=n>from_string</span><span class=p>(</span><span class=n>shellcode</span><span class=p>,</span> <span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>machine</span> <span class=o>=</span> <span class=n>Machine</span><span class=p>(</span><span class=s1>&#39;x86_64&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ira</span> <span class=o>=</span> <span class=n>machine</span><span class=o>.</span><span class=n>lifter</span><span class=p>(</span><span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dis_engine</span> <span class=o>=</span> <span class=n>machine</span><span class=o>.</span><span class=n>dis_engine</span><span class=p>(</span><span class=n>container</span><span class=o>.</span><span class=n>bin_stream</span><span class=p>,</span> <span class=n>loc_db</span><span class=o>=</span><span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>start_addres</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb</span>
</span></span><span class=line><span class=cl>    <span class=n>asm_cfg</span> <span class=o>=</span> <span class=n>dis_engine</span><span class=o>.</span><span class=n>dis_multiblock</span><span class=p>(</span><span class=n>start_addres</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ira_cfg</span> <span class=o>=</span> <span class=n>ira</span><span class=o>.</span><span class=n>new_ircfg_from_asmcfg</span><span class=p>(</span><span class=n>asm_cfg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    # on peut utiliser ce bout de code pour afficher les instructions assembleurs.
</span></span></span><span class=line><span class=cl><span class=s2>    for block in asm_cfg.blocks:
</span></span></span><span class=line><span class=cl><span class=s2>            print(block)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>init_state</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on definit ici RDI qui va contenir la valeur en entrée.</span>
</span></span><span class=line><span class=cl>    <span class=n>init_state</span><span class=p>[</span><span class=n>ExprId</span><span class=p>(</span><span class=s2>&#34;RDI&#34;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)]</span> <span class=o>=</span> <span class=n>ExprId</span><span class=p>(</span><span class=s1>&#39;input&#39;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># rax qui est censé être égal à 0 à la fin du script.</span>
</span></span><span class=line><span class=cl>    <span class=n>init_state</span><span class=p>[</span><span class=n>ExprId</span><span class=p>(</span><span class=s2>&#34;RAX&#34;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)]</span> <span class=o>=</span> <span class=n>ExprId</span><span class=p>(</span><span class=s1>&#39;result&#39;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on lance l&#39;execution symbolique.</span>
</span></span><span class=line><span class=cl>    <span class=n>sb</span> <span class=o>=</span> <span class=n>SymbolicExecutionEngine</span><span class=p>(</span><span class=n>LifterModelCall_x86_64</span><span class=p>(</span><span class=n>loc_db</span><span class=p>)</span> <span class=p>,</span> <span class=n>state</span><span class=o>=</span><span class=n>init_state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sb</span><span class=o>.</span><span class=n>run_at</span><span class=p>(</span><span class=n>ira_cfg</span><span class=p>,</span> <span class=n>addr</span><span class=o>=</span><span class=n>start_addres</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on va transformer l&#39;expression symbolique en contraintes pour z3</span>
</span></span><span class=line><span class=cl>    <span class=n>trans</span> <span class=o>=</span> <span class=n>TranslatorZ3</span><span class=p>(</span><span class=n>loc_db</span><span class=o>=</span><span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># solveur basique z3</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>Solver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall)</span>
</span></span><span class=line><span class=cl>    <span class=n>expr_simp_cond</span> <span class=o>=</span> <span class=n>ExpressionSimplifier</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>expr_simp_cond</span><span class=o>.</span><span class=n>enable_passes</span><span class=p>(</span><span class=n>ExpressionSimplifier</span><span class=o>.</span><span class=n>PASS_COND</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># récuperer l&#39;expression symbolique (+ la simplifiée.)</span>
</span></span><span class=line><span class=cl>    <span class=n>expr_rax</span> <span class=o>=</span> <span class=n>sb</span><span class=o>.</span><span class=n>eval_expr</span><span class=p>(</span><span class=n>expr_simp</span><span class=p>(</span><span class=n>expr_simp_cond</span><span class=p>(</span><span class=n>ExprId</span><span class=p>(</span><span class=s1>&#39;RAX&#39;</span><span class=p>,</span> <span class=mi>64</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on solve avec z3</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>trans</span><span class=o>.</span><span class=n>from_expr</span><span class=p>(</span><span class=n>expr_rax</span><span class=p>)</span> <span class=o>==</span> <span class=n>trans</span><span class=o>.</span><span class=n>from_expr</span><span class=p>(</span><span class=n>ExprInt</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>64</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>s</span><span class=o>.</span><span class=n>check</span><span class=p>()</span> <span class=o>==</span> <span class=n>sat</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># print(&#34;found&#34;)</span>
</span></span><span class=line><span class=cl>        <span class=n>model</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>model</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># on retourne le resultat </span>
</span></span><span class=line><span class=cl>        <span class=c1># (j&#39;ai honte de mon parsing mais je n&#39;arrivais pas récuperer cette valeur correctement ...)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s2>&#34;[0-9]+&#34;</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>model</span><span class=p>))[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[-] fail&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on ouvre le fichier contenant les octets de notre code assembleur</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;bytcodes_function&#34;</span><span class=p>,</span> <span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>=</span> <span class=n>file</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl><span class=n>solve_shellcode</span><span class=p>(</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[+] solution found : </span><span class=si>{</span><span class=n>result</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>On va donc executer notre programme et l&rsquo;on récupère bel et bien une valeur.</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs
╰─➤  python3 solve_first_shellcode.py
[+] solution found : 14171339039947875846
</code></pre><p>On peut entrer ces valeurs dans notre binaire et effectivemment notre script passe la première condition avec succès !</p><h2 id=vous-croyez-que-cétait-fini--cest-que-le-début>Vous croyez que c&rsquo;était fini ? c&rsquo;est que le début.<a hidden class=anchor aria-hidden=true href=#vous-croyez-que-cétait-fini--cest-que-le-début>#</a></h2><p>On passe donc à la deuxième fonction. Comme précédemment, on place notre breakpoint avant l&rsquo;appel à la fonction et on l&rsquo;affiche.</p><pre tabindex=0><code>(gdb) b*0x000055555555612c
Breakpoint 1 at 0x55555555612c
(gdb) run
Starting program: /home/user/shared/fcsc2023/reverse/chaussette-xs/chaussette-xs
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/usr/lib/libthread_db.so.1&#34;.
14171339039947875846
123

Breakpoint 1, 0x000055555555612c in ?? ()
(gdb) x/i $rip
=&gt; 0x55555555612c:    call   0x555555557000
(gdb) x/110i 0x555555557000
   0x555555557000:    movabs rax,0x676e656c6c616863
   0x55555555700a:    push   r15
   0x55555555700c:    push   r14
   0x55555555700e:    push   r13
   0x555555557010:    push   r12
   0x555555557012:    push   rbp
   0x555555557013:    push   rbx
   0x555555557014:    mov    rbx,rdi
   0x555555557017:    lea    rdi,[rip+0xfea]        # 0x555555558008
   0x55555555701e:    sub    rsp,0x68
   0x555555557022:    movdqa xmm0,XMMWORD PTR [rip+0xfe6]        # 0x555555558010
   0x55555555702a:    mov    QWORD PTR [rsp+0x8],rsi
   0x55555555702f:    movups XMMWORD PTR [rsp+0x30],xmm0
   0x555555557034:    movdqa xmm0,XMMWORD PTR [rip+0xfe4]        # 0x555555558020
   0x55555555703c:    mov    QWORD PTR [rsp],rdx
   0x555555557040:    mov    QWORD PTR [rsp+0x50],rax
   0x555555557045:    mov    DWORD PTR [rsp+0x58],0x72662e65
   0x55555555704d:    mov    BYTE PTR [rsp+0x5c],0x0
   0x555555557052:    movups XMMWORD PTR [rsp+0x40],xmm0
   0x555555557057:    call   0x5555555550a0 &lt;getprotobyname@plt&gt;
   0x55555555705c:    test   rax,rax
   0x55555555705f:    je     0x5555555571bf
   0x555555557065:    mov    edx,DWORD PTR [rax+0x10]
   0x555555557068:    mov    esi,0x1
   0x55555555706d:    mov    edi,0x2
   0x555555557072:    call   0x5555555550f0 &lt;socket@plt&gt;
   0x555555557077:    mov    DWORD PTR [rip+0x313b],eax        # 0x55555555a1b8
   0x55555555707d:    cmp    eax,0xffffffff
   0x555555557080:    je     0x5555555571bf
   0x555555557086:    lea    rdi,[rsp+0x30]
   0x55555555708b:    call   0x555555555090 &lt;gethostbyname@plt&gt;
   0x555555557090:    test   rax,rax
   0x555555557093:    je     0x5555555571bf
   0x555555557099:    mov    rax,QWORD PTR [rax+0x18]
   0x55555555709d:    mov    rax,QWORD PTR [rax]
   0x5555555570a0:    mov    edi,DWORD PTR [rax]
   0x5555555570a2:    call   0x555555555050 &lt;inet_ntoa@plt&gt;
   0x5555555570a7:    mov    rdi,rax
   0x5555555570aa:    call   0x555555555080 &lt;inet_addr@plt&gt;
   0x5555555570af:    cmp    eax,0xffffffff
   0x5555555570b2:    je     0x5555555571bf
   0x5555555570b8:    mov    edi,DWORD PTR [rip+0x30fa]        # 0x55555555a1b8
   0x5555555570be:    lea    rsi,[rsp+0x20]
   0x5555555570c3:    mov    DWORD PTR [rsp+0x24],eax
   0x5555555570c7:    mov    edx,0x10
   0x5555555570cc:    mov    DWORD PTR [rsp+0x20],0xcd080002
   0x5555555570d4:    call   0x5555555550e0 &lt;connect@plt&gt;
   0x5555555570d9:    cmp    eax,0xffffffff
   0x5555555570dc:    je     0x5555555571bf
   0x5555555570e2:    lea    r12,[rsp+0x18]
   0x5555555570e7:    lea    r13,[rsp+0x10]
   0x5555555570ec:    lea    r14,[rsp+0x8]
   0x5555555570f1:    nop    DWORD PTR [rax+0x0]
   0x5555555570f8:    mov    rax,QWORD PTR [rsp+0x8]
   0x5555555570fd:    mov    edi,DWORD PTR [rip+0x30b5]        # 0x55555555a1b8
   0x555555557103:    mov    edx,0x8
   0x555555557108:    mov    rsi,r12
   0x55555555710b:    mov    QWORD PTR [rsp+0x18],rax
   0x555555557110:    call   0x555555555040 &lt;write@plt&gt;
   0x555555557115:    mov    rax,QWORD PTR [rsp]
   0x555555557119:    mov    edx,0x8
   0x55555555711e:    mov    rsi,r12
   0x555555557121:    mov    edi,DWORD PTR [rip+0x3091]        # 0x55555555a1b8
   0x555555557127:    mov    QWORD PTR [rsp+0x18],rax
   0x55555555712c:    call   0x555555555040 &lt;write@plt&gt;
   0x555555557131:    mov    edi,DWORD PTR [rip+0x3081]        # 0x55555555a1b8
   0x555555557137:    mov    edx,0x8
   0x55555555713c:    mov    rsi,r13
   0x55555555713f:    call   0x555555555070 &lt;read@plt&gt;
   0x555555557144:    mov    rbp,QWORD PTR [rsp+0x10]
   0x555555557149:    cmp    rbp,0xffffffffffffffff
   0x55555555714d:    je     0x5555555571ce
   0x55555555714f:    mov    r15,rbx
   0x555555557152:    test   rbp,rbp
   0x555555557155:    jne    0x55555555716e
   0x555555557157:    jmp    0x555555557189
   0x555555557159:    nop    DWORD PTR [rax+0x0]
   0x555555557160:    add    r15,rax
   0x555555557163:    mov    rax,r15
   0x555555557166:    sub    rax,rbx
   0x555555557169:    cmp    rax,rbp
   0x55555555716c:    jae    0x555555557189
   0x55555555716e:    mov    edi,DWORD PTR [rip+0x3044]        # 0x55555555a1b8
   0x555555557174:    xor    ecx,ecx
   0x555555557176:    mov    edx,0x1000
   0x55555555717b:    mov    rsi,r15
   0x55555555717e:    call   0x555555555030 &lt;recv@plt&gt;
   0x555555557183:    cmp    rax,0xffffffffffffffff
   0x555555557187:    jne    0x555555557160
   0x555555557189:    mov    rsi,r14
   0x55555555718c:    lea    rdi,[rip+0xe71]        # 0x555555558004
   0x555555557193:    xor    eax,eax
   0x555555557195:    call   0x5555555550d0 &lt;__isoc99_scanf@plt&gt;
   0x55555555719a:    mov    rsi,rsp
   0x55555555719d:    lea    rdi,[rip+0xe60]        # 0x555555558004
   0x5555555571a4:    xor    eax,eax
   0x5555555571a6:    call   0x5555555550d0 &lt;__isoc99_scanf@plt&gt;
   0x5555555571ab:    mov    rsi,QWORD PTR [rsp]
   0x5555555571af:    mov    rdi,QWORD PTR [rsp+0x8]
   0x5555555571b4:    call   rbx
   0x5555555571b6:    test   rax,rax
   0x5555555571b9:    je     0x5555555570f8
   0x5555555571bf:    add    rsp,0x68
   0x5555555571c3:    pop    rbx
   0x5555555571c4:    pop    rbp
   0x5555555571c5:    pop    r12
   0x5555555571c7:    pop    r13
   0x5555555571c9:    pop    r14
   0x5555555571cb:    pop    r15
   0x5555555571cd:    ret
</code></pre><p>cette fonction peut paraître effrayante aux premiers abords, mais elle est en réalité plutôt simple. On peut d&rsquo;abord voir les appels aux fonctions de la libc tels que <code>socket</code>, <code>connect</code>, <code>recv</code> etc.</p><p>Elle va établir une connexion tcp avec un serveur distant, lui envoyer nos 2 valeurs entrées précédemment et récuperer des données que le serveur lui envoie. Les octets que la fonction récupère vont être placés à l&rsquo;addresse de notre précédente fonction. Ensuite le programme va demander à nouveau 2 entrées à l&rsquo;utilisateur et appeler notre nouvelle fonction avec les valeurs données par l&rsquo;utlisateur et recommencer.</p><p>On pourrait représenter le fonctionnement de cette fonction par le pseudo code suivant :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>strange_function</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>shellcode</span><span class=p>,</span> <span class=n>ulong</span> <span class=n>value1</span><span class=p>,</span> <span class=n>ulong</span> <span class=n>value2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>conn</span> <span class=o>=</span> <span class=nf>connexion</span><span class=p>();</span> <span class=c1>// établit une connexion tcp avec le serveur
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>conn</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span> <span class=c1>// lit 8 octets qui seront la taille du shellcode 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=n>shellcode</span> <span class=o>=</span> <span class=nf>recv</span><span class=p>(</span><span class=n>conn</span><span class=p>)</span> <span class=c1>// reçois le shellcode et l&#39;écris à
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=c1>// l&#39;addresse de l&#39;ancien shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// récupère les 2 entrées utilisateur
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%lu&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>value1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%lu&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>value2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// verifie que les entrées résolve le shellcode.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// pareil que la première partie du challenge.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>((</span><span class=o>*</span><span class=p>(</span><span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=p>)())</span><span class=n>shellcode</span><span class=p>)(</span><span class=n>value1</span><span class=p>,</span> <span class=n>value2</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// signifie que notre entrée est fausse
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// le programme se stoppe. (et donc par conséquent pas de flag)
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>On va donc récuperer l&rsquo;IP et le port afin de créer nous même la connexion tcp avec le serveur distant, lui envoyer nos valeurs et récuperer les shellcodes.</p><p>Pour récuperer l&rsquo;ip et le port on pourrait placer un point d&rsquo;arret au niveau de l&rsquo;appel à la fonction <code>getprotobyname</code> et au niveau de la fonction <code>socket</code> . Mais étant flemmard (ou malin à vous de me dire) j&rsquo;ai préféré regarder les connexions ouvertes sur ma machine par le processus en question.</p><p><img loading=lazy src=/img/posts/fcsc2023-chaussette-xs/getting_ip.png alt></p><p>Pour ce faire j&rsquo;ai utilisé l&rsquo;outil <code>ss</code>. J&rsquo;execute donc mon binaire, je lui donne les valeurs trouvé précedemment afin qu&rsquo;il établisse la connexion et ensuite avec la commande <code>ss -nap | grep chaussette-xs</code> je récupère l&rsquo;ip et le port.</p><p>Le serveur distant se trouve donc en <code>51.254.115.216:2253</code>.</p><h2 id=résoudre-les-shellcode-avec-miasm>Résoudre les shellcode avec miasm<a hidden class=anchor aria-hidden=true href=#résoudre-les-shellcode-avec-miasm>#</a></h2><p>Après quelques tests on s&rsquo;aperçoit qu&rsquo;a chaque connexion le code renvoyé par le serveur change. On va donc implémenter un algorithme qui resout les fonctions donnée par le serveur distant.</p><p>Heureusement nous avons déjà fait une grande partie du travail, en effet nous avons implémenté durant la première partie une fonction qui utilise miasm afin de résoudre les shellcodes. Nous avons donc a configurer la connexion avec le serveur et ensuite résoudre les instructions que le serveur nous enverra.</p><p>Voici mon code :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.analysis.machine</span> <span class=kn>import</span> <span class=n>Machine</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.core.locationdb</span> <span class=kn>import</span> <span class=n>LocationDB</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.analysis.binary</span> <span class=kn>import</span> <span class=n>Container</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.expression.expression</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.ir.symbexec</span> <span class=kn>import</span> <span class=n>SymbolicExecutionEngine</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.ir.translators.z3_ir</span> <span class=kn>import</span> <span class=n>TranslatorZ3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.arch.x86.lifter_model_call</span> <span class=kn>import</span> <span class=n>LifterModelCall_x86_64</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.analysis.simplifier</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>miasm.expression.simplifications</span> <span class=kn>import</span> <span class=n>expr_simp</span><span class=p>,</span> <span class=n>ExpressionSimplifier</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>z3</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_shellcode</span><span class=p>(</span><span class=n>shellcode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on créé une nouvelle location pour notre shellcode</span>
</span></span><span class=line><span class=cl>    <span class=n>loc_db</span> <span class=o>=</span> <span class=n>LocationDB</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on load notre shellcode</span>
</span></span><span class=line><span class=cl>    <span class=n>container</span> <span class=o>=</span> <span class=n>Container</span><span class=o>.</span><span class=n>from_string</span><span class=p>(</span><span class=n>shellcode</span><span class=p>,</span> <span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>machine</span> <span class=o>=</span> <span class=n>Machine</span><span class=p>(</span><span class=s1>&#39;x86_64&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ira</span> <span class=o>=</span> <span class=n>machine</span><span class=o>.</span><span class=n>lifter</span><span class=p>(</span><span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dis_engine</span> <span class=o>=</span> <span class=n>machine</span><span class=o>.</span><span class=n>dis_engine</span><span class=p>(</span><span class=n>container</span><span class=o>.</span><span class=n>bin_stream</span><span class=p>,</span> <span class=n>loc_db</span><span class=o>=</span><span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>start_addres</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># https://github.com/cea-sec/miasm/blob/master/doc/ir/lift.ipynb</span>
</span></span><span class=line><span class=cl>    <span class=n>asm_cfg</span> <span class=o>=</span> <span class=n>dis_engine</span><span class=o>.</span><span class=n>dis_multiblock</span><span class=p>(</span><span class=n>start_addres</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ira_cfg</span> <span class=o>=</span> <span class=n>ira</span><span class=o>.</span><span class=n>new_ircfg_from_asmcfg</span><span class=p>(</span><span class=n>asm_cfg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    # on peut utiliser ce bout de code pour afficher les instructions assembleurs.
</span></span></span><span class=line><span class=cl><span class=s2>    for block in asm_cfg.blocks:
</span></span></span><span class=line><span class=cl><span class=s2>            print(block)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>init_state</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on definit ici RDI qui va contenir la valeur en entrée.</span>
</span></span><span class=line><span class=cl>    <span class=n>init_state</span><span class=p>[</span><span class=n>ExprId</span><span class=p>(</span><span class=s2>&#34;RDI&#34;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)]</span> <span class=o>=</span> <span class=n>ExprId</span><span class=p>(</span><span class=s1>&#39;input&#39;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># rax qui est censé être égal à 0 à la fin du script.</span>
</span></span><span class=line><span class=cl>    <span class=n>init_state</span><span class=p>[</span><span class=n>ExprId</span><span class=p>(</span><span class=s2>&#34;RAX&#34;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)]</span> <span class=o>=</span> <span class=n>ExprId</span><span class=p>(</span><span class=s1>&#39;result&#39;</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on lance l&#39;execution symbolique.</span>
</span></span><span class=line><span class=cl>    <span class=n>sb</span> <span class=o>=</span> <span class=n>SymbolicExecutionEngine</span><span class=p>(</span><span class=n>LifterModelCall_x86_64</span><span class=p>(</span><span class=n>loc_db</span><span class=p>)</span> <span class=p>,</span> <span class=n>state</span><span class=o>=</span><span class=n>init_state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sb</span><span class=o>.</span><span class=n>run_at</span><span class=p>(</span><span class=n>ira_cfg</span><span class=p>,</span> <span class=n>addr</span><span class=o>=</span><span class=n>start_addres</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on va transformer l&#39;expression symbolique en contraintes pour z3</span>
</span></span><span class=line><span class=cl>    <span class=n>trans</span> <span class=o>=</span> <span class=n>TranslatorZ3</span><span class=p>(</span><span class=n>loc_db</span><span class=o>=</span><span class=n>loc_db</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># solveur basique z3</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>Solver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on utilise miasm pour simplifier les expressions symboliques (on aurait pu faire sans pour ce chall)</span>
</span></span><span class=line><span class=cl>    <span class=n>expr_simp_cond</span> <span class=o>=</span> <span class=n>ExpressionSimplifier</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>expr_simp_cond</span><span class=o>.</span><span class=n>enable_passes</span><span class=p>(</span><span class=n>ExpressionSimplifier</span><span class=o>.</span><span class=n>PASS_COND</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># récuperer l&#39;expression symbolique (+ la simplifiée.)</span>
</span></span><span class=line><span class=cl>    <span class=n>expr_rax</span> <span class=o>=</span> <span class=n>sb</span><span class=o>.</span><span class=n>eval_expr</span><span class=p>(</span><span class=n>expr_simp</span><span class=p>(</span><span class=n>expr_simp_cond</span><span class=p>(</span><span class=n>ExprId</span><span class=p>(</span><span class=s1>&#39;RAX&#39;</span><span class=p>,</span> <span class=mi>64</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># on solve avec z3</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>trans</span><span class=o>.</span><span class=n>from_expr</span><span class=p>(</span><span class=n>expr_rax</span><span class=p>)</span> <span class=o>==</span> <span class=n>trans</span><span class=o>.</span><span class=n>from_expr</span><span class=p>(</span><span class=n>ExprInt</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>64</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>s</span><span class=o>.</span><span class=n>check</span><span class=p>()</span> <span class=o>==</span> <span class=n>sat</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># print(&#34;found&#34;)</span>
</span></span><span class=line><span class=cl>        <span class=n>model</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>model</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s2>&#34;[0-9]+&#34;</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>model</span><span class=p>))[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[-] fail&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>shellcode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># j&#39;ai placé mon breakpoint au final, je trouvai un hostname plus joli</span>
</span></span><span class=line><span class=cl><span class=n>host</span> <span class=o>=</span> <span class=s2>&#34;challenges.france-cybersecurity-challenge.fr&#34;</span>
</span></span><span class=line><span class=cl><span class=n>port</span> <span class=o>=</span> <span class=mi>2253</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>data_1</span> <span class=o>=</span> <span class=mi>14171339039947875846</span>
</span></span><span class=line><span class=cl><span class=n>data_2</span> <span class=o>=</span> <span class=mh>0xdeadbeef</span> <span class=c1># useless</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on etablit la connection tcp.</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>remote</span><span class=p>(</span><span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>compteur</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># on envoie notre solution ainsi que celle inutile pour ce challenge.</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>data_1</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=s2>&#34;little&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>data_2</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=s2>&#34;little&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>size</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>8</span><span class=p>),</span> <span class=s2>&#34;little&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>shellcode</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[~] shellcode of </span><span class=si>{</span><span class=n>size</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>shellcode</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>flag</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;FCSC{.*}&#34;</span><span class=p>,</span> <span class=n>shellcode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>flag</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;flag is : &#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>flag</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>decode</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[~] solving shellcode </span><span class=si>{</span><span class=n>compteur</span><span class=si>}</span><span class=s2>...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>solve_shellcode</span><span class=p>(</span><span class=n>shellcode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>data_1</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[+] solution found : </span><span class=si>{</span><span class=n>data_1</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>compteur</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on ferme la connection</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span></code></pre></div><p>Ce code va établir une connexion avec le serveur et tant qu&rsquo;il ne trouve pas le flag dans les fonctions qu&rsquo;il reçoit il va les résoudre et renvoyer la solution. Je ne pense pas qu&rsquo;il est nécessaire que j&rsquo;explique mon script en détail, il est très similaire au précédent.</p><p>On execute donc le script et au bout de quelques secondes le flag apparait.</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/fcsc2023/reverse/chaussette-xs
╰─➤  python3 solving_using_miasm.py
[+] Opening connection to challenges.france-cybersecurity-challenge.fr on port 2253: Done
[~] shellcode of 414 bytes
[~] solving shellcode 0...
[+] solution found : 16584048833465228239
[~] shellcode of 444 bytes
[~] solving shellcode 1...
[+] solution found : 5460636808995531285
[~] shellcode of 842 bytes
[~] solving shellcode 2...
[+] solution found : 3445377768356975671
[~] shellcode of 810 bytes
[~] solving shellcode 3...
[+] solution found : 6412023629681526002
[~] shellcode of 929 bytes
[~] solving shellcode 4...
[+] solution found : 1172201077721270149
[~] shellcode of 18446744073709551615 bytes
flag is : FCSC{2a86d6edc5d08afc03d2c9ef3e2ff83cd63e520ffbd716d96479df8147e6da5e}
[*] Closed connection to challenges.france-cybersecurity-challenge.fr port 2253
</code></pre><h2 id=pour-conclure>Pour conclure<a hidden class=anchor aria-hidden=true href=#pour-conclure>#</a></h2><p>J&rsquo;ai trouvé ce challenge très intéressant, j&rsquo;ai malheureusement été bloqué par son grand frère durant plusieurs jours sans le réussir. Il m&rsquo;a néanmoins appris beaucoup de choses sur l&rsquo;automatisation de l&rsquo;analyse binaire. En effet j&rsquo;ai toujours cru que les outils tels que angr, miasm et tout les solveurs de ce genre était pour les personnes qui ne voulaient pas réfléchir. C&rsquo;était donc la première fois que j&rsquo;utilisais miasm (et angr) et j&rsquo;ai trouvé ça très intéressant. Cela m&rsquo;a permis d&rsquo;aborder un nouvel aspect du reverse engineering qui m&rsquo;a l&rsquo;air très complexe mais également très intéressant.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://trikkss.github.io/tags/reverse-engineering/>Reverse engineering</a></li><li><a href=https://trikkss.github.io/tags/linux/>Linux</a></li><li><a href=https://trikkss.github.io/tags/miasm/>Miasm</a></li></ul><nav class=paginav><a class=prev href=https://trikkss.github.io/posts/fcsc2024_tv-hacks1/><span class=title>« Prev</span><br><span>FCSC 2024 - TV Hacks 1/2</span></a>
<a class=next href=https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/><span class=title>Next »</span><br><span>FCSC 2023 - Sensor Watch</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://trikkss.github.io/>TRIKKSS Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>