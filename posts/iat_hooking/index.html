<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Malware - IAT Hooking | TRIKKSS Blog</title><meta name=keywords content="Reverse engineering,malware,C,Windows,PE,DLL,IAT"><meta name=description content="IAT hooking is a technique often used by malware developers, game hackers or reverse engineer to replace a function from the Import Table by another one."><meta name=author content="TRIKKSS"><link rel=canonical href=https://trikkss.github.io/posts/iat_hooking/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=16x16 href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=32x32 href=https://trikkss.github.io/img/pfp.png><link rel=apple-touch-icon href=https://trikkss.github.io/img/pfp.png><link rel=mask-icon href=https://trikkss.github.io/img/pfp.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Malware - IAT Hooking"><meta property="og:description" content="IAT hooking is a technique often used by malware developers, game hackers or reverse engineer to replace a function from the Import Table by another one."><meta property="og:type" content="article"><meta property="og:url" content="https://trikkss.github.io/posts/iat_hooking/"><meta property="og:image" content="https://trikkss.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-08T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-08T00:00:00+00:00"><meta property="og:site_name" content="TRIKKSS Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trikkss.github.io/img/pfp.png"><meta name=twitter:title content="Malware - IAT Hooking"><meta name=twitter:description content="IAT hooking is a technique often used by malware developers, game hackers or reverse engineer to replace a function from the Import Table by another one."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://trikkss.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Malware - IAT Hooking","item":"https://trikkss.github.io/posts/iat_hooking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Malware - IAT Hooking","name":"Malware - IAT Hooking","description":"IAT hooking is a technique often used by malware developers, game hackers or reverse engineer to replace a function from the Import Table by another one.","keywords":["Reverse engineering","malware","C","Windows","PE","DLL","IAT"],"articleBody":"Import Table When you run a Portable Executable (PE), before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the Import Address Table (IAT). When a program calls a function from a DLL, it calls the address located in the IAT wich point to the function in memory.\ndiagram of a normal api call :\ndiagram of an hooked api call :\nWe want to change the address of this API call in the IAT to execute an non intended function. This technique can be useful for reverse engineer to change the result of a function or dump his parameter (for example if you have a runPE you can hook the WriteProcessMemory function and easily dump the PE.) and it can be useful for malware devellopers to hide some malicious code.\nImport table structure You can learn more about the import table here.\nThe import table is a null terminated array a null terminated array of IMAGE_IMPORT_DESCRIPTOR structure.\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; Each dll in the Import Table as an IMAGE_IMPORT_DESCRIPTOR structure which contains information about it like its name, its functions, etc.\nHere we will focus only on interesting things for us.\nDWORD Name : RVA of an ASCII string that contains the name of the module (dll name)\nDWORD OriginalFirstThunk : RVA of the Import Lookup Table (ILT)\nDWORD FirstThunk : RVA of the Import Address Table (IAT)\nRelative Virtual Address (RVA) means Relative to the base address.\nExample : dll_name = PE_Base_Address + IMAGE_IMPORT_DESCRIPTOR.Name\nOriginalFirstThunk and FirstThunk The IAT and ILT are parallel’s NULL terminated arrays.\nTheir structure is defined as it :\ntypedef struct _IMAGE_THUNK_DATA { union { uint32_t* Function; // address of imported function uint32_t Ordinal; // ordinal value of function PIMAGE_IMPORT_BY_NAME AddressOfData; // RVA of imported name DWORD ForwarderStringl // RVA to forwarder string } u1; } IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA; Import Lookup Table The ILT contain names and ordinals for each API call.\nif the first bit of AddressOfData is 1, this DWORD is the ordinal of the function to import.\nElse, the AddressOfData point to a IMAGE_IMPORT_BY_NAME structure which contains the API call name and looks like this :\ntypedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; BYTE Name[1]; /*The BYTE designated at Name of course only marks the beginning of the character array of the imported function name as the name can be larger than one character.*/ } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; Import Address Table The IAT contain virtual address of these API calls.\nParsing the import table Now, we have to parse our PE to find it’s Import Table. To do that we will use the winnt.h library in C.\nThe following diagram illustrate the simplified structure of a PE.\nWe first have to retrieve the base address of our PE. To do it we can call the GetModuleHandle() API call.\nGetModuleHandle(NULL)\nNow, like my previous article about API Windows Hashing, we will parse the PE.\nHANDLE PE_base = GetModuleHandle(NULL); IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; // convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u003ee_lfanew ); // NT HEADERS are located at the raw offset defined in the e_lfanew header // RVA of the import table can be found in the optional headers // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only // https://0xrick.github.io/win-internals/pe6/#import-directory-table IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); Here we retrieve the address of the first IMAGE_IMPORT_DESCRIPTOR array.\nwe can easily iterate trought the null terminated array using a while loop :\nwhile (import_table-\u003eName != 0) { // print each dll loaded in the import table printf(\"%s\\n\", (char*)((LPBYTE)PE_base + import_table-\u003eName)); } Now, we want for each DLLs to retrieve their functions name and address. We first have to find our ILT and IAT and iterate throught it.\nIMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u003eOriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u003eFirstThunk); // it will print all function name of the module. while(lookup_table-\u003eu1.AddressOfData != 0) { // check if its an import by ordinal if((lookup_table-\u003eu1.AddressOfData \u0026 IMAGE_ORDINAL_FLAG) == 0) { // retrieve the struct wich contains the function name IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u003eu1.AddressOfData); printf(\"%s\\n\", (char*)lookup_addr-\u003eName); } lookup_table++; address_table++; } Now we can print a function’s address from its name, like MessageBoxA as below:\n// we want to print the address of the MessageBoxA API call. if(strcmp(lookup_addr-\u003eName, \"MessageBoxA\") == 0) { printf(\"%p\\n\", address_table-\u003eu1.Function); // print the function address } Okay, now we have the address of the API call we want to hook.\nThe complete function to print it looks like this :\nvoid print_address_by_parsing_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u003ee_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u003eName != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u003eOriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u003eFirstThunk); // iterate throught IAT and ILT while(lookup_table-\u003eu1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u003eu1.AddressOfData \u0026 IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u003eu1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u003eName, function_to_hook) == 0) { printf(\"%p\\n\", address_table-\u003eu1.Function); } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } So, this function will just print the API call address. Now we have to change it.\nHooking the API call Lets make a fake MessageBox :\nINT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\"I hooked your function :)\\n\"); printf(\"you wanted to display %s\\n\", lpText); return 0; } Instead of printing the MessageBoxA address in the IAT, we will overwrite it by fake_messagebox address and save the real MessageBox address into an other variable.\naddress_table-\u003eu1.Function = (ULONGLONG)fake_messagebox;\nOur final code look like this.\n#include #include typedef int(WINAPI* MESSAGE_BOX_TYPE)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType); MESSAGE_BOX_TYPE MessageBoxSaved; INT WINAPI fake_messagebox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ printf(\"I hooked your function :)\\n\"); printf(\"you wanted to display %s\\n\", lpText); return MessageBoxSaved(hWnd, lpText, lpCaption, uType); } void hook_IAT(HMODULE PE_base, char* function_to_hook) { IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*) PE_base; IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*) ((LPBYTE)PE_base + p_DOS_HDR-\u003ee_lfanew ); IMAGE_IMPORT_DESCRIPTOR* import_table = (IMAGE_IMPORT_DESCRIPTOR*)((LPBYTE)PE_base + p_NT_HDR-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // iterate throught the null terminated modules array while (import_table-\u003eName != 0) { // retrieve ILT and IAT IMAGE_THUNK_DATA* lookup_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u003eOriginalFirstThunk); IMAGE_THUNK_DATA* address_table = (IMAGE_THUNK_DATA*)((LPBYTE)PE_base + import_table-\u003eFirstThunk); // iterate throught IAT and ILT while(lookup_table-\u003eu1.AddressOfData != 0) { // check if the function is called by ordinal if((lookup_table-\u003eu1.AddressOfData \u0026 IMAGE_ORDINAL_FLAG) == 0) { // if it is not retrieve its IMAGE_IMPORT_BY_NAME structure IMAGE_IMPORT_BY_NAME* lookup_addr = (IMAGE_IMPORT_BY_NAME*)((LPBYTE)PE_base + lookup_table-\u003eu1.AddressOfData); // compare the function name with the function name to hook if(strcmp(lookup_addr-\u003eName, function_to_hook) == 0) { // change its address address_table-\u003eu1.Function = (ULONGLONG)fake_messagebox; } } // next element of the IAT and the ILT lookup_table++; address_table++; } // next module import_table++; } } int main(void) { // save MessageBox function MessageBoxSaved = (MESSAGE_BOX_TYPE)GetProcAddress(LoadLibrary(\"user32.dll\"), \"MessageBoxA\"); // hook the function hook_IAT(GetModuleHandle(NULL), \"MessageBoxA\"); MessageBoxA(NULL, \"hello world\", \"simple message box\", MB_OK); } /* output : I hooked your function :) you wanted to display hello world */ To go further you can hook any function present in the IAT of an other process using DLL injection to execute some code which will patch the import table. It’s a bit more difficult but it can be interesting for game hacking or reverse engineering.\nIssue This technic is useful, but it can be bypassed if the program retrieve its API call address from the Export Table using the GetProcAddress() function.\nConclusion This example was basic, but I think with it you can make lot of funny things.\nI hope you enjoyed to read it, have a nice day.\n","wordCount":"1308","inLanguage":"en","datePublished":"2023-01-08T00:00:00Z","dateModified":"2023-01-08T00:00:00Z","author":{"@type":"Person","name":"TRIKKSS"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://trikkss.github.io/posts/iat_hooking/"},"publisher":{"@type":"Organization","name":"TRIKKSS Blog","logo":{"@type":"ImageObject","url":"https://trikkss.github.io/img/pfp.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://trikkss.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://trikkss.github.io/img/pfp.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://trikkss.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://trikkss.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://trikkss.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://trikkss.github.io/posts/>Posts</a></div><h1 class=post-title>Malware - IAT Hooking</h1><div class=post-meta><span title='2023-01-08 00:00:00 +0000 UTC'>January 8, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1308 words&nbsp;·&nbsp;TRIKKSS</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#import-table>Import Table</a><ul><li><a href=#import-table-structure>Import table structure</a></li><li><a href=#originalfirstthunk-and-firstthunk>OriginalFirstThunk and FirstThunk</a></li></ul></li><li><a href=#parsing-the-import-table>Parsing the import table</a></li><li><a href=#hooking-the-api-call>Hooking the API call</a></li><li><a href=#to-go-further>To go further</a></li><li><a href=#issue>Issue</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><h2 id=import-table>Import Table<a hidden class=anchor aria-hidden=true href=#import-table>#</a></h2><p>When you run a Portable Executable (PE), before the execution of our program, libraries will be loaded in memory and their function addresses will be referenced in the <em>Import Address Table (IAT)</em>. When a program calls a function from a DLL, it calls the address located in the IAT wich point to the function in memory.</p><p>diagram of a normal api call :</p><p><img loading=lazy src=/img/posts/IAT_Hooking/IAT_schema.png alt="diagram IAT hooked and not hooked"></p><p>diagram of an hooked api call :</p><p><img loading=lazy src=/img/posts/IAT_Hooking/IAT_hooked_schema.png alt="HOOKED API CALL"></p><p>We want to change the address of this API call in the IAT to <em>execute an non intended function</em>. This technique can be useful for reverse engineer to <em>change the result of a function or dump his parameter</em> (for example if you have a runPE you can hook the WriteProcessMemory function and easily dump the PE.) and it can be useful for malware devellopers to <em>hide some malicious code</em>.</p><h3 id=import-table-structure>Import table structure<a hidden class=anchor aria-hidden=true href=#import-table-structure>#</a></h3><p>You can learn more about the import table <a href=https://0xrick.github.io/win-internals/pe6/>here</a>.</p><p>The import table is <em>a null terminated array</em> a null terminated array of IMAGE_IMPORT_DESCRIPTOR structure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_IMAGE_IMPORT_DESCRIPTOR</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DWORD</span>   <span class=n>Characteristics</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>DWORD</span>   <span class=n>OriginalFirstThunk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>DUMMYUNIONNAME</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>TimeDateStamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>ForwarderChain</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>Name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>FirstThunk</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>IMAGE_IMPORT_DESCRIPTOR</span> <span class=n>UNALIGNED</span> <span class=o>*</span><span class=n>PIMAGE_IMPORT_DESCRIPTOR</span><span class=p>;</span>
</span></span></code></pre></div><p>Each dll in the Import Table as an IMAGE_IMPORT_DESCRIPTOR structure which contains information about it like its name, its functions, etc.</p><p>Here we will focus only on interesting things for us.</p><ul><li><p>DWORD Name : RVA of an ASCII string that contains the name of the module (dll name)</p></li><li><p>DWORD OriginalFirstThunk : RVA of the Import Lookup Table (ILT)</p></li><li><p>DWORD FirstThunk : RVA of the Import Address Table (IAT)</p></li></ul><p><em>Relative Virtual Address (RVA) means Relative to the base address</em>.</p><p>Example : <code>dll_name = PE_Base_Address + IMAGE_IMPORT_DESCRIPTOR.Name</code></p><h3 id=originalfirstthunk-and-firstthunk>OriginalFirstThunk and FirstThunk<a hidden class=anchor aria-hidden=true href=#originalfirstthunk-and-firstthunk>#</a></h3><p>The IAT and ILT are <em>parallel&rsquo;s NULL terminated arrays</em>.</p><p><img loading=lazy src=/img/posts/IAT_Hooking/ILT%20and%20IAT.png alt="IAT and ILT"></p><p>Their structure is defined as it :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_IMAGE_THUNK_DATA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span><span class=o>*</span> <span class=n>Function</span><span class=p>;</span>             <span class=c1>// address of imported function
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint32_t</span>  <span class=n>Ordinal</span><span class=p>;</span>              <span class=c1>// ordinal value of function
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>PIMAGE_IMPORT_BY_NAME</span> <span class=n>AddressOfData</span><span class=p>;</span>        <span class=c1>// RVA of imported name
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DWORD</span> <span class=n>ForwarderStringl</span>              <span class=c1>// RVA to forwarder string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>u1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_THUNK_DATA</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_THUNK_DATA</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=import-lookup-table>Import Lookup Table<a hidden class=anchor aria-hidden=true href=#import-lookup-table>#</a></h4><p>The ILT <em>contain names and <a href=https://rioasmara.com/2020/11/15/hide-api-call-strings-with-ordinals/>ordinals</a> for each API call</em>.</p><p><em>if the first bit of AddressOfData is 1, this DWORD is the ordinal of the function to import</em>.</p><p>Else, the AddressOfData <em>point to a IMAGE_IMPORT_BY_NAME structure</em> which contains the API call name and looks like this :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_IMAGE_IMPORT_BY_NAME</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>Hint</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span>    <span class=n>Name</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*The BYTE designated at Name of course only marks the beginning 
</span></span></span><span class=line><span class=cl><span class=cm>    of the character array of the imported function name as the name 
</span></span></span><span class=line><span class=cl><span class=cm>    can be larger than one character.*/</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_IMPORT_BY_NAME</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_IMPORT_BY_NAME</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=import-address-table>Import Address Table<a hidden class=anchor aria-hidden=true href=#import-address-table>#</a></h4><p>The <em>IAT contain virtual address of these API calls</em>.</p><h2 id=parsing-the-import-table>Parsing the import table<a hidden class=anchor aria-hidden=true href=#parsing-the-import-table>#</a></h2><p>Now, we have to parse our PE to find it&rsquo;s Import Table. To do that we will use the <em>winnt.h</em> library in C.</p><p>The following diagram illustrate the <em>simplified structure of a PE</em>.</p><p><img loading=lazy src=/img/posts/IAT_Hooking/PE_FORMAT_IAT.png alt="PE IAT format"></p><p>We first have <em>to retrieve the base address of our PE</em>. To do it we can call the GetModuleHandle() API call.</p><p><code>GetModuleHandle(NULL)</code></p><p>Now, like my <a href=https://trikkss.github.io/posts/hiding_windows_api_calls_part1/#parse-the-dlls>previous article about API Windows Hashing</a>, we will parse the PE.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HANDLE</span> <span class=n>PE_base</span> <span class=o>=</span> <span class=nf>GetModuleHandle</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span> <span class=n>p_DOS_HDR</span>  <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span><span class=p>)</span> <span class=n>PE_base</span><span class=p>;</span> <span class=c1>// convert your data into an IMAGE_DOS_HEADER* type defined in winnt.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span> <span class=n>p_NT_HDR</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>p_DOS_HDR</span><span class=o>-&gt;</span><span class=n>e_lfanew</span> <span class=p>);</span> <span class=c1>// NT HEADERS are located at the raw offset defined in the e_lfanew header
</span></span></span><span class=line><span class=cl><span class=c1>// RVA of the import table can be found in the optional headers
</span></span></span><span class=line><span class=cl><span class=c1>// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only
</span></span></span><span class=line><span class=cl><span class=c1>// https://0xrick.github.io/win-internals/pe6/#import-directory-table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span> <span class=n>import_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>p_NT_HDR</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class=p>].</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span></code></pre></div><p>Here we retrieve the address of the first IMAGE_IMPORT_DESCRIPTOR array.</p><p>we can easily iterate trought the null terminated array using a while loop :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>import_table</span><span class=o>-&gt;</span><span class=n>Name</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// print each dll loaded in the import table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>import_table</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, we want for each DLLs to retrieve their functions name and address. We first have to find our ILT and IAT and iterate throught it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span> <span class=n>lookup_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>import_table</span><span class=o>-&gt;</span><span class=n>OriginalFirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span> <span class=n>address_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>import_table</span><span class=o>-&gt;</span><span class=n>FirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// it will print all function name of the module.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span><span class=p>(</span><span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// check if its an import by ordinal
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>((</span><span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span> <span class=o>&amp;</span> <span class=n>IMAGE_ORDINAL_FLAG</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// retrieve the struct wich contains the function name
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span> <span class=n>lookup_addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>lookup_addr</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>lookup_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>address_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now we can print a function&rsquo;s address from its name, like <code>MessageBoxA</code> as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// we want to print the address of the MessageBoxA API call.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>lookup_addr</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>,</span> <span class=s>&#34;MessageBoxA&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>address_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>Function</span><span class=p>);</span> <span class=c1>// print the function address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Okay, now we have the address of the API call we want to hook.</p><p>The complete function to print it looks like this :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print_address_by_parsing_IAT</span><span class=p>(</span><span class=n>HMODULE</span> <span class=n>PE_base</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>function_to_hook</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span> <span class=n>p_DOS_HDR</span>  <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span><span class=p>)</span> <span class=n>PE_base</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span> <span class=n>p_NT_HDR</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>p_DOS_HDR</span><span class=o>-&gt;</span><span class=n>e_lfanew</span> <span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span> <span class=n>import_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>p_NT_HDR</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class=p>].</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// iterate throught the null terminated modules array
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>import_table</span><span class=o>-&gt;</span><span class=n>Name</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// retrieve ILT and IAT
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span> <span class=n>lookup_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>import_table</span><span class=o>-&gt;</span><span class=n>OriginalFirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span> <span class=n>address_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>import_table</span><span class=o>-&gt;</span><span class=n>FirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// iterate throught IAT and ILT
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span><span class=p>(</span><span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// check if the function is called by ordinal
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>((</span><span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span> <span class=o>&amp;</span> <span class=n>IMAGE_ORDINAL_FLAG</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>                <span class=c1>// if it is not retrieve its IMAGE_IMPORT_BY_NAME structure
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span> <span class=n>lookup_addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1>// compare the function name with the function name to hook
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span><span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>lookup_addr</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>,</span> <span class=n>function_to_hook</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>address_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>Function</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// next element of the IAT and the ILT
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>lookup_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>address_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// next module
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>import_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So, this function will just print the API call address. Now we have to change it.</p><h2 id=hooking-the-api-call>Hooking the API call<a hidden class=anchor aria-hidden=true href=#hooking-the-api-call>#</a></h2><p>Lets make a fake MessageBox :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>INT</span> <span class=n>WINAPI</span> <span class=nf>fake_messagebox</span><span class=p>(</span><span class=n>HWND</span> <span class=n>hWnd</span><span class=p>,</span> <span class=n>LPCTSTR</span> <span class=n>lpText</span><span class=p>,</span> <span class=n>LPCTSTR</span> <span class=n>lpCaption</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uType</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I hooked your function :)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;you wanted to display %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>lpText</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Instead of printing the <code>MessageBoxA</code> address in the IAT, <em>we will overwrite it</em> by <code>fake_messagebox</code> address and save the real MessageBox address into an other variable.</p><p><code>address_table->u1.Function = (ULONGLONG)fake_messagebox;</code></p><p>Our final code look like this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>int</span><span class=p>(</span><span class=n>WINAPI</span><span class=o>*</span> <span class=n>MESSAGE_BOX_TYPE</span><span class=p>)(</span><span class=n>HWND</span> <span class=n>hWnd</span><span class=p>,</span> <span class=n>LPCTSTR</span> <span class=n>lpText</span><span class=p>,</span> <span class=n>LPCTSTR</span> <span class=n>lpCaption</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uType</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>MESSAGE_BOX_TYPE</span> <span class=n>MessageBoxSaved</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>INT</span> <span class=n>WINAPI</span> <span class=nf>fake_messagebox</span><span class=p>(</span><span class=n>HWND</span> <span class=n>hWnd</span><span class=p>,</span> <span class=n>LPCTSTR</span> <span class=n>lpText</span><span class=p>,</span> <span class=n>LPCTSTR</span> <span class=n>lpCaption</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uType</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;I hooked your function :)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;you wanted to display %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>lpText</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>MessageBoxSaved</span><span class=p>(</span><span class=n>hWnd</span><span class=p>,</span> <span class=n>lpText</span><span class=p>,</span> <span class=n>lpCaption</span><span class=p>,</span> <span class=n>uType</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>hook_IAT</span><span class=p>(</span><span class=n>HMODULE</span> <span class=n>PE_base</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>function_to_hook</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span> <span class=n>p_DOS_HDR</span>  <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=o>*</span><span class=p>)</span> <span class=n>PE_base</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span> <span class=n>p_NT_HDR</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_NT_HEADERS</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>p_DOS_HDR</span><span class=o>-&gt;</span><span class=n>e_lfanew</span> <span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span> <span class=n>import_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>p_NT_HDR</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class=p>].</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// iterate throught the null terminated modules array
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>import_table</span><span class=o>-&gt;</span><span class=n>Name</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// retrieve ILT and IAT
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span> <span class=n>lookup_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>import_table</span><span class=o>-&gt;</span><span class=n>OriginalFirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span> <span class=n>address_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>import_table</span><span class=o>-&gt;</span><span class=n>FirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// iterate throught IAT and ILT
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span><span class=p>(</span><span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// check if the function is called by ordinal
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>((</span><span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span> <span class=o>&amp;</span> <span class=n>IMAGE_ORDINAL_FLAG</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>                <span class=c1>// if it is not retrieve its IMAGE_IMPORT_BY_NAME structure
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span> <span class=n>lookup_addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span><span class=p>)((</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>PE_base</span> <span class=o>+</span> <span class=n>lookup_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1>// compare the function name with the function name to hook
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span><span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>lookup_addr</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>,</span> <span class=n>function_to_hook</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// change its address
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>address_table</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>Function</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONGLONG</span><span class=p>)</span><span class=n>fake_messagebox</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// next element of the IAT and the ILT
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>lookup_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>address_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// next module
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>import_table</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// save MessageBox function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MessageBoxSaved</span> <span class=o>=</span> <span class=p>(</span><span class=n>MESSAGE_BOX_TYPE</span><span class=p>)</span><span class=nf>GetProcAddress</span><span class=p>(</span><span class=nf>LoadLibrary</span><span class=p>(</span><span class=s>&#34;user32.dll&#34;</span><span class=p>),</span> <span class=s>&#34;MessageBoxA&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// hook the function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>hook_IAT</span><span class=p>(</span><span class=nf>GetModuleHandle</span><span class=p>(</span><span class=nb>NULL</span><span class=p>),</span> <span class=s>&#34;MessageBoxA&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>MessageBoxA</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=s>&#34;hello world&#34;</span><span class=p>,</span> <span class=s>&#34;simple message box&#34;</span><span class=p>,</span> <span class=n>MB_OK</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* output :
</span></span></span><span class=line><span class=cl><span class=cm>I hooked your function :)
</span></span></span><span class=line><span class=cl><span class=cm>you wanted to display hello world
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><h2 id=to-go-further>To go further<a hidden class=anchor aria-hidden=true href=#to-go-further>#</a></h2><p>you can hook any function present in the IAT of an other process using <a href=https://en.wikipedia.org/wiki/DLL_injection>DLL injection</a> to execute some code which will patch the import table. It&rsquo;s a bit more difficult but it can be interesting for game hacking or reverse engineering.</p><h2 id=issue>Issue<a hidden class=anchor aria-hidden=true href=#issue>#</a></h2><p>This technic is useful, but it can be bypassed if the program retrieve its API call address from the <a href=https://trikkss.github.io/posts/hiding_windows_api_calls_part1/>Export Table using the GetProcAddress()</a> function.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This example was basic, but I think with it you can make lot of funny things.</p><p>I hope you enjoyed to read it, have a nice day.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://trikkss.github.io/tags/reverse-engineering/>Reverse engineering</a></li><li><a href=https://trikkss.github.io/tags/malware/>malware</a></li><li><a href=https://trikkss.github.io/tags/c/>C</a></li><li><a href=https://trikkss.github.io/tags/windows/>Windows</a></li><li><a href=https://trikkss.github.io/tags/pe/>PE</a></li><li><a href=https://trikkss.github.io/tags/dll/>DLL</a></li><li><a href=https://trikkss.github.io/tags/iat/>IAT</a></li></ul><nav class=paginav><a class=prev href=https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/><span class=title>« Prev</span><br><span>FCSC 2023 - Sensor Watch</span></a>
<a class=next href=https://trikkss.github.io/posts/hiding_windows_api_calls_part1/><span class=title>Next »</span><br><span>Malware - Windows API hashing 1</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://trikkss.github.io/>TRIKKSS Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>