<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FCSC 2023 - Sensor Watch | TRIKKSS Blog</title>
<meta name=keywords content="Reverse engineering,Firmware,ARM"><meta name=description content="Write up du challenge Sensor Watch."><meta name=author content="TRIKKSS"><link rel=canonical href=https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=16x16 href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=32x32 href=https://trikkss.github.io/img/pfp.png><link rel=apple-touch-icon href=https://trikkss.github.io/img/pfp.png><link rel=mask-icon href=https://trikkss.github.io/img/pfp.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="FCSC 2023 - Sensor Watch"><meta property="og:description" content="Write up du challenge Sensor Watch."><meta property="og:type" content="article"><meta property="og:url" content="https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/"><meta property="og:image" content="https://trikkss.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-30T00:00:00+00:00"><meta property="og:site_name" content="TRIKKSS Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trikkss.github.io/img/pfp.png"><meta name=twitter:title content="FCSC 2023 - Sensor Watch"><meta name=twitter:description content="Write up du challenge Sensor Watch."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://trikkss.github.io/posts/"},{"@type":"ListItem","position":2,"name":"FCSC 2023 - Sensor Watch","item":"https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FCSC 2023 - Sensor Watch","name":"FCSC 2023 - Sensor Watch","description":"Write up du challenge Sensor Watch.","keywords":["Reverse engineering","Firmware","ARM"],"articleBody":"vous pouvez retrouver les fichiers joint avec le chall ici\nDécouverte du challenge Pour ce challenge 2 fichiers nous ont été donnés, un dossier compressé contenant un emulateur ainsi qu’un dump de la flash d’une montre.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ file watch.uf2\rwatch.uf2: UF2 firmware image, file size 00000000, address 0x002000, 360 total blocks après quelques recherches sur le format de fichier on comprend que c’est un format dévellopé par microsoft afin de flasher des micro controleur\ngithub.com/microsoft/uf2 on trouve sur ce même github un script python permettant packer et à la fois d’unpacker des fichiers UF2.\nuf2/uf2conv.md on va donc télécharger ce script et extraire le firmware.\nwget https://github.com/microsoft/uf2/raw/master/utils/uf2conv.py\rwget https://github.com/microsoft/uf2/raw/master/utils/uf2families.json Une fois téléchargé on va pouvoir récuperer notre firmware avec la commande :\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ python3 uf2conv.py watch.uf2 --convert --output firmware.bin 1 ↵\r--- UF2 File Header Info ---\rAll block flag values consistent, 0x0000\r----------------------------\rConverted to bin, output size: 92160, start address: 0x2000\rWrote 92160 bytes to firmware.bin Dans l’archive “émulateur”, on peut trouver un docker contenant un fichier web-assembly qui semble émuler notre montre.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ tar -xvf emulateur.tar.gz\remulateur/\remulateur/src/\remulateur/src/favicon.ico\remulateur/src/watch.html\remulateur/src/watch.js\remulateur/src/watch.wasm\remulateur/docker-compose.yml\remulateur/Dockerfile\remulateur/README.md On peut lancer l’émulateur avec la commande docker-compose up et se rendre sur la page http://localhost:8000/watch.html\nOn joue un peu avec l’émulateur et on tombe rapidemment sur une interface “PIN” qui semble prendre en entrée un code PIN en incrémentant les chiffres présents sur le cadran de la montre.\nSi l’on tente de rentrer un mot de passe la montre nous répond “BADPIN”\nSensor Watch Après quelques recherches sur le modèle de la montre CASIO F-91W, un nom revient très souvent : celui de Joey Castillo.\nEn effet je tombe sur un github intéressant : GitHub - joeycastillo/Sensor-Watch\nJe n’ai pas remarqué de suite, mais ce github porte le nom du challenge ! On est donc sur la bonne voie.\nEn parcourant le github on comprend que la Sensor Watch est une carte de remplacement pour la montre Casio F-91W sur laquelle on peut intégrer en quelque sorte des mods etc.\nOn peut d’ailleurs y retrouver notre émulateur quand on jette un oeil au framework Movement.\nOn a le code source du framework utilisé !\nOn peut donc maintenant passer au passer au reverse engineering de notre montre.\nReverse engineering Afin de decompiler le firmware je vais utiliser le framework ghidra.\nOn peut lire sur le github de la sensor watch :\nARM Cortex M0+ microcontroller Afin d’en savoir plus on cherche la datasheet du micro controleur. https://www.st.com/resource/en/datasheet/stm32g081rb.pdf\nOn est donc sur de l’ARM compilé en 32 bits.\nl’outil binbloom peut lui aussi nous donner des informations à propos du firmware.\n╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup\r╰─➤ binbloom -a 32 firmware.bin 255 ↵\r[i] 32-bit architecture selected.\r[i] File read (92160 bytes)\r[i] Endianness is LE\r[i] 143 strings indexed\r[i] Found 580 base addresses to test\r[i] Base address found (valid array): 0x00002000.\rMore base addresses to consider (just in case):\r0x1ffeb000 (0.03)\r0x1fff8000 (0.01)\r0x46bfa000 (0.00)\r0x001fb000 (0.00) Cet outil nous apprend que les octets dans le firmware sont en little endian et nous propose des addresse de bases afin de mapper correctement notre binaire.\nOn est donc maintenant prêt à charger notre firmware dans Ghidra.\nUne fois notre binaire chargé on va aller dans Window -\u003e Memory Map et cliquer sur la petite maison afin de modifier l’addresse de base du binaire.\net l’on va la mettre à 0x2000. A ce moment là vous vous rendrez compte que ghidra vous a maintenant trouvé plein de fonctions. En effet, grâce à l’addresse de base les fonctions ainsi que les symboles présents dans le binaire vont pouvoir être résolus par notre désassembleur car ils seront à leur addresse correcte. Je vous conseille tout de même de lancer à nouveau une auto-analyse du firmware ainsi qu’un “ARM agressive instruction finder”.\nCommençons donc à investiguer.\nPour ma part j’ai d’abord commencé par regarder les chaines de caractères présentes dans le binaire. Certaines telles que “BADPIN”, “PI N%c%c%c%c%c%c”\nA la suite de ça on peut trouver les fonctions qui utilise ces chaines de caractère.\nOn trouve cette fonction qui fait reference à la chaine “BADPIN” :\nundefined8 UndefinedFunction_0000b308(uint param_1,uint param_2,char *param_3) { int iVar1; undefined *puVar2; char cVar3; char extraout_r1; int extraout_r1_00; int iVar4; uint uStack_14; iVar1 = DAT_0000b3fc; uStack_14 = param_2 \u0026 0xffff0000 | param_1 \u0026 0xffff; switch(param_1 \u0026 0xff) { case 1: if (*param_3 != '\\0') break; goto LAB_0000b376; case 2: cVar3 = *param_3; if (cVar3 == '\\0') { if ((int)((uStack_14 \u003e\u003e 8) \u003c\u003c 0x1f) \u003c 0) { cVar3 = param_3[2] + '\\x04'; puVar2 = DAT_0000b3f8; LAB_0000b340: FUN_00005a84(puVar2,cVar3); break; } } else if (cVar3 == '\\x01') { FUN_00006a88(param_3 + 3,6,DAT_0000b3fc,0); iVar4 = 0; do { if (PTR_DAT_0000b400[iVar4] != (*(byte *)(iVar1 + iVar4) ^ 0x15)) { cVar3 = '\\0'; goto LAB_0000b370; } iVar4 = iVar4 + 1; } while (iVar4 != 0x40); cVar3 = '\\x01'; LAB_0000b370: *param_3 = '\\x03' - cVar3; } else { if (cVar3 != '\\x03') { if (cVar3 != '\\x02') break; cVar3 = '\\0'; puVar2 = PTR_DAT_0000b408; goto LAB_0000b340; } FUN_0000e31c(param_3 + 3,PTR_s_BADPIN_0000b404); param_3[1] = '\\0'; param_3[2] = '\\0'; } LAB_0000b376: FUN_0000b29c(param_3); break; default: FUN_0000a700(uStack_14); break; case 5: FUN_0000a6c4(0); break; case 6: if (*param_3 == '\\0') { if ((byte)param_3[2] == 5) { *param_3 = '\\x01'; } FUN_0000b744((byte)param_3[2] + 1,6); param_3[2] = extraout_r1; param_3[1] = '\\0'; } break; case 0xe: if (*param_3 == '\\0') { FUN_0000b744((byte)param_3[1] + 1,10); puVar2 = PTR_s_0123456789_0000b40c; param_3[1] = (char)extraout_r1_00; param_3[(byte)param_3[2] + 3] = puVar2[extraout_r1_00]; } } return CONCAT44(param_1,1); } Malheureusement elle n’est pas très compréhensible.\nSachant que nous avons une partie du code source de notre firmware, nous pouvons nous en servir afin de retrouver des symboles.\nJ’ai donc procédé de la même manière suivante, pour chaque fonctions présentes dans le code source de la Sensor-Watch et en particulier du framework movement, je modifie le nom de la fonction.\nQuelques exemples de fonctions que j’ai utilisé sont :\napp_init\napp_loop\nfile_system_init\nfilesystem_process_command\nfile_system_write_file\n…\nGrâce à cela, j’ai pu retrouver plusieurs symboles et avoir une meilleure compréhension de notre fonction.\nLa documentation de Movement fût également d’une grande aide :\nSensor-Watch/README.md at main · joeycastillo/Sensor-Watch · GitHub\nOn comprend donc que le code trouvé précedemment équivaut à la fonction face_loop\nEn s’aidant de cette page de documentation, de quelques exemples présent sur le github ainsi que des symboles que l’on a résolu je réussis à réécrire un code un peu plus compréhensible.\nundefined8 face_loop(event_type event,astruct_1 *param_2,struct_context *context) { undefined *puVar1; char cVar2; uchar extraout_r1; int extraout_r1_00; int iVar3; uint local_14; int state; buffer = DAT_0000b3fc; local_14 = (uint)param_2 \u0026 0xffff0000 | (uint)(ushort)event; switch(event.event_type) { case '\\x01': if (context-\u003eaction != '\\0') break; goto LAB_0000b376; case '\\x02': /* si context-\u003e action n'est pas égal à 0 on va appeler */ cVar2 = context-\u003eaction; if (cVar2 == '\\0') { if ((int)((local_14 \u003e\u003e 8) \u003c\u003c 0x1f) \u003c 0) { cVar2 = context-\u003eindex + '\\x04'; puVar1 = DAT_0000b3f8; LAB_0000b340: watch_display_string(puVar1,cVar2); break; } } else if (cVar2 == '\\x01') { /* on dirait qu'il va mettre des données à l'adresse de DAT_0000b3fc et va ensuite itérer dessus en faisait un xor 0x15 sur chaque valeur à cette addresse et la comparer avec des valeurs d'une array de 64 bytes */ unknow_function(context-\u003ePIN,6,DAT_0000b3fc,0); iVar3 = 0; do { if (PTR_DAT_0000b400[iVar3] != (*(byte *)(state + iVar3) ^ 0x15)) { cVar2 = '\\0'; goto LAB_0000b370; } iVar3 = iVar3 + 1; } while (iVar3 != 0x40); cVar2 = '\\x01'; LAB_0000b370: context-\u003eaction = '\\x03' - cVar2; } else { if (cVar2 != '\\x03') { if (cVar2 != '\\x02') break; cVar2 = '\\0'; puVar1 = FCSC; goto LAB_0000b340; } maybe_print(context-\u003ePIN,PTR_s_BADPIN_0000b404); context-\u003eticks = '\\0'; context-\u003eindex = '\\0'; } LAB_0000b376: update_cadran(context); break; default: movement_default_loop_handler(local_14); break; case '\\x05': FUN_0000a6c4(0); break; case '\\x06': /* bouton en haut à gauche de la montre, on incrémente notre index et si il est égal à 5 on passe context à 1 */ if (context-\u003eaction == '\\0') { if (context-\u003eindex == 5) { context-\u003eaction = '\\x01'; } FUN_0000b744(context-\u003eindex + 1,6); context-\u003eindex = extraout_r1; context-\u003eticks = '\\0'; } break; case '\\x0e': if (context-\u003eaction == '\\0') { /* incremente le password à la position password[param[2]] (bouton en bas à droite) */ FUN_0000b744(context-\u003eticks + 1,10); puVar1 = PTR_s_0123456789_0000b40c; /* PTR_s_0123456789_0000b40c pointe vers \"0123456789\" */ context-\u003eticks = (uchar)extraout_r1_00; context-\u003ePIN[context-\u003eindex] = puVar1[extraout_r1_00]; } } return CONCAT44((uint)(ushort)event,1); } J’ai aussi réimplémenter les structures suivantes :\nstruct struct_context { uint8 ticks; uint8 index; char PIN[6] } struct event_type { uint8 no_idea; uint8 event; } la structure contexte contient le code PIN entré ainsi que l’index du code PIN que l’on est actuellement en train de modifier.\nLa structure event contient l’action réalisé par l’utilisateur.\nA partir de là, le code reste plutôt sale mais j’espère que vous le comprendrez aussi grâce à mes commentaires.\nA partir de là une chose était sure pour moi. Il fallait qu’une fois unknow_function était appelée avec en paramètre notre PIN ainsi que sa taille DAT_0000b3fc soit égal au 64 bytes présent à l’addresse PTR_DAT_0000b400 xor par 15.\nJe me suis donc mis à reverse la fonction unknow function pendant un très long moment sans comprendre son fonctionnement.\nPuis une idée m’est venue, googler les constantes ! Et effectivemment on tombe rapidemment sur des liens parlant de sha512.\nA ce moment là, tout deviens plus clair. En effet la taille d’un hash sha512 est de 64 bytes ! On cherche donc un peu et on retrouve dans le code source de la Sensor Watch notre fonction de hashage.\nJe récupère donc le tableau de 64 bytes\n[ 0xe3, 0x1e, 0x2c, 0x61, 0x36, 0xbd, 0xa8, 0xc0, 0x53, 0xf0, 0xf4, 0x45, 0x91, 0x88, 0x0b, 0xa7, 0x86, 0x39, 0x35, 0xd8, 0xb3, 0xc9, 0x7a, 0x3c, 0xca, 0xdf, 0xdd, 0xc2, 0xb3, 0x68, 0x97, 0xe8, 0x6c, 0x17, 0xd7, 0x97, 0x60, 0x1a, 0x3c, 0xda, 0xa6, 0xb8, 0x24, 0xd3, 0xb9, 0xac, 0xe6, 0xec, 0xac, 0xac, 0x55, 0xfd, 0x49, 0xaf, 0x5d, 0xaa, 0x44, 0x4f, 0x8f, 0x3e, 0x7d, 0xf5, 0xf2, 0xa7 ] que je xor par 0x15 afin d’obtenir le hash suivant :\nf60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2 Nous savons que notre code PIN à une taille de 6 caractère et nous avons “0123456” comme set de caractère. On pourra donc très facilement casser ce mot de passe.\nPour ce faire j’ai utilisé hashcat :\n.\\hashcat.exe -m 1700 -a 3 f60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2 ?d?d?d?d?d?d Et nous obtenons un code pin qui est 413372 !!\nOn peut donc maintenant l’essayer dans notre émulateur et obtenir le flag.\nLe flag est donc FCSC413372 !\nConclusion C’était la première fois que je reversais un firmware et malgré beaucoup de difficultés au début j’ai apprécié ce challenge. Si je devais en retenir quelque chose ce serait prendre le temps de comprendre le firmware afin de configurer correctement son désassembleur. J’ai en effet l’habitude de reverse des binaires très communs tels que des ELF, PE, etc. qui sont très bien pris en charges par les désassembleurs. Ce fut un challenge très enrichissant, un grand merci aux créateurs.\n","wordCount":"1811","inLanguage":"en","datePublished":"2023-04-30T00:00:00Z","dateModified":"2023-04-30T00:00:00Z","author":{"@type":"Person","name":"TRIKKSS"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://trikkss.github.io/posts/fcsc2023_Sensor-Watch/"},"publisher":{"@type":"Organization","name":"TRIKKSS Blog","logo":{"@type":"ImageObject","url":"https://trikkss.github.io/img/pfp.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://trikkss.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://trikkss.github.io/img/pfp.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://trikkss.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://trikkss.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://trikkss.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://trikkss.github.io/posts/>Posts</a></div><h1 class=post-title>FCSC 2023 - Sensor Watch</h1><div class=post-meta>&lt;span title='2023-04-30 00:00:00 +0000 UTC'>April 30, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;9 min&amp;nbsp;·&amp;nbsp;1811 words&amp;nbsp;·&amp;nbsp;TRIKKSS</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#découverte-du-challenge>Découverte du challenge</a></li><li><a href=#sensor-watch>Sensor Watch</a></li><li><a href=#reverse-engineering>Reverse engineering</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p><em>vous pouvez retrouver les fichiers joint avec le chall <a href=/static/sensor-watch.zip>ici</a></em></p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/enonce.png alt="énoncée du challenge"></p><h2 id=découverte-du-challenge>Découverte du challenge<a hidden class=anchor aria-hidden=true href=#découverte-du-challenge>#</a></h2><p>Pour ce challenge 2 fichiers nous ont été donnés, un dossier compressé contenant un emulateur ainsi qu&rsquo;un dump de la flash d&rsquo;une montre.</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup
╰─➤  file watch.uf2
watch.uf2: UF2 firmware image, file size 00000000, address 0x002000, 360 total blocks
</code></pre><p>après quelques recherches sur le format de fichier on comprend que c&rsquo;est un format dévellopé par microsoft afin de flasher des micro controleur</p><ul><li><a href=https://github.com/microsoft/uf2>github.com/microsoft/uf2</a></li></ul><p>on trouve sur ce même github un script python permettant packer et à la fois d&rsquo;unpacker des fichiers UF2.</p><ul><li><a href=https://github.com/microsoft/uf2/blob/master/utils/uf2conv.md>uf2/uf2conv.md</a></li></ul><p>on va donc télécharger ce script et extraire le firmware.</p><pre tabindex=0><code>wget https://github.com/microsoft/uf2/raw/master/utils/uf2conv.py
wget https://github.com/microsoft/uf2/raw/master/utils/uf2families.json
</code></pre><p>Une fois téléchargé on va pouvoir récuperer notre firmware avec la commande :</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup
╰─➤  python3 uf2conv.py watch.uf2 --convert --output firmware.bin                                     1 ↵
--- UF2 File Header Info ---
All block flag values consistent, 0x0000
----------------------------
Converted to bin, output size: 92160, start address: 0x2000
Wrote 92160 bytes to firmware.bin
</code></pre><p>Dans l&rsquo;archive &ldquo;émulateur&rdquo;, on peut trouver un docker contenant un fichier web-assembly qui semble émuler notre montre.</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup
╰─➤  tar -xvf emulateur.tar.gz
emulateur/
emulateur/src/
emulateur/src/favicon.ico
emulateur/src/watch.html
emulateur/src/watch.js
emulateur/src/watch.wasm
emulateur/docker-compose.yml
emulateur/Dockerfile
emulateur/README.md
</code></pre><p>On peut lancer l&rsquo;émulateur avec la commande <code>docker-compose up</code> et se rendre sur la page <code>http://localhost:8000/watch.html</code></p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/emulator.png alt=emulateur></p><p>On joue un peu avec l&rsquo;émulateur et on tombe rapidemment sur une interface &ldquo;PIN&rdquo; qui semble prendre en entrée un code PIN en incrémentant les chiffres présents sur le cadran de la montre.</p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/pin.png alt=pin></p><p>Si l&rsquo;on tente de rentrer un mot de passe la montre nous répond &ldquo;BADPIN&rdquo;</p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/badpin.png alt="bad pin"></p><h2 id=sensor-watch>Sensor Watch<a hidden class=anchor aria-hidden=true href=#sensor-watch>#</a></h2><p>Après quelques recherches sur le modèle de la montre CASIO F-91W, un nom revient très souvent : celui de <strong>Joey Castillo</strong>.</p><p>En effet je tombe sur un github intéressant : <a href=https://github.com/joeycastillo/Sensor-Watch>GitHub - joeycastillo/Sensor-Watch</a></p><p>Je n&rsquo;ai pas remarqué de suite, mais ce github porte le nom du challenge ! On est donc sur la bonne voie.</p><p>En parcourant le github on comprend que la Sensor Watch est une carte de remplacement pour la montre Casio F-91W sur laquelle on peut intégrer en quelque sorte des mods etc.</p><p>On peut d&rsquo;ailleurs y retrouver notre émulateur quand on jette un oeil au framework <em>Movement</em>.</p><p>On a le code source du framework utilisé !</p><p>On peut donc maintenant passer au passer au reverse engineering de notre montre.</p><h2 id=reverse-engineering>Reverse engineering<a hidden class=anchor aria-hidden=true href=#reverse-engineering>#</a></h2><p>Afin de decompiler le firmware je vais utiliser le framework <a href=https://ghidra-sre.org/>ghidra</a>.</p><p>On peut lire sur le github de la sensor watch :</p><ul><li>ARM Cortex M0+ microcontroller</li></ul><p>Afin d&rsquo;en savoir plus on cherche la datasheet du micro controleur. <a href=https://www.st.com/resource/en/datasheet/stm32g081rb.pdf>https://www.st.com/resource/en/datasheet/stm32g081rb.pdf</a></p><p>On est donc sur de l&rsquo;ARM compilé en 32 bits.</p><p>l&rsquo;outil <a href=https://github.com/quarkslab/binbloom>binbloom</a> peut lui aussi nous donner des informations à propos du firmware.</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/fcsc2023/reverse/sensor_watch/writeup
╰─➤  binbloom -a 32 firmware.bin                                                                    255 ↵
[i] 32-bit architecture selected.
[i] File read (92160 bytes)
[i] Endianness is LE
[i] 143 strings indexed
[i] Found 580 base addresses to test
[i] Base address found (valid array): 0x00002000.
 More base addresses to consider (just in case):
  0x1ffeb000 (0.03)
  0x1fff8000 (0.01)
  0x46bfa000 (0.00)
  0x001fb000 (0.00)
</code></pre><p>Cet outil nous apprend que les octets dans le firmware sont en little endian et nous propose des addresse de bases afin de mapper correctement notre binaire.</p><p>On est donc maintenant prêt à charger notre firmware dans Ghidra.</p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/import_ghidra.png alt="import firmware dans ghidra"></p><p>Une fois notre binaire chargé on va aller dans <code>Window -> Memory Map</code> et cliquer sur la petite maison afin de modifier l&rsquo;addresse de base du binaire.</p><p><img loading=lazy src=C:%5cUsers%5c0xTRIKKSS%5cAppData%5cRoaming%5cmarktext%5cimages%5c2023-04-29-22-43-33-image.png alt></p><p>et l&rsquo;on va la mettre à <code>0x2000</code>. A ce moment là vous vous rendrez compte que ghidra vous a maintenant trouvé plein de fonctions. En effet, grâce à l&rsquo;addresse de base les fonctions ainsi que les symboles présents dans le binaire vont pouvoir être résolus par notre désassembleur car ils seront à leur addresse correcte. Je vous conseille tout de même de lancer à nouveau une auto-analyse du firmware ainsi qu&rsquo;un &ldquo;ARM agressive instruction finder&rdquo;.</p><p>Commençons donc à investiguer.</p><p>Pour ma part j&rsquo;ai d&rsquo;abord commencé par regarder les chaines de caractères présentes dans le binaire. Certaines telles que &ldquo;BADPIN&rdquo;, &ldquo;PI N%c%c%c%c%c%c&rdquo;</p><p>A la suite de ça on peut trouver les fonctions qui utilise ces chaines de caractère.</p><p>On trouve cette fonction qui fait reference à la chaine &ldquo;BADPIN&rdquo; :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>undefined8</span> <span class=nf>UndefinedFunction_0000b308</span><span class=p>(</span><span class=n>uint</span> <span class=n>param_1</span><span class=p>,</span><span class=n>uint</span> <span class=n>param_2</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span><span class=n>param_3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>iVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>undefined</span> <span class=o>*</span><span class=n>puVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>cVar3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>extraout_r1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>extraout_r1_00</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>iVar4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uStack_14</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>iVar1</span> <span class=o>=</span> <span class=n>DAT_0000b3fc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uStack_14</span> <span class=o>=</span> <span class=n>param_2</span> <span class=o>&amp;</span> <span class=mh>0xffff0000</span> <span class=o>|</span> <span class=n>param_1</span> <span class=o>&amp;</span> <span class=mh>0xffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span><span class=p>(</span><span class=n>param_1</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>param_3</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>LAB_0000b376</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>cVar3</span> <span class=o>=</span> <span class=o>*</span><span class=n>param_3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cVar3</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>((</span><span class=kt>int</span><span class=p>)((</span><span class=n>uStack_14</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x1f</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cVar3</span> <span class=o>=</span> <span class=n>param_3</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=sc>&#39;\x04&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>puVar2</span> <span class=o>=</span> <span class=n>DAT_0000b3f8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>LAB_0000b340</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>FUN_00005a84</span><span class=p>(</span><span class=n>puVar2</span><span class=p>,</span><span class=n>cVar3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>cVar3</span> <span class=o>==</span> <span class=sc>&#39;\x01&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>FUN_00006a88</span><span class=p>(</span><span class=n>param_3</span> <span class=o>+</span> <span class=mi>3</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=n>DAT_0000b3fc</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>iVar4</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>PTR_DAT_0000b400</span><span class=p>[</span><span class=n>iVar4</span><span class=p>]</span> <span class=o>!=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>byte</span> <span class=o>*</span><span class=p>)(</span><span class=n>iVar1</span> <span class=o>+</span> <span class=n>iVar4</span><span class=p>)</span> <span class=o>^</span> <span class=mh>0x15</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>cVar3</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>goto</span> <span class=n>LAB_0000b370</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>iVar4</span> <span class=o>=</span> <span class=n>iVar4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>iVar4</span> <span class=o>!=</span> <span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>cVar3</span> <span class=o>=</span> <span class=sc>&#39;\x01&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>LAB_0000b370</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=o>*</span><span class=n>param_3</span> <span class=o>=</span> <span class=sc>&#39;\x03&#39;</span> <span class=o>-</span> <span class=n>cVar3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>cVar3</span> <span class=o>!=</span> <span class=sc>&#39;\x03&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>cVar3</span> <span class=o>!=</span> <span class=sc>&#39;\x02&#39;</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cVar3</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>puVar2</span> <span class=o>=</span> <span class=n>PTR_DAT_0000b408</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>LAB_0000b340</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nf>FUN_0000e31c</span><span class=p>(</span><span class=n>param_3</span> <span class=o>+</span> <span class=mi>3</span><span class=p>,</span><span class=n>PTR_s_BADPIN_0000b404</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>param_3</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>param_3</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nl>LAB_0000b376</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>FUN_0000b29c</span><span class=p>(</span><span class=n>param_3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>FUN_0000a700</span><span class=p>(</span><span class=n>uStack_14</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>5</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>FUN_0000a6c4</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>6</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>param_3</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>((</span><span class=n>byte</span><span class=p>)</span><span class=n>param_3</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>==</span> <span class=mi>5</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>param_3</span> <span class=o>=</span> <span class=sc>&#39;\x01&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nf>FUN_0000b744</span><span class=p>((</span><span class=n>byte</span><span class=p>)</span><span class=n>param_3</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span><span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>param_3</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>extraout_r1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>param_3</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mh>0xe</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>param_3</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>FUN_0000b744</span><span class=p>((</span><span class=n>byte</span><span class=p>)</span><span class=n>param_3</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>puVar2</span> <span class=o>=</span> <span class=n>PTR_s_0123456789_0000b40c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>param_3</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=p>)</span><span class=n>extraout_r1_00</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>param_3</span><span class=p>[(</span><span class=n>byte</span><span class=p>)</span><span class=n>param_3</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>puVar2</span><span class=p>[</span><span class=n>extraout_r1_00</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>CONCAT44</span><span class=p>(</span><span class=n>param_1</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Malheureusement elle n&rsquo;est pas très compréhensible.</p><p>Sachant que nous avons une partie du code source de notre firmware, nous pouvons nous en servir afin de retrouver des symboles.</p><p>J&rsquo;ai donc procédé de la même manière suivante, pour chaque fonctions présentes dans le code source de la Sensor-Watch et en particulier du framework movement, je modifie le nom de la fonction.</p><p>Quelques exemples de fonctions que j&rsquo;ai utilisé sont :</p><ul><li><p>app_init</p></li><li><p>app_loop</p></li><li><p>file_system_init</p></li><li><p>filesystem_process_command</p></li><li><p>file_system_write_file</p></li><li><p>&mldr;</p></li></ul><p>Grâce à cela, j&rsquo;ai pu retrouver plusieurs symboles et avoir une meilleure compréhension de notre fonction.</p><p>La documentation de Movement fût également d&rsquo;une grande aide :</p><p><a href=https://github.com/joeycastillo/Sensor-Watch/blob/main/movement/README.md>Sensor-Watch/README.md at main · joeycastillo/Sensor-Watch · GitHub</a></p><p>On comprend donc que le code trouvé précedemment équivaut à la fonction <code>face_loop</code></p><p>En s&rsquo;aidant de cette page de documentation, de quelques exemples présent sur le github ainsi que des symboles que l&rsquo;on a résolu je réussis à réécrire un code un peu plus compréhensible.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>undefined8</span> <span class=nf>face_loop</span><span class=p>(</span><span class=n>event_type</span> <span class=n>event</span><span class=p>,</span><span class=n>astruct_1</span> <span class=o>*</span><span class=n>param_2</span><span class=p>,</span><span class=n>struct_context</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>undefined</span> <span class=o>*</span><span class=n>puVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>cVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uchar</span> <span class=n>extraout_r1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>extraout_r1_00</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>iVar3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>local_14</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>buffer</span> <span class=o>=</span> <span class=n>DAT_0000b3fc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>local_14</span> <span class=o>=</span> <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>param_2</span> <span class=o>&amp;</span> <span class=mh>0xffff0000</span> <span class=o>|</span> <span class=p>(</span><span class=n>uint</span><span class=p>)(</span><span class=n>ushort</span><span class=p>)</span><span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span><span class=p>(</span><span class=n>event</span><span class=p>.</span><span class=n>event_type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=sc>&#39;\x01&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>action</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>LAB_0000b376</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=sc>&#39;\x02&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    si context-&gt; action n&#39;est pas égal à 0 on va appeler
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>cVar2</span> <span class=o>=</span> <span class=n>context</span><span class=o>-&gt;</span><span class=n>action</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cVar2</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>((</span><span class=kt>int</span><span class=p>)((</span><span class=n>local_14</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x1f</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cVar2</span> <span class=o>=</span> <span class=n>context</span><span class=o>-&gt;</span><span class=n>index</span> <span class=o>+</span> <span class=sc>&#39;\x04&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>puVar1</span> <span class=o>=</span> <span class=n>DAT_0000b3f8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>LAB_0000b340</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>watch_display_string</span><span class=p>(</span><span class=n>puVar1</span><span class=p>,</span><span class=n>cVar2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>cVar2</span> <span class=o>==</span> <span class=sc>&#39;\x01&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=cm>/* on dirait qu&#39;il va mettre des données à l&#39;adresse de DAT_0000b3fc 
</span></span></span><span class=line><span class=cl><span class=cm>      et va ensuite itérer dessus en faisait un xor 0x15 sur chaque valeur
</span></span></span><span class=line><span class=cl><span class=cm>      à cette addresse et la comparer avec des valeurs d&#39;une array de 64 bytes */</span>
</span></span><span class=line><span class=cl>      <span class=nf>unknow_function</span><span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>PIN</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=n>DAT_0000b3fc</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>iVar3</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>PTR_DAT_0000b400</span><span class=p>[</span><span class=n>iVar3</span><span class=p>]</span> <span class=o>!=</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>byte</span> <span class=o>*</span><span class=p>)(</span><span class=n>state</span> <span class=o>+</span> <span class=n>iVar3</span><span class=p>)</span> <span class=o>^</span> <span class=mh>0x15</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>cVar2</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>goto</span> <span class=n>LAB_0000b370</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>iVar3</span> <span class=o>=</span> <span class=n>iVar3</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>iVar3</span> <span class=o>!=</span> <span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>cVar2</span> <span class=o>=</span> <span class=sc>&#39;\x01&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>LAB_0000b370</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>context</span><span class=o>-&gt;</span><span class=n>action</span> <span class=o>=</span> <span class=sc>&#39;\x03&#39;</span> <span class=o>-</span> <span class=n>cVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>cVar2</span> <span class=o>!=</span> <span class=sc>&#39;\x03&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>cVar2</span> <span class=o>!=</span> <span class=sc>&#39;\x02&#39;</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cVar2</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>puVar1</span> <span class=o>=</span> <span class=n>FCSC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>LAB_0000b340</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nf>maybe_print</span><span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>PIN</span><span class=p>,</span><span class=n>PTR_s_BADPIN_0000b404</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>context</span><span class=o>-&gt;</span><span class=n>ticks</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>context</span><span class=o>-&gt;</span><span class=n>index</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nl>LAB_0000b376</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>update_cadran</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>movement_default_loop_handler</span><span class=p>(</span><span class=n>local_14</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=sc>&#39;\x05&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>FUN_0000a6c4</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=sc>&#39;\x06&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>       bouton en haut à gauche de la montre, on incrémente 
</span></span></span><span class=line><span class=cl><span class=cm>       notre index et si il est égal à 5 on passe context à 1
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>action</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>index</span> <span class=o>==</span> <span class=mi>5</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>context</span><span class=o>-&gt;</span><span class=n>action</span> <span class=o>=</span> <span class=sc>&#39;\x01&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nf>FUN_0000b744</span><span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span><span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>context</span><span class=o>-&gt;</span><span class=n>index</span> <span class=o>=</span> <span class=n>extraout_r1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>context</span><span class=o>-&gt;</span><span class=n>ticks</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=sc>&#39;\x0e&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>action</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* incremente le password à la position password[param[2]] 
</span></span></span><span class=line><span class=cl><span class=cm>    (bouton en bas à droite) */</span>
</span></span><span class=line><span class=cl>      <span class=nf>FUN_0000b744</span><span class=p>(</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>ticks</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>puVar1</span> <span class=o>=</span> <span class=n>PTR_s_0123456789_0000b40c</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>      <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      PTR_s_0123456789_0000b40c pointe vers &#34;0123456789&#34;
</span></span></span><span class=line><span class=cl><span class=cm>      */</span>
</span></span><span class=line><span class=cl>      <span class=n>context</span><span class=o>-&gt;</span><span class=n>ticks</span> <span class=o>=</span> <span class=p>(</span><span class=n>uchar</span><span class=p>)</span><span class=n>extraout_r1_00</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>context</span><span class=o>-&gt;</span><span class=n>PIN</span><span class=p>[</span><span class=n>context</span><span class=o>-&gt;</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>puVar1</span><span class=p>[</span><span class=n>extraout_r1_00</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>CONCAT44</span><span class=p>((</span><span class=n>uint</span><span class=p>)(</span><span class=n>ushort</span><span class=p>)</span><span class=n>event</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>J&rsquo;ai aussi réimplémenter les structures suivantes :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>struct_context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8</span> <span class=n>ticks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>  <span class=n>PIN</span><span class=p>[</span><span class=mi>6</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>event_type</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8</span> <span class=n>no_idea</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>la structure contexte contient le code PIN entré ainsi que l&rsquo;index du code PIN que l&rsquo;on est actuellement en train de modifier.</p><p>La structure event contient l&rsquo;action réalisé par l&rsquo;utilisateur.</p><p>A partir de là, le code reste plutôt sale mais j&rsquo;espère que vous le comprendrez aussi grâce à mes commentaires.</p><p>A partir de là une chose était sure pour moi. Il fallait qu&rsquo;une fois <code>unknow_function</code> était appelée avec en paramètre notre PIN ainsi que sa taille <code>DAT_0000b3fc</code> soit égal au 64 bytes présent à l&rsquo;addresse <code>PTR_DAT_0000b400</code> xor par 15.</p><p>Je me suis donc mis à reverse la fonction <code>unknow function</code> pendant un très long moment sans comprendre son fonctionnement.</p><p>Puis une idée m&rsquo;est venue, googler les constantes ! Et effectivemment on tombe rapidemment sur des liens parlant de sha512.</p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/constantes_google.png alt="constantes google"></p><p>A ce moment là, tout deviens plus clair. En effet la taille d&rsquo;un hash sha512 est de 64 bytes ! On cherche donc un peu et on retrouve dans le code source de la Sensor Watch notre fonction de hashage.</p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/sha512.png alt="sha512 function"></p><p>Je récupère donc le tableau de 64 bytes</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=p>[</span> <span class=mh>0xe3</span><span class=p>,</span> <span class=mh>0x1e</span><span class=p>,</span> <span class=mh>0x2c</span><span class=p>,</span> <span class=mh>0x61</span><span class=p>,</span> <span class=mh>0x36</span><span class=p>,</span> <span class=mh>0xbd</span><span class=p>,</span> <span class=mh>0xa8</span><span class=p>,</span> <span class=mh>0xc0</span><span class=p>,</span> <span class=mh>0x53</span><span class=p>,</span> <span class=mh>0xf0</span><span class=p>,</span> <span class=mh>0xf4</span><span class=p>,</span> <span class=mh>0x45</span><span class=p>,</span> <span class=mh>0x91</span><span class=p>,</span> <span class=mh>0x88</span><span class=p>,</span> <span class=mh>0x0b</span><span class=p>,</span> <span class=mh>0xa7</span><span class=p>,</span> <span class=mh>0x86</span><span class=p>,</span> <span class=mh>0x39</span><span class=p>,</span> <span class=mh>0x35</span><span class=p>,</span> <span class=mh>0xd8</span><span class=p>,</span> <span class=mh>0xb3</span><span class=p>,</span> <span class=mh>0xc9</span><span class=p>,</span> <span class=mh>0x7a</span><span class=p>,</span> <span class=mh>0x3c</span><span class=p>,</span> <span class=mh>0xca</span><span class=p>,</span> <span class=mh>0xdf</span><span class=p>,</span> <span class=mh>0xdd</span><span class=p>,</span> <span class=mh>0xc2</span><span class=p>,</span> <span class=mh>0xb3</span><span class=p>,</span> <span class=mh>0x68</span><span class=p>,</span> <span class=mh>0x97</span><span class=p>,</span> <span class=mh>0xe8</span><span class=p>,</span> <span class=mh>0x6c</span><span class=p>,</span> <span class=mh>0x17</span><span class=p>,</span> <span class=mh>0xd7</span><span class=p>,</span> <span class=mh>0x97</span><span class=p>,</span> <span class=mh>0x60</span><span class=p>,</span> <span class=mh>0x1a</span><span class=p>,</span> <span class=mh>0x3c</span><span class=p>,</span> <span class=mh>0xda</span><span class=p>,</span> <span class=mh>0xa6</span><span class=p>,</span> <span class=mh>0xb8</span><span class=p>,</span> <span class=mh>0x24</span><span class=p>,</span> <span class=mh>0xd3</span><span class=p>,</span> <span class=mh>0xb9</span><span class=p>,</span> <span class=mh>0xac</span><span class=p>,</span> <span class=mh>0xe6</span><span class=p>,</span> <span class=mh>0xec</span><span class=p>,</span> <span class=mh>0xac</span><span class=p>,</span> <span class=mh>0xac</span><span class=p>,</span> <span class=mh>0x55</span><span class=p>,</span> <span class=mh>0xfd</span><span class=p>,</span> <span class=mh>0x49</span><span class=p>,</span> <span class=mh>0xaf</span><span class=p>,</span> <span class=mh>0x5d</span><span class=p>,</span> <span class=mh>0xaa</span><span class=p>,</span> <span class=mh>0x44</span><span class=p>,</span> <span class=mh>0x4f</span><span class=p>,</span> <span class=mh>0x8f</span><span class=p>,</span> <span class=mh>0x3e</span><span class=p>,</span> <span class=mh>0x7d</span><span class=p>,</span> <span class=mh>0xf5</span><span class=p>,</span> <span class=mh>0xf2</span><span class=p>,</span> <span class=mh>0xa7</span> <span class=p>]</span>
</span></span></code></pre></div><p>que je xor par 0x15 afin d&rsquo;obtenir le hash suivant :</p><pre tabindex=0><code>f60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2
</code></pre><p>Nous savons que notre code PIN à une taille de 6 caractère et nous avons &ldquo;0123456&rdquo; comme set de caractère. On pourra donc très facilement casser ce mot de passe.</p><p>Pour ce faire j&rsquo;ai utilisé <a href=https://hashcat.net/hashcat/>hashcat</a> :</p><pre tabindex=0><code>.\hashcat.exe -m 1700 -a 3 f60b397423a8bdd546e5e150849d1eb2932c20cda6dc6f29dfcac8d7a67d82fd7902c282750f29cfb3ad31c6acb9f3f9b9b940e85cba48bf515a9a2b68e0e7b2 ?d?d?d?d?d?d
</code></pre><p>Et nous obtenons un code pin qui est <code>413372</code> !!</p><p>On peut donc maintenant l&rsquo;essayer dans notre émulateur et obtenir le flag.</p><p><img loading=lazy src=/img/posts/fcsc2023-sensor-watch/flag.png alt=flag></p><p>Le flag est donc <code>FCSC413372</code> !</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>C&rsquo;était la première fois que je reversais un firmware et malgré beaucoup de difficultés au début j&rsquo;ai apprécié ce challenge. Si je devais en retenir quelque chose ce serait prendre le temps de comprendre le firmware afin de configurer correctement son désassembleur. J&rsquo;ai en effet l&rsquo;habitude de reverse des binaires très communs tels que des ELF, PE, etc. qui sont très bien pris en charges par les désassembleurs. Ce fut un challenge très enrichissant, un grand merci aux créateurs.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://trikkss.github.io/tags/reverse-engineering/>Reverse Engineering</a></li><li><a href=https://trikkss.github.io/tags/firmware/>Firmware</a></li><li><a href=https://trikkss.github.io/tags/arm/>ARM</a></li></ul><nav class=paginav><a class=prev href=https://trikkss.github.io/posts/fcsc2023_chaussette-xs/><span class=title>« Prev</span><br><span>FCSC 2023 - chaussette (XS)</span>
</a><a class=next href=https://trikkss.github.io/posts/iat_hooking/><span class=title>Next »</span><br><span>Malware - IAT Hooking</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://trikkss.github.io/>TRIKKSS Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>