<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FCSC 2024 - TV Hacks 1/2 | TRIKKSS Blog</title><meta name=keywords content="Reverse engineering,Linux,Kernel,Qemu,Emulation"><meta name=description content="Write up du challenge TV Hacks 1/2"><meta name=author content="TRIKKSS"><link rel=canonical href=https://trikkss.github.io/posts/fcsc2024_tv-hacks1/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=16x16 href=https://trikkss.github.io/img/pfp.png><link rel=icon type=image/png sizes=32x32 href=https://trikkss.github.io/img/pfp.png><link rel=apple-touch-icon href=https://trikkss.github.io/img/pfp.png><link rel=mask-icon href=https://trikkss.github.io/img/pfp.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="FCSC 2024 - TV Hacks 1/2"><meta property="og:description" content="Write up du challenge TV Hacks 1/2"><meta property="og:type" content="article"><meta property="og:url" content="https://trikkss.github.io/posts/fcsc2024_tv-hacks1/"><meta property="og:image" content="https://trikkss.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-15T00:00:00+00:00"><meta property="og:site_name" content="TRIKKSS Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trikkss.github.io/img/pfp.png"><meta name=twitter:title content="FCSC 2024 - TV Hacks 1/2"><meta name=twitter:description content="Write up du challenge TV Hacks 1/2"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://trikkss.github.io/posts/"},{"@type":"ListItem","position":2,"name":"FCSC 2024 - TV Hacks 1/2","item":"https://trikkss.github.io/posts/fcsc2024_tv-hacks1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FCSC 2024 - TV Hacks 1/2","name":"FCSC 2024 - TV Hacks 1\/2","description":"Write up du challenge TV Hacks 1/2","keywords":["Reverse engineering","Linux","Kernel","Qemu","Emulation"],"articleBody":"Contexte Le SOC de la chaîne de télévision TV Hacks a remarqué des paquets NTP étranges passant leur pare-feu dans le sillage de paquets légitimes. Ces messages sont à destination de l’équipement responsable de la génération des flux télévisuels pour la TNT.\nUne analyse de la machine n’a pas permis de trouver quoi que ce soit de suspect à part un module noyau Linux qui semble servir à l’optimisation des flux IP à destination de notre diffuseur.\nCe module et un extrait de capture réseau vous sont fournis pour une première analyse.\nL’équipement ne peut être arrêté sous aucun prétexte : cela signifierait un écran noir pour tous les téléspectateurs ! Si vous pouviez comprendre ce que fait l’attaquant, nous pourrons peut-être éviter un drame national.\nNous avons donc un module kernel ainsi qu’une capture réseau contenant 6 trames NTP.\nvous pouvez retrouver les deux fichiers ici.\nDécouverte du module kernel après avoir récupéré le module kernel, nous pouvons utiliser la commande modinfoafin de lister les informations le concernant.\n╭─user@arch-vmware ~/shared/FCSC_2024/TV-HACKS-1 ╰─➤ modinfo ipopt.ko 127 ↵ filename: /home/user/shared/FCSC_2024/TV-HACKS-1/ipopt.ko description: IP optimizer author: Shenzhen NetSoft Technology Co., Ltd. license: GPL alias: acpi*:PNP0700:* alias: pnp:dPNP0700* depends: vermagic: 3.2.0-4-amd64 SMP mod_unload modversions le vermagic nous indique que ce module a été compilé pour un kernel 2.2.0-4-amd64.\nIl est donc nécessaire d’avoir la bonne version de notre kernel afin de pouvoir le lancer.\nJ’ai pour ma part d’abord commencé par lire le code statique, mais ma solution ne fonctionnait pas. N’ayant pas confiance en mes capacitées de compréhension de code j’ai donc décidé d’émuler le binaire afin de vérifier mes incertitudes. J’ai néanmoins appris énormément de choses grâce à ça.\nEmulation du binaire Afin de pouvoir débugger le kernel de notre debian nous allons émuler notre VM à l’aide de qemu. Pour ça nous récupèrons un ISO de debian possèdant le kernel 2.2.0-4-amd64 et nous procédons à l’installation.\nqemu-img create debian.img 20G qemu-system-x86_64 -hda debian.img -cdrom debian-7.11.0-amd64-kde-CD-1.iso -boot d -m 512 nous faisons ensuite une installation classique de Debian et enfin nous pouvons lancer notre vm.\nqemu-system-x86_64 -hda debian.img -m 512 j’ai également mis en place en network bridge afin de pouvoir envoyer des paquets NTP à ma VM (les paquets envoyés depuis la VM vers elle même à l’aide de scapy ne semblaient pas être intercepté par le module kernel.) Pour ça j’ai suivi ligne pour ligne cet article : https://www.spad.uk/posts/really-simple-network-bridging-with-qemu/\nvoici ma commande finale permettant de lancer ma VM\nqemu-system-x86_64 -hda debian.img -m 1024 -s -net nic,model=virtio,macaddr=52:54:00:00:00:01 -net bridge,br=virbr0 j’utilise l’option -s afin de pouvoir debugger le kernel en remote.\nDebuggage on charge le module kernel\ninsmod ipopt.ko on récupère son addresse en mémoire\ncat /proc/modules | grep ipopt puis dans gdb\ntarget remote :1234 # placer un breakpoint dans le module kernel b*module_base_addr + offset_from_disassembler afin de pouvoir effectuer mes tests sur le module kernel j’ai également utilisé scapy de la manière suivante :\ndata = \"donnees que je souhaite envoyer\" a = IP(dst=\"remote ip\")/UDP(dport=123, sport=1337)/Raw(load=data) send(a) Fonctionnement du binaire Analysons maintenant le code du module.\nLa fonction que j’ai renommer do_hmac_512() va effectuer un hmac_512 avec comme message la variable globale que j’ai renommée user_key et comme clé 32 octets contenus dans la variable globale unk_3310.\nuser_key contient 16 octets nul au début du programme.\nLe résultat de celle ci est stocké dans une variable globale hmac_output que nous utiliserons plus tard.\nEnsuite la fonction que j’ai appeler deobfuscate_function() va déobfusquer les éléments nécessaires à l’execution de commande bash. Nous ne nous y intéresseront pas.\nLe binaire va ensuite mettre un place des hook netfilter. Ces hooks vont permettre d’intercepter les trames entrantes et sortantes sur la machine afin de pouvoir les examiner, les modifiers, etc.\nla définition de cette fonction est la suivante :\nint nf_register_hooks(struct nf_hook_ops *reg, unsigned int n); Cette fonction prend en paramètre une liste de structure nf_hooks_op ainsi que le nombre d’éléments présents cette liste.\nstruct nf_hook_ops { struct list_head list; /* User fills in from here down. */ nf_hookfn\t*hook; struct module\t*owner; void\t*priv; u_int8_t\tpf; unsigned int\thooknum; /* Hooks are ordered in ascending priority. */ int\tpriority; }; Nous allons nous intéresser au premier élément dde notre strutcure hookqui est en réalité un pointeur vers la une fonction à executer.\nOn récupère donc 4 hooks netfilter que nous allons renommer tout simple hook1, hook2, hook3, hook4.\nLes deux premiers servent à filtrer le trafic entrant, les deux derniers servent à filtrer le trafic sortant sur la machine.\nAnalyse des paquets entrant Les deux premiers hooks semblent faire la même chose pour des types de paquets différents, ils vont d’abord parser notre paquet, vérifier que celui ci est un paquet NTP (verifie que le protocole soit UDP ainsi que le port source soit 123), vérifier que le début des données NTP commencent par fCsC avant d’envoyer ces données à une autre fonction.\nvoici le code décompilé et pas très propre car je n’avais pas la force de recréer les structures dans IDA. Néanmoins j’ai laissé des commentaires sur les parties importantes de celui ci.\nNous arrivons maintenant sur la partie intéressante.\nSi le paquet est de la forme souhaitée, le code va appeler deux fonctions et vérifier si celle-ci retournent 0.\nLa première fonction prend en paramètre :\nun pointeur vers les données NTP du paquet la taille de ces données - 16 une liste de 8 bytes la taille de celle ci un pointeur vers les 16 derniers bytes de nos données NTP la taille de ces 16 derniers bytes la seconde fonction va prendre en paramètre:\nun pointeur vers nos données NTP à l’offset 20 la taille de notre paquet - 36 un pointeur vers une variable que nous verrons plus tard un pointeur vers une liste de 8 bytes la taille de celle ci un pointeur vers les données contenu dans notre paquet NTP juste après le fCsC la taille des données. à partir de ces infos nous pouvons avoir une idée de la structure des paquets NTP envoyés.\nmagic number : 4 bytes (fCsC) data1 : 16 bytes data2 : n bytes data3 : 16 bytes Nous pouvons maintenant nous aventurer dans notre première fonction.\nJ’ai détaillé celle-ci en 5 points principaux :\nLe binaire va déobfusquer une chaine de caractère en mémoire correspondant à hmac(256) puis il va faire appel à la fonction crypto_alloc_shashavec comme argument notre chaine de caractère déchiffrée. Il va donc créer un “crypto handler” nous permettant par la suite d’hasher nos données. Le binaire utilise une obfuscation très simple sur les chaines de caractère, celle ci consiste à prendre la liste d’octets obfusqué 2 par 2 et appliquer un xor entre ces deux octets. Cette opération est réalisée par la fonction sub_23C0.\nv1 = [ 0xc1, 0xa9, 0xa6, 0xcb, 0xd5, 0xb4, 0x97, 0xf4, 0x6f, 0x47, 0xb8, 0xcb, 0x10, 0x78, 0xfd, 0x9c, 0x58, 0x6a, 0x98, 0xad, 0x13, 0x25, 0xe1, 0xc8, 0x77, 0x77 ] for i in range(0,len(v1),2): print(chr(v1[i] ^ v1[i+1]), end=\"\") print() # output : hmac(sha256) Il va ensuite faire appel à la fonction __________10() avec comme arguments les 8 bytes passé en paramètres, ainsi qu’un pointeur vers un buffer de 32 bytes. Nous reviendrons sur cette fonction (que j’aurai du renommer plus proprement) juste après. Garder en tête qu’elle génère la clé pour notre hmac 256.\nNous spécifions la clé à utiliser à notre crypto handler.\nNous effectuons un hmac256 de nos données NTP sans les 16 derniers bytes.\nEt enfin nous comparons le hash obtenu avec les 16 derniers bytes de nos données NTP.\nCette fonction fais donc une vérification d’intégritée sur les paquets NTP que le serveur reçoit.\nNous allons maintenant rapidemment détailler la fonction __________10()\nCelle-ci effectue … roulement de tambours … un hmac 256 !\nElle prend comme clé notre variable globale hmac_output que nous avons définie au début de notre analyse et en message la valeur passé en paramètre de la fonction + 1 byte à 1. (j’ai simplifié le fonctionnement de la fonction car le reste n’est pas utilisé dans notre cas, néanmoins le fonctionnement de celle ci est légérement différent si l’output demandé en paramètre est différent supérieur à 32.)\nce qui nous donne en python\nout = hmac.new( hmac_output, msg=p1 + (1).to_bytes(1, \"little\"), digestmod=hashlib.sha256 ).digest() Nous en avons maintenant fini avec cette première fonction. Nous pouvons maintenant nous attaquer à la deuxième fonction.\nPour rappel, les valeurs passées en paramètre à cette fonction sont nos données NTP à l’offset 20 (sans le magic byte et sans les 16 premiers bytes), la taille de ces données, un pointeur vers une chaine de 8 bytes, la taille de celle-ci, ainsi qu’un pointeur vers les 16 premiers octets de nos données et encore une fois leur taille.\nJ’ai encore une fois simplifié la fonction en 6 points principaux.\nIl vérifie que la taille des données est un multiple de 16.\nil va déobfusquer la chaine de caractère cbc(aes) et créer un crypto handler pour pouvoir déchiffrer de l’aes.\nil fait à nouveau appel à la fonction __________10() afin de lui générer une clé de 16 bytes avec les 8 bytes passé en argument.\nIl spécifie ensuite la clé à notre crypto handler.\nIl déchiffre enfin nos données passé en paramètre avec comme IV les 16 premiers octets de notre paquet NTP\nIl vérifie que le padding des données déchifrée est correct (il utilise le padding PKCS7)\nAfin d’identifier les fonctions permettant de spécifier la clé AES et chiffrer les données j’ai rechercher sur internet comment était effectué les chiffrements AES cbc dans le kernel. Les paramètres passé en paramètres de mes fonctions concordaient à celles présentes sur internet et grâce au débugger que j’ai mis en place j’ai pu confirmer ma théorie en verifiant les valeurs en sortie de fonction.\nSi nous récapitulons, nous avons des paquets de la forme suivante.\nA ce moment là je pensais que le challenge etait terminé, plus qu’a déchiffrer les données présentes dans le pcap … que nenni ! C’est que le début !\nInterprétation des données déchiffrée Une fois nos données déchiffrées, l’algorithme va vérifier si le premier byte de celui est à 0.\ns’il n’est pas nul, alors on va executer le code présent dans les données déchiffrée … seulement si la user_key n’est pas nul ! je n’avais pas fait gaffe à cette condition au début, c’était donc logique que je ne puisse pas déchiffrer les données.\nsi le premier byte est nul, alors les 16 prochains octets vont servir à définir une nouvelle clé stockée dans la variable user_key.\nL’utilisateur a donc forcément défini une clé avant de pouvoir envoyer ses payloads.\nGénération d’une nouvelle clé la génération de la clé est très simple, il va d’abord appliquer 3 opérations ET binaire sur chaque octet de la clé envoyé dans la trame NTP avant d’utiliser celle-ci dans la fonction do_hmac_sha512() que nous avons déjà vu au début. Pour rappel, cette fonction stocke le hash créé dans la variable globale hmac_output.\nVoici donc un schéma simplifié de notre chiffrement\nNotre clé est utilisée deux fois, pour chiffrer mais également pour générer le checksum.\nCasser le chiffrement La vulnérabilité de ce chiffrement réside dans les 3 ET binaire appliqué sur la clé donnée par l’utilisateur.\nEn effet, l’opération \u0026 fonctionne de la manière suivante :\n1 \u0026 1 = 1 0 \u0026 1 = 0 1 \u0026 0 = 0 0 \u0026 0 = 0 prenons un example :\nImaginons nous avons une clé sur 1 octet : 'A' -\u003e 01000001\nNous avons donc 8 bits à bruteforce pour trouver la bonne clé.\nMais si l’on applique un \u0026 avec la valeur 'F' -\u003e 01000110\nAlors les octets 1, 4, 5, 6 et 8 seront forcément à 0 et nous aurons seulement les valeurs 2, 3 et 7 à bruteforce.\nsi l’on applique un \u0026 une fois notre clé est affaiblie, alors imaginez 3 fois !\nNous allons donc bruteforce notre clé de 16 octets, pour chaque clé nous allons calculer la valeur du checksum avec celle-ci et comparer avec le checksum présent dans la trame NTP. Si le checksum calculé avec notre clé est égal à celui présent dans la trame alors nous aurons trouvé la bonne clé de chiffrement.\nVoici le script qui va nous permettre de casser la clé de chiffrement.\nimport binascii import hmac import hashlib from Crypto.Cipher import AES and_values = [0x2F, 0x4E, 0x2F, 0x66, 0xE4, 0x7F, 0x7A, 0x5E, 0xEB, 0xE5, 0xE7, 0x8C, 0xB2, 0x19, 0x1C, 0x36, 0xB7, 0xFB, 0x76, 0x0E, 0xAC, 0x28, 0x0C, 0xDE, 0xB7, 0xBF, 0x98, 0x69, 0x39, 0x7B, 0xFB, 0xFD, 0xE2, 0x76, 0xCB, 0xFE, 0x5D, 0xDF, 0x70, 0xC9, 0x8F, 0x54, 0x16, 0xAD, 0xFF, 0xF6, 0xB7, 0xCE] hmac_key = [0x15, 0xba, 0x94, 0x08, 0x48, 0x6e, 0x0d, 0xa2, 0x6d, 0x67, 0xe9, 0x7b, 0xc5, 0x56, 0x2c, 0xd2, 0x2e, 0x58, 0xa7, 0x4d, 0x05, 0x32, 0xa2, 0x26, 0x21, 0x8a, 0x35, 0xfe, 0x35, 0x59, 0x99, 0x54] # la trame NTP paquet = binascii.unhexlify(\"6643734364bda3c196d86f172737afdc409cdb3d675995e6524e17b50f16b0de154404f0df3c0b5f62193b759965e7f6d76cb38ac475d9c91e16217376fd97b33e09228ee738ecdf0b7ee2c1001f42f8700c1125683750d77825417142069c0a849d5c7fd44e54e43b49365cd1569304667a4dc702a6155f84ad155ee5fa21623bce226fa3b3f1e18dbd2da64253d9e0e1054ee8\") # les 8 octets utilisé pour générer la clé du hmac ainsi que la clé AES p1 = binascii.unhexlify(\"A612E61640B3218E\") p2 = binascii.unhexlify(\"192C98524983EAB4\") IV = paquet[4:4+16] ciphertext = paquet[4+16:-16] checksum = paquet[-16:] partial_key = \"\" # on récupère les \u0026 finaux afin de connaitre les bits qui seront à 0 for i in range(16): x = f\"{and_values[i] \u0026 and_values[i+16] \u0026 and_values[i+32]:08b}\" partial_key += x # on compte le nombre de bits à bruteforce n = partial_key.count(\"1\") values = [i for i in partial_key] # on bruteforce jusqu'a ce que le checksum soit le même. for i in range(0, 2**n): v = f\"{i:021b}\" partial_test = values.copy() k = 0 for j in range(len(partial_test)): if partial_test[j] == \"1\": partial_test[j] = v[k] k += 1 partial_key_test = int(\"\".join(partial_test), 2).to_bytes(16, \"big\") key2 = hmac.new( bytes(hmac_key), msg=bytes(partial_key_test), digestmod=hashlib.sha256 ).digest() out = hmac.new( key2, msg=p1 + (1).to_bytes(1, \"little\"), digestmod=hashlib.sha256 ).digest() final_key = hmac.new( out, msg=paquet[:-16], digestmod=hashlib.sha256 ).digest() if final_key[:16] == checksum: break # on calcule la clé de chiffrement AES out = hmac.new( bytes(key2), msg=p2 + (1).to_bytes(1, \"little\"), digestmod=hashlib.sha256 ).digest() # on déchiffre les données. decipher = AES.new(out[:16],AES.MODE_CBC, IV) plaintext = decipher.decrypt(ciphertext) print(plaintext) Après quelques minutes on récupère une joli commande bash avec le flag présent à l’intérieur :)\n╭─user@arch-vmware ~/shared/FCSC_2024/TV-HACKS-1 ╰─➤ python3 bruteforce_bits.py 1 ↵ b'/bin/sh\\x00-c\\x00echo \"FCSC{5d58e776e659866d110ac50dc2bce631e634222953a234893cb4978594ec0ae1}\" \u003e /root/flag1\\x00\\x00\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08' ","wordCount":"2358","inLanguage":"en","datePublished":"2024-04-15T00:00:00Z","dateModified":"2024-04-15T00:00:00Z","author":{"@type":"Person","name":"TRIKKSS"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://trikkss.github.io/posts/fcsc2024_tv-hacks1/"},"publisher":{"@type":"Organization","name":"TRIKKSS Blog","logo":{"@type":"ImageObject","url":"https://trikkss.github.io/img/pfp.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://trikkss.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://trikkss.github.io/img/pfp.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://trikkss.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://trikkss.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://trikkss.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://trikkss.github.io/posts/>Posts</a></div><h1 class=post-title>FCSC 2024 - TV Hacks 1/2</h1><div class=post-meta><span title='2024-04-15 00:00:00 +0000 UTC'>April 15, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2358 words&nbsp;·&nbsp;TRIKKSS</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#contexte>Contexte</a></li><li><a href=#découverte-du-module-kernel>Découverte du module kernel</a></li><li><a href=#emulation-du-binaire>Emulation du binaire</a></li><li><a href=#debuggage>Debuggage</a></li><li><a href=#fonctionnement-du-binaire>Fonctionnement du binaire</a></li><li><a href=#analyse-des-paquets-entrant>Analyse des paquets entrant</a></li><li><a href=#interprétation-des-données-déchiffrée>Interprétation des données déchiffrée</a></li><li><a href=#génération-dune-nouvelle-clé>Génération d&rsquo;une nouvelle clé</a></li><li><a href=#casser-le-chiffrement>Casser le chiffrement</a></li></ul></nav></div></details></div><div class=post-content><h2 id=contexte>Contexte<a hidden class=anchor aria-hidden=true href=#contexte>#</a></h2><p><em>Le SOC de la chaîne de télévision TV Hacks a remarqué des paquets NTP étranges passant leur pare-feu dans le sillage de paquets légitimes. Ces messages sont à destination de l&rsquo;équipement responsable de la génération des flux télévisuels pour la TNT.</em></p><p><em>Une analyse de la machine n&rsquo;a pas permis de trouver quoi que ce soit de suspect à part un module noyau Linux qui semble servir à l&rsquo;optimisation des flux IP à destination de notre diffuseur.</em></p><p><em>Ce module et un extrait de capture réseau vous sont fournis pour une première analyse.</em></p><p><em>L&rsquo;équipement ne peut être arrêté sous aucun prétexte : cela signifierait un écran noir pour tous les téléspectateurs ! Si vous pouviez comprendre ce que fait l&rsquo;attaquant, nous pourrons peut-être éviter un drame national.</em></p><p>Nous avons donc un module kernel ainsi qu&rsquo;une capture réseau contenant 6 trames NTP.</p><p><em>vous pouvez retrouver les deux fichiers <a href=/static/chaussette-xs>ici</a></em>.</p><h2 id=découverte-du-module-kernel>Découverte du module kernel<a hidden class=anchor aria-hidden=true href=#découverte-du-module-kernel>#</a></h2><p>après avoir récupéré le module kernel, nous pouvons utiliser la commande <code>modinfo</code>afin de lister les informations le concernant.</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/FCSC_2024/TV-HACKS-1
╰─➤  modinfo ipopt.ko                         127 ↵
filename:       /home/user/shared/FCSC_2024/TV-HACKS-1/ipopt.ko
description:    IP optimizer
author:         Shenzhen NetSoft Technology Co., Ltd.
license:        GPL
alias:          acpi*:PNP0700:*
alias:          pnp:dPNP0700*
depends:
vermagic:       3.2.0-4-amd64 SMP mod_unload modversions
</code></pre><p>le vermagic nous indique que ce module a été compilé pour un kernel 2.2.0-4-amd64.</p><p>Il est donc nécessaire d&rsquo;avoir la bonne version de notre kernel afin de pouvoir le lancer.</p><p><em>J&rsquo;ai pour ma part d&rsquo;abord commencé par lire le code statique, mais ma solution ne fonctionnait pas. N&rsquo;ayant pas confiance en mes capacitées de compréhension de code j&rsquo;ai donc décidé d&rsquo;émuler le binaire afin de vérifier mes incertitudes. J&rsquo;ai néanmoins appris énormément de choses grâce à ça.</em></p><h2 id=emulation-du-binaire>Emulation du binaire<a hidden class=anchor aria-hidden=true href=#emulation-du-binaire>#</a></h2><p>Afin de pouvoir débugger le kernel de notre debian nous allons émuler notre VM à l&rsquo;aide de qemu. Pour ça nous récupèrons <a href=https://cdimage.debian.org/cdimage/archive/7.11.0/amd64/iso-cd/>un ISO de debian possèdant le kernel 2.2.0-4-amd64</a> et nous procédons à l&rsquo;installation.</p><pre tabindex=0><code>qemu-img create debian.img 20G
qemu-system-x86_64 -hda debian.img -cdrom debian-7.11.0-amd64-kde-CD-1.iso -boot d -m 512
</code></pre><p>nous faisons ensuite une installation classique de Debian et enfin nous pouvons lancer notre vm.</p><pre tabindex=0><code>qemu-system-x86_64 -hda debian.img -m 512
</code></pre><p>j&rsquo;ai également mis en place en network bridge afin de pouvoir envoyer des paquets NTP à ma VM (les paquets envoyés depuis la VM vers elle même à l&rsquo;aide de scapy ne semblaient pas être intercepté par le module kernel.)
Pour ça j&rsquo;ai suivi ligne pour ligne cet article : <a href=https://www.spad.uk/posts/really-simple-network-bridging-with-qemu/>https://www.spad.uk/posts/really-simple-network-bridging-with-qemu/</a></p><p>voici ma commande finale permettant de lancer ma VM</p><pre tabindex=0><code>qemu-system-x86_64 -hda debian.img -m 1024 -s -net nic,model=virtio,macaddr=52:54:00:00:00:01 -net bridge,br=virbr0
</code></pre><p>j&rsquo;utilise l&rsquo;option <code>-s</code> afin de pouvoir debugger le kernel en remote.</p><h2 id=debuggage>Debuggage<a hidden class=anchor aria-hidden=true href=#debuggage>#</a></h2><p>on charge le module kernel</p><pre tabindex=0><code>insmod ipopt.ko
</code></pre><p>on récupère son addresse en mémoire</p><pre tabindex=0><code>cat /proc/modules | grep ipopt
</code></pre><p>puis dans gdb</p><pre tabindex=0><code>target remote :1234
# placer un breakpoint dans le module kernel
b*module_base_addr + offset_from_disassembler
</code></pre><p>afin de pouvoir effectuer mes tests sur le module kernel j&rsquo;ai également utilisé scapy de la manière suivante :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=s2>&#34;donnees que je souhaite envoyer&#34;</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>IP</span><span class=p>(</span><span class=n>dst</span><span class=o>=</span><span class=s2>&#34;remote ip&#34;</span><span class=p>)</span><span class=o>/</span><span class=n>UDP</span><span class=p>(</span><span class=n>dport</span><span class=o>=</span><span class=mi>123</span><span class=p>,</span> <span class=n>sport</span><span class=o>=</span><span class=mi>1337</span><span class=p>)</span><span class=o>/</span><span class=n>Raw</span><span class=p>(</span><span class=n>load</span><span class=o>=</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=fonctionnement-du-binaire>Fonctionnement du binaire<a hidden class=anchor aria-hidden=true href=#fonctionnement-du-binaire>#</a></h2><p>Analysons maintenant le code du module.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/nf_register_hooks.png alt></p><p>La fonction que j&rsquo;ai renommer <code>do_hmac_512()</code> va effectuer un hmac_512 avec comme message la variable globale que j&rsquo;ai renommée <code>user_key</code> et comme clé 32 octets contenus dans la variable globale <code>unk_3310</code>.</p><p><code>user_key</code> contient 16 octets nul au début du programme.</p><p>Le résultat de celle ci est stocké dans une variable globale <code>hmac_output</code> que nous utiliserons plus tard.</p><p>Ensuite la fonction que j&rsquo;ai appeler <code>deobfuscate_function()</code> va déobfusquer les éléments nécessaires à l&rsquo;execution de commande bash. Nous ne nous y intéresseront pas.</p><p>Le binaire va ensuite mettre un place des hook netfilter. Ces hooks vont permettre d&rsquo;intercepter les trames entrantes et sortantes sur la machine afin de pouvoir les examiner, les modifiers, etc.</p><p>la définition de cette fonction est la suivante :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>nf_register_hooks</span><span class=p>(</span><span class=k>struct</span> <span class=n>nf_hook_ops</span> <span class=o>*</span><span class=n>reg</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>n</span><span class=p>);</span>
</span></span></code></pre></div><p>Cette fonction prend en paramètre une liste de structure <code>nf_hooks_op</code> ainsi que le nombre d&rsquo;éléments présents cette liste.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>nf_hook_ops</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* User fills in from here down. */</span>
</span></span><span class=line><span class=cl>	<span class=n>nf_hookfn</span>	<span class=o>*</span><span class=n>hook</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>module</span>	<span class=o>*</span><span class=n>owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span>		<span class=o>*</span><span class=n>priv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>u_int8_t</span>	<span class=n>pf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span>	<span class=n>hooknum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* Hooks are ordered in ascending priority. */</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span>		<span class=n>priority</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Nous allons nous intéresser au premier élément dde notre strutcure <code>hook</code>qui est en réalité un pointeur vers la une fonction à executer.</p><p>On récupère donc 4 hooks netfilter que nous allons renommer tout simple <code>hook1</code>, <code>hook2</code>, <code>hook3</code>, <code>hook4</code>.</p><p>Les deux premiers servent à filtrer le trafic entrant, les deux derniers servent à filtrer le trafic sortant sur la machine.</p><h2 id=analyse-des-paquets-entrant>Analyse des paquets entrant<a hidden class=anchor aria-hidden=true href=#analyse-des-paquets-entrant>#</a></h2><p>Les deux premiers hooks semblent faire la même chose pour des types de paquets différents, ils vont d&rsquo;abord parser notre paquet, vérifier que celui ci est un paquet NTP (verifie que le protocole soit UDP ainsi que le port source soit 123), vérifier que le début des données NTP commencent par <code>fCsC</code> avant d&rsquo;envoyer ces données à une autre fonction.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/hook_1.png alt></p><p>voici le code décompilé et pas très propre car je n&rsquo;avais pas la force de recréer les structures dans IDA.
Néanmoins j&rsquo;ai laissé des commentaires sur les parties importantes de celui ci.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/meme_struct.jpg alt></p><p>Nous arrivons maintenant sur la partie intéressante.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/check_ntp_packet.png alt></p><p>Si le paquet est de la forme souhaitée, le code va appeler deux fonctions et vérifier si celle-ci retournent 0.</p><p>La première fonction prend en paramètre :</p><ul><li>un pointeur vers les données NTP du paquet</li><li>la taille de ces données - 16</li><li>une liste de 8 bytes</li><li>la taille de celle ci</li><li>un pointeur vers les 16 derniers bytes de nos données NTP</li><li>la taille de ces 16 derniers bytes</li></ul><p>la seconde fonction va prendre en paramètre:</p><ul><li>un pointeur vers nos données NTP à l&rsquo;offset 20</li><li>la taille de notre paquet - 36</li><li>un pointeur vers une variable que nous verrons plus tard</li><li>un pointeur vers une liste de 8 bytes</li><li>la taille de celle ci</li><li>un pointeur vers les données contenu dans notre paquet NTP juste après le <code>fCsC</code></li><li>la taille des données.</li></ul><p>à partir de ces infos nous pouvons avoir une idée de la structure des paquets NTP envoyés.</p><pre tabindex=0><code>magic number : 4 bytes (fCsC)
data1 : 16 bytes
data2 : n bytes
data3 : 16 bytes
</code></pre><p>Nous pouvons maintenant nous aventurer dans notre première fonction.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/check_integrity.png alt></p><p>J&rsquo;ai détaillé celle-ci en 5 points principaux :</p><ol><li>Le binaire va déobfusquer une chaine de caractère en mémoire correspondant à <code>hmac(256)</code> puis il va faire appel à la fonction <code>crypto_alloc_shash</code>avec comme argument notre chaine de caractère déchiffrée.
Il va donc créer un &ldquo;crypto handler&rdquo; nous permettant par la suite d&rsquo;hasher nos données.</li></ol><p><em>Le binaire utilise une obfuscation très simple sur les chaines de caractère, celle ci consiste à prendre la liste d&rsquo;octets obfusqué 2 par 2 et appliquer un xor entre ces deux octets. Cette opération est réalisée par la fonction <code>sub_23C0</code>.</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>v1</span> <span class=o>=</span> <span class=p>[</span> <span class=mh>0xc1</span><span class=p>,</span> <span class=mh>0xa9</span><span class=p>,</span> <span class=mh>0xa6</span><span class=p>,</span> <span class=mh>0xcb</span><span class=p>,</span> <span class=mh>0xd5</span><span class=p>,</span> <span class=mh>0xb4</span><span class=p>,</span> <span class=mh>0x97</span><span class=p>,</span> <span class=mh>0xf4</span><span class=p>,</span> <span class=mh>0x6f</span><span class=p>,</span> <span class=mh>0x47</span><span class=p>,</span> <span class=mh>0xb8</span><span class=p>,</span> <span class=mh>0xcb</span><span class=p>,</span> <span class=mh>0x10</span><span class=p>,</span> <span class=mh>0x78</span><span class=p>,</span> <span class=mh>0xfd</span><span class=p>,</span> <span class=mh>0x9c</span><span class=p>,</span> <span class=mh>0x58</span><span class=p>,</span> <span class=mh>0x6a</span><span class=p>,</span> <span class=mh>0x98</span><span class=p>,</span> <span class=mh>0xad</span><span class=p>,</span> <span class=mh>0x13</span><span class=p>,</span> <span class=mh>0x25</span><span class=p>,</span> <span class=mh>0xe1</span><span class=p>,</span> <span class=mh>0xc8</span><span class=p>,</span> <span class=mh>0x77</span><span class=p>,</span> <span class=mh>0x77</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=n>v1</span><span class=p>),</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=nb>chr</span><span class=p>(</span><span class=n>v1</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>^</span> <span class=n>v1</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]),</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># output : hmac(sha256)</span>
</span></span></code></pre></div><ol start=2><li><p>Il va ensuite faire appel à la fonction <code>__________10()</code> avec comme arguments les 8 bytes passé en paramètres, ainsi qu&rsquo;un pointeur vers un buffer de 32 bytes. Nous reviendrons sur cette fonction (que j&rsquo;aurai du renommer plus proprement) juste après. Garder en tête qu&rsquo;elle génère la clé pour notre hmac 256.</p></li><li><p>Nous spécifions la clé à utiliser à notre crypto handler.</p></li><li><p>Nous effectuons un hmac256 de nos données NTP sans les 16 derniers bytes.</p></li><li><p>Et enfin nous comparons le hash obtenu avec les 16 derniers bytes de nos données NTP.</p></li></ol><p>Cette fonction fais donc une vérification d&rsquo;intégritée sur les paquets NTP que le serveur reçoit.</p><p>Nous allons maintenant rapidemment détailler la fonction <code>__________10()</code></p><p>Celle-ci effectue &mldr; <em>roulement de tambours &mldr;</em> un hmac 256 !</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/meme_hmac.jpeg alt></p><p>Elle prend comme clé notre variable globale <code>hmac_output</code> que nous avons définie au début de notre analyse et en message la valeur passé en paramètre de la fonction + 1 byte à 1. (j&rsquo;ai simplifié le fonctionnement de la fonction car le reste n&rsquo;est pas utilisé dans notre cas, néanmoins le fonctionnement de celle ci est légérement différent si l&rsquo;output demandé en paramètre est différent supérieur à 32.)</p><p>ce qui nous donne en python</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>out</span> <span class=o>=</span> <span class=n>hmac</span><span class=o>.</span><span class=n>new</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>hmac_output</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>msg</span><span class=o>=</span><span class=n>p1</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;little&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>digestmod</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span>
</span></span><span class=line><span class=cl><span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span>
</span></span></code></pre></div><p>Nous en avons maintenant fini avec cette première fonction. Nous pouvons maintenant nous attaquer à la deuxième fonction.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/aes_cbc.png alt></p><p><em>Pour rappel, les valeurs passées en paramètre à cette fonction sont nos données NTP à l&rsquo;offset 20 (sans le magic byte et sans les 16 premiers bytes), la taille de ces données, un pointeur vers une chaine de 8 bytes, la taille de celle-ci, ainsi qu&rsquo;un pointeur vers les 16 premiers octets de nos données et encore une fois leur taille.</em></p><p>J&rsquo;ai encore une fois simplifié la fonction en 6 points principaux.</p><ol><li><p>Il vérifie que la taille des données est un multiple de 16.</p></li><li><p>il va déobfusquer la chaine de caractère <code>cbc(aes)</code> et créer un crypto handler pour pouvoir déchiffrer de l&rsquo;aes.</p></li><li><p>il fait à nouveau appel à la fonction <code>__________10()</code> afin de lui générer une clé de 16 bytes avec les 8 bytes passé en argument.</p></li><li><p>Il spécifie ensuite la clé à notre crypto handler.</p></li><li><p>Il déchiffre enfin nos données passé en paramètre avec comme IV les 16 premiers octets de notre paquet NTP</p></li><li><p>Il vérifie que le padding des données déchifrée est correct (il utilise le padding PKCS7)</p></li></ol><p><em>Afin d&rsquo;identifier les fonctions permettant de spécifier la clé AES et chiffrer les données j&rsquo;ai rechercher sur internet comment était effectué les chiffrements AES cbc dans le kernel. Les paramètres passé en paramètres de mes fonctions concordaient à celles présentes sur internet et grâce au débugger que j&rsquo;ai mis en place j&rsquo;ai pu confirmer ma théorie en verifiant les valeurs en sortie de fonction.</em></p><p>Si nous récapitulons, nous avons des paquets de la forme suivante.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/format_paquets.png alt></p><p><em>A ce moment là je pensais que le challenge etait terminé, plus qu&rsquo;a déchiffrer les données présentes dans le pcap &mldr; que nenni ! C&rsquo;est que le début !</em></p><h2 id=interprétation-des-données-déchiffrée>Interprétation des données déchiffrée<a hidden class=anchor aria-hidden=true href=#interprétation-des-données-déchiffrée>#</a></h2><p>Une fois nos données déchiffrées, l&rsquo;algorithme va vérifier si le premier byte de celui est à 0.</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/change_key.png alt></p><p>s&rsquo;il n&rsquo;est pas nul, alors on va executer le code présent dans les données déchiffrée &mldr; seulement si la <code>user_key</code> n&rsquo;est pas nul ! <em>je n&rsquo;avais pas fait gaffe à cette condition au début, c&rsquo;était donc logique que je ne puisse pas déchiffrer les données.</em></p><p>si le premier byte est nul, alors les 16 prochains octets vont servir à définir une nouvelle clé stockée dans la variable <code>user_key</code>.</p><p>L&rsquo;utilisateur a donc forcément défini une clé avant de pouvoir envoyer ses payloads.</p><h2 id=génération-dune-nouvelle-clé>Génération d&rsquo;une nouvelle clé<a hidden class=anchor aria-hidden=true href=#génération-dune-nouvelle-clé>#</a></h2><p>la génération de la clé est très simple, il va d&rsquo;abord appliquer 3 opérations <code>ET</code> binaire sur chaque octet de la clé envoyé dans la trame NTP avant d&rsquo;utiliser celle-ci dans la fonction <code>do_hmac_sha512()</code> que nous avons déjà vu au début.
Pour rappel, cette fonction stocke le hash créé dans la variable globale <code>hmac_output</code>.</p><p>Voici donc un schéma simplifié de notre chiffrement</p><p><img loading=lazy src=/img/posts/fcsc2024-tv-hacks1/chiffrement.png alt></p><p>Notre clé est utilisée deux fois, pour chiffrer mais également pour générer le checksum.</p><h2 id=casser-le-chiffrement>Casser le chiffrement<a hidden class=anchor aria-hidden=true href=#casser-le-chiffrement>#</a></h2><p>La vulnérabilité de ce chiffrement réside dans les 3 <code>ET</code> binaire appliqué sur la clé donnée par l&rsquo;utilisateur.</p><p>En effet, l&rsquo;opération <code>&</code> fonctionne de la manière suivante :</p><pre tabindex=0><code>1 &amp; 1 = 1
0 &amp; 1 = 0
1 &amp; 0 = 0
0 &amp; 0 = 0
</code></pre><p>prenons un example :</p><p>Imaginons nous avons une clé sur 1 octet : <code>'A'</code> -> <code>01000001</code></p><p>Nous avons donc 8 bits à bruteforce pour trouver la bonne clé.</p><p>Mais si l&rsquo;on applique un <code>&</code> avec la valeur <code>'F'</code> -> <code>01000110</code></p><p>Alors les octets 1, 4, 5, 6 et 8 seront forcément à 0 et nous aurons seulement les valeurs 2, 3 et 7 à bruteforce.</p><p>si l&rsquo;on applique un <code>&</code> une fois notre clé est affaiblie, alors imaginez 3 fois !</p><p>Nous allons donc bruteforce notre clé de 16 octets, pour chaque clé nous allons calculer la valeur du checksum avec celle-ci et comparer avec le checksum présent dans la trame NTP. Si le checksum calculé avec notre clé est égal à celui présent dans la trame alors nous aurons trouvé la bonne clé de chiffrement.</p><p>Voici le script qui va nous permettre de casser la clé de chiffrement.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>binascii</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>hmac</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>hashlib</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>Crypto.Cipher</span> <span class=kn>import</span> <span class=n>AES</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>and_values</span> <span class=o>=</span> <span class=p>[</span><span class=mh>0x2F</span><span class=p>,</span> <span class=mh>0x4E</span><span class=p>,</span> <span class=mh>0x2F</span><span class=p>,</span> <span class=mh>0x66</span><span class=p>,</span> <span class=mh>0xE4</span><span class=p>,</span> <span class=mh>0x7F</span><span class=p>,</span> <span class=mh>0x7A</span><span class=p>,</span> <span class=mh>0x5E</span><span class=p>,</span> <span class=mh>0xEB</span><span class=p>,</span> <span class=mh>0xE5</span><span class=p>,</span> <span class=mh>0xE7</span><span class=p>,</span> <span class=mh>0x8C</span><span class=p>,</span> <span class=mh>0xB2</span><span class=p>,</span> <span class=mh>0x19</span><span class=p>,</span> <span class=mh>0x1C</span><span class=p>,</span> <span class=mh>0x36</span><span class=p>,</span> <span class=mh>0xB7</span><span class=p>,</span> <span class=mh>0xFB</span><span class=p>,</span> <span class=mh>0x76</span><span class=p>,</span> <span class=mh>0x0E</span><span class=p>,</span> <span class=mh>0xAC</span><span class=p>,</span> <span class=mh>0x28</span><span class=p>,</span> <span class=mh>0x0C</span><span class=p>,</span> <span class=mh>0xDE</span><span class=p>,</span> <span class=mh>0xB7</span><span class=p>,</span> <span class=mh>0xBF</span><span class=p>,</span> <span class=mh>0x98</span><span class=p>,</span> <span class=mh>0x69</span><span class=p>,</span> <span class=mh>0x39</span><span class=p>,</span> <span class=mh>0x7B</span><span class=p>,</span> <span class=mh>0xFB</span><span class=p>,</span> <span class=mh>0xFD</span><span class=p>,</span> <span class=mh>0xE2</span><span class=p>,</span> <span class=mh>0x76</span><span class=p>,</span> <span class=mh>0xCB</span><span class=p>,</span> <span class=mh>0xFE</span><span class=p>,</span> <span class=mh>0x5D</span><span class=p>,</span> <span class=mh>0xDF</span><span class=p>,</span> <span class=mh>0x70</span><span class=p>,</span> <span class=mh>0xC9</span><span class=p>,</span> <span class=mh>0x8F</span><span class=p>,</span> <span class=mh>0x54</span><span class=p>,</span> <span class=mh>0x16</span><span class=p>,</span> <span class=mh>0xAD</span><span class=p>,</span> <span class=mh>0xFF</span><span class=p>,</span> <span class=mh>0xF6</span><span class=p>,</span> <span class=mh>0xB7</span><span class=p>,</span> <span class=mh>0xCE</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>hmac_key</span> <span class=o>=</span> <span class=p>[</span><span class=mh>0x15</span><span class=p>,</span> <span class=mh>0xba</span><span class=p>,</span> <span class=mh>0x94</span><span class=p>,</span> <span class=mh>0x08</span><span class=p>,</span> <span class=mh>0x48</span><span class=p>,</span> <span class=mh>0x6e</span><span class=p>,</span> <span class=mh>0x0d</span><span class=p>,</span> <span class=mh>0xa2</span><span class=p>,</span> <span class=mh>0x6d</span><span class=p>,</span> <span class=mh>0x67</span><span class=p>,</span> <span class=mh>0xe9</span><span class=p>,</span> <span class=mh>0x7b</span><span class=p>,</span> <span class=mh>0xc5</span><span class=p>,</span> <span class=mh>0x56</span><span class=p>,</span> <span class=mh>0x2c</span><span class=p>,</span> <span class=mh>0xd2</span><span class=p>,</span> <span class=mh>0x2e</span><span class=p>,</span> <span class=mh>0x58</span><span class=p>,</span> <span class=mh>0xa7</span><span class=p>,</span> <span class=mh>0x4d</span><span class=p>,</span> <span class=mh>0x05</span><span class=p>,</span> <span class=mh>0x32</span><span class=p>,</span> <span class=mh>0xa2</span><span class=p>,</span> <span class=mh>0x26</span><span class=p>,</span> <span class=mh>0x21</span><span class=p>,</span> <span class=mh>0x8a</span><span class=p>,</span> <span class=mh>0x35</span><span class=p>,</span> <span class=mh>0xfe</span><span class=p>,</span> <span class=mh>0x35</span><span class=p>,</span> <span class=mh>0x59</span><span class=p>,</span> <span class=mh>0x99</span><span class=p>,</span> <span class=mh>0x54</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># la trame NTP</span>
</span></span><span class=line><span class=cl><span class=n>paquet</span> <span class=o>=</span> <span class=n>binascii</span><span class=o>.</span><span class=n>unhexlify</span><span class=p>(</span><span class=s2>&#34;6643734364bda3c196d86f172737afdc409cdb3d675995e6524e17b50f16b0de154404f0df3c0b5f62193b759965e7f6d76cb38ac475d9c91e16217376fd97b33e09228ee738ecdf0b7ee2c1001f42f8700c1125683750d77825417142069c0a849d5c7fd44e54e43b49365cd1569304667a4dc702a6155f84ad155ee5fa21623bce226fa3b3f1e18dbd2da64253d9e0e1054ee8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># les 8 octets utilisé pour générer la clé du hmac ainsi que la clé AES</span>
</span></span><span class=line><span class=cl><span class=n>p1</span> <span class=o>=</span> <span class=n>binascii</span><span class=o>.</span><span class=n>unhexlify</span><span class=p>(</span><span class=s2>&#34;A612E61640B3218E&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>p2</span> <span class=o>=</span> <span class=n>binascii</span><span class=o>.</span><span class=n>unhexlify</span><span class=p>(</span><span class=s2>&#34;192C98524983EAB4&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>IV</span> <span class=o>=</span> <span class=n>paquet</span><span class=p>[</span><span class=mi>4</span><span class=p>:</span><span class=mi>4</span><span class=o>+</span><span class=mi>16</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>ciphertext</span> <span class=o>=</span> <span class=n>paquet</span><span class=p>[</span><span class=mi>4</span><span class=o>+</span><span class=mi>16</span><span class=p>:</span><span class=o>-</span><span class=mi>16</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>checksum</span> <span class=o>=</span> <span class=n>paquet</span><span class=p>[</span><span class=o>-</span><span class=mi>16</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>partial_key</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on récupère les &amp; finaux afin de connaitre les bits qui seront à 0</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>16</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>x</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>and_values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>and_values</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>16</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>and_values</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>32</span><span class=p>]</span><span class=si>:</span><span class=s2>08b</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>	<span class=n>partial_key</span> <span class=o>+=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on compte le nombre de bits à bruteforce</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=n>partial_key</span><span class=o>.</span><span class=n>count</span><span class=p>(</span><span class=s2>&#34;1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>values</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>partial_key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on bruteforce jusqu&#39;a ce que le checksum soit le même.</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=o>**</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>v</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>i</span><span class=si>:</span><span class=s2>021b</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>	<span class=n>partial_test</span> <span class=o>=</span> <span class=n>values</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>k</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>partial_test</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>partial_test</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;1&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>partial_test</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=p>[</span><span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>partial_key_test</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=s2>&#34;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>partial_test</span><span class=p>),</span> <span class=mi>2</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>16</span><span class=p>,</span> <span class=s2>&#34;big&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>key2</span> <span class=o>=</span> <span class=n>hmac</span><span class=o>.</span><span class=n>new</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	    <span class=nb>bytes</span><span class=p>(</span><span class=n>hmac_key</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	    <span class=n>msg</span><span class=o>=</span><span class=nb>bytes</span><span class=p>(</span><span class=n>partial_key_test</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>	    <span class=n>digestmod</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>out</span> <span class=o>=</span> <span class=n>hmac</span><span class=o>.</span><span class=n>new</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	    <span class=n>key2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	    <span class=n>msg</span><span class=o>=</span><span class=n>p1</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;little&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	    <span class=n>digestmod</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>final_key</span> <span class=o>=</span> <span class=n>hmac</span><span class=o>.</span><span class=n>new</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	    <span class=n>out</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	    <span class=n>msg</span><span class=o>=</span><span class=n>paquet</span><span class=p>[:</span><span class=o>-</span><span class=mi>16</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	    <span class=n>digestmod</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>final_key</span><span class=p>[:</span><span class=mi>16</span><span class=p>]</span> <span class=o>==</span> <span class=n>checksum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on calcule la clé de chiffrement AES</span>
</span></span><span class=line><span class=cl><span class=n>out</span> <span class=o>=</span> <span class=n>hmac</span><span class=o>.</span><span class=n>new</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nb>bytes</span><span class=p>(</span><span class=n>key2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>msg</span><span class=o>=</span><span class=n>p2</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;little&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>digestmod</span><span class=o>=</span><span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span>
</span></span><span class=line><span class=cl><span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># on déchiffre les données.</span>
</span></span><span class=line><span class=cl><span class=n>decipher</span> <span class=o>=</span> <span class=n>AES</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>out</span><span class=p>[:</span><span class=mi>16</span><span class=p>],</span><span class=n>AES</span><span class=o>.</span><span class=n>MODE_CBC</span><span class=p>,</span> <span class=n>IV</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plaintext</span> <span class=o>=</span> <span class=n>decipher</span><span class=o>.</span><span class=n>decrypt</span><span class=p>(</span><span class=n>ciphertext</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>plaintext</span><span class=p>)</span>
</span></span></code></pre></div><p>Après quelques minutes on récupère une joli commande bash avec le flag présent à l&rsquo;intérieur :)</p><pre tabindex=0><code>╭─user@arch-vmware ~/shared/FCSC_2024/TV-HACKS-1
╰─➤  python3 bruteforce_bits.py                                                                       1 ↵
b&#39;/bin/sh\x00-c\x00echo &#34;FCSC{5d58e776e659866d110ac50dc2bce631e634222953a234893cb4978594ec0ae1}&#34; &gt; /root/flag1\x00\x00\x08\x08\x08\x08\x08\x08\x08\x08&#39;
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://trikkss.github.io/tags/reverse-engineering/>Reverse engineering</a></li><li><a href=https://trikkss.github.io/tags/linux/>Linux</a></li><li><a href=https://trikkss.github.io/tags/kernel/>Kernel</a></li><li><a href=https://trikkss.github.io/tags/qemu/>Qemu</a></li><li><a href=https://trikkss.github.io/tags/emulation/>Emulation</a></li></ul><nav class=paginav><a class=next href=https://trikkss.github.io/posts/fcsc2023_chaussette-xs/><span class=title>Next »</span><br><span>FCSC 2023 - chaussette (XS)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://trikkss.github.io/>TRIKKSS Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>